<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=10481">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=10481</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Thu Sep 12, 2013 4:14 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">DRW wrote:</div><div class="quotecontent"><div class="quotetitle">tepples wrote:</div><div class="quotecontent">&quot;$0500-$0800 3 pages for cc65 parameter stack&quot;<br /><br />That's used for local variables in C functions, and I think it can be made smaller.</div><br />Why should it be made smaller? Isn't it better to make it bigger to have more memory? Or does this make the program slower even if the stack is not fully used?<br /><br />Where in the RAM will the global variables in a C program be stored?</div><br />I was under the impression that at least one of the linker scripts floating around assumed that BSS (the segment containing global variables) would be stored in $6000-$7FFF, which isn't available on NROM unless you solder in a couple more ICs, namely a 6264 SRAM and a 74HC20 to decode it. (Family BASIC, for example, includes these ICs.) Making the stack smaller would allow moving global variables into internal memory.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Is there even a C++ compiler for 6502 programs?</div><br />There are C++ compilers that output C. In fact, the first C++ compiler was such.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">However, since I won't use any libraries, I assume it's safe to remove that stuff, right? Especially since in the default config file, after removing the WRAM stuff, the FEATURES section only has CONDES for RODATA anyway. And not for, like, STARTUP.</div><br />CONDES, STARTUP, and LOWCODE aren't needed for simple freestanding NES use. LOWCODE is useful for carts using 32K bank switching so that the code to go from one bank to another can be copied into RAM so that it's always available.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>DRW</b> [ Fri Sep 13, 2013 11:51 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Again, thanks a lot for your answers.<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">I was under the impression that at least one of the linker scripts floating around assumed that BSS (the segment containing global variables) would be stored in $6000-$7FFF, which isn't available on NROM unless you solder in a couple more ICs, namely a 6264 SRAM and a 74HC20 to decode it. (Family BASIC, for example, includes these ICs.) Making the stack smaller would allow moving global variables into internal memory.</div><br />So, is this still a fact or have you only <em>been</em> under this impression.<br /><br />From the point of view of my own configuration now, what's the best value for __STACKSIZE__?<br />And where will each variable be declared later? Where will the local variables be declared and where the global ones?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Fri Sep 13, 2013 12:44 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">DRW wrote:</div><div class="quotecontent"><div class="quotetitle">tepples wrote:</div><div class="quotecontent">I was under the impression that at least one of the linker scripts floating around assumed that BSS (the segment containing global variables) would be stored in $6000-$7FFF</div><br />So, is this still a fact or have you only <em>been</em> under this impression.</div><br />I try not to state something as authoritative fact unless I have some sort of citation or a test program or something to back it up. I used to write using more confident language on another forum for a while until I was <a href="http://forum.gbadev.org/viewtopic.php?t=13608" class="postlink">called out</a> for giving answers that turned out false. Adding extra RAM to mapper 0 with 6264+7420 is fact, backed by <a href="http://bootgod.dyndns.org:7777/profile.php?id=4028" class="postlink">PCB shots of Family BASIC v3</a> and discussions linked from <a href="http://wiki.nesdev.com/w/index.php/PRG_RAM_circuit" class="postlink">the page about this circuit</a>.<br /><br />The bit about the default ld65 linker script for NES was only my recollection because I have never used the default ld65 linker script for NES, instead using my own much simpler linker script. So I went and dug up <a href="https://github.com/oliverschmidt/cc65/blob/master/cfg/nes.cfg" class="postlink">nes.cfg on GitHub</a>. It turns out that the part I was referring to was the following in the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">MEMORY</tt> section:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; # additional 8K SRAM Bank<br />&nbsp; &nbsp; # - data (run)<br />&nbsp; &nbsp; # - bss<br />&nbsp; &nbsp; # - heap<br />&nbsp; &nbsp; RAM: file = &quot;&quot;, start = $6000, size = $2000, define = yes;<br /></div><br />So yes, the default NES linker script does assume that global variables and heap will be placed in extra memory on the cartridge mapped at $6000-$7FFF. If you don't plan to put extra memory on the cartridge, you'll have to shrink the stack or use a different output method or both in order to gain enough memory for storing your variables.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>DRW</b> [ Fri Sep 13, 2013 2:20 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Since I'm not into the programming in C part yet, I still really don't understand the inner workings of all that stuff that the C compiler and linker will do to the program. (I know how the C programing language works and I basically know about 6502 assembly now, but all those specific linker options for C-to-6502 programs are still really abstract to me.) If assembly was a bit more user-friendly, I guess I would just write it right there.*<br /><br />So, what value should I finally set for the stack if I want to write a game with the same memory outline as a simple first generation game like &quot;Donkey Kong&quot; with no extra memory or any of that stuff? And what would happen if I just omit __STACKSIZE__ at all or if I simply set it to 0?<br /><br /><br />* Isn't there some in-between language? A langauge that feels like a high level language, but where every command directly maps to the corresponding assembly commands without overhead and without the compiler doing things where you can't predict what will happen?<br />A language where you can write <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">value = status + 3</tt> and the compiler/converter maps it into the shortest possible assembly code and clears the carry flag, while during a subtraction, it would set the carry flag.<br />And where you can write expressions like <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">if &#40;value1 &lt; value2&#41;</tt>.<br />But where you can't declare local variables that are automatically cleaned up when you leave a function, but every variable is global and takes a specified memory location (maybe with automatic increment like in the segments area of CC65 assembly code).<br />And where sub functions can't have real parameters, but where you can directly access the X and Y register if you want to. And so, the X register, the Y register and the accumulator would be the only three possible parameters in a function, knowing that if you call a function inside another function and both use a certain register as a parameter, the inner function could overwrite the value that the outer function uses.<br /><br />You know, some language that let's you mostly write short and readable C-like code without that whole LDA, STA, INC, BNE etc., but that can transform 1:1 into assembly code without using any internal, hidden compiler operations that bloat the binary file. (In fact, the converter should be merely a source code converter that transforms your high level code into an assembly text file.)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Fri Sep 13, 2013 2:26 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />You'll want to look into <a href="http://shiru.untergrund.net/articles/programming_nes_games_in_c.htm" class="postlink">the library that Shiru made for writing simple NES games</a>.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Fri Sep 13, 2013 3:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&quot;In-between languages&quot; that I remember having shown up here before:<br /><a href="http://forums.nesdev.com/viewtopic.php?t=10242" class="postlink">uc65, by qbradq</a>.<br />Movax12 has had a series of &quot;writing enough macro glue to make ca65 nice&quot; posts: <a href="http://forums.nesdev.com/viewtopic.php?t=9366" class="postlink">assignment</a>, <a href="http://forums.nesdev.com/viewtopic.php?t=9272" class="postlink">comparing</a>, <a href="http://mynesdev.blogspot.ca" class="postlink">blog</a>, <a href="https://www.assembla.com/spaces/ca65hl/wiki/Integrated_Support_Macros" class="postlink">wiki</a>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>rainwarrior</b> [ Fri Sep 13, 2013 5:36 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Your stack needs to be as big as required by your program. This depends on how deep the call tree needs to go, and how many variables you put on the stack in those functions.<br /><br />Probably your call tree doesn't need to go very deep. If you need to do something that needs a deep call stack, like maybe if it's recursive, I'd recommend just writing it in assembly and using the hardware stack. CC65's stack is heavyweight and slow.<br /><br />For the same reason, it's generally good to try to keep variables on the stack to a minimum, too. I like to put some general purpose global variables into the zero page (e.g. ints i and j for for loops) so that I don't have to take the performance hit of placing them on the C stack.<br /><br />I made this music ROM a while ago using CC65, and it's open source. Feel free to take a look if you think it might be useful:<br /><br /><a href="http://rainwarrior.ca/music/coltrane.nes" class="postlink">http://rainwarrior.ca/music/coltrane.nes</a><br /><a href="http://rainwarrior.ca/music/coltrane_src.zip" class="postlink">http://rainwarrior.ca/music/coltrane_src.zip</a><br /><br />It's not a good example of a game, but it's written mostly in C, and I've whittled down the CC65 CRT to what I think is the minimum. It's an NROM game with no additional memory. (For this project I reserved 128 bytes for the C stack, but I don't think it really uses all of that. I didn't have too much trouble fitting in RAM though, so I never needed to cut it down.)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>thefox</b> [ Fri Sep 13, 2013 11:19 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">So, what value should I finally set for the stack if I want to write a game with the same memory outline as a simple first generation game like &quot;Donkey Kong&quot; with no extra memory or any of that stuff? And what would happen if I just omit __STACKSIZE__ at all or if I simply set it to 0?</div><br />As far as I know, __STACKSIZE__ is only required to be valid if you use the heap (i.e. malloc() and friends). Other than that, its value shouldn't matter.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">* Isn't there some in-between language? A langauge that feels like a high level language, but where every command directly maps to the corresponding assembly commands without overhead and without the compiler doing things where you can't predict what will happen?</div><br />Movax's CA65 macros are probably the closest thing (see lidnariq's post). NESHLA is an option as well (google it).<br /><br />There's also Atalan, but it doesn't map to assembly 1:1.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>DRW</b> [ Tue Sep 17, 2013 2:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I didn't get to have a look at the in-between languages and the libraries yet, so I'll have a look at it later.<br /><br />So, let's get back to the &quot;nes.cfg&quot; first.<br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">Your stack needs to be as big as required by your program. This depends on how deep the call tree needs to go, and how many variables you put on the stack in those functions.</div>I'd still like to know the following things about it:<br /><br />1. If I declare a local variable in a function, where in memory is it saved? At the next free spot of the RAM? Or on the next free spot at (RAM - STACKSIZE)? Or somewhere else?<br />2. Where is a local variable stored if I just omit the stack size in the cfg file?<br />3. Where is a local variable stored if the stack is full?<br />4. Where is a global vaiable stored? Next free spot of RAM?<br /><br /><div class="quotetitle">thefox wrote:</div><div class="quotecontent">As far as I know, __STACKSIZE__ is only required to be valid if you use the heap (i.e. malloc() and friends). Other than that, its value shouldn't matter.</div>5. Can somebody else confirm this? (I won't use malloc() and free() in my NES program.)<br /><br /><br />Alright, this is my current &quot;nes.cfg&quot; (I used some names that fit my style more, making the names in the SEGMENTS section explaining what they are used for while the ones in MEMORY are what they actually are hardware-wise):<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">MEMORY<br />{<br />&nbsp; &nbsp;ZERO_PAGE: start =&nbsp; &nbsp; $0, size =&nbsp; $100, type = rw,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; define = yes;<br />&nbsp; &nbsp;RAM:&nbsp; &nbsp; &nbsp; &nbsp;start =&nbsp; &nbsp; $0, size =&nbsp; $800,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;define = yes;<br />&nbsp; &nbsp;HEADER:&nbsp; &nbsp; start =&nbsp; &nbsp; $0, size =&nbsp; &nbsp;$10,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file = %O, fill = yes;<br />&nbsp; &nbsp;PRG_ROM:&nbsp; &nbsp;start = $C000, size = $4000,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file = %O, fill = yes, define = yes;<br />&nbsp; &nbsp;CHR_ROM:&nbsp; &nbsp;start =&nbsp; &nbsp; $0, size = $2000,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file = %O, fill = yes;<br />}<br /><br />SEGMENTS<br />{<br />&nbsp; &nbsp;COMMON_VARIABLES: load = ZERO_PAGE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = zp;<br />&nbsp; &nbsp;VARIABLES:&nbsp; &nbsp; &nbsp; &nbsp; load = RAM,&nbsp; &nbsp; &nbsp; &nbsp;start =&nbsp; $200, type = bss, define = yes;<br />&nbsp; &nbsp;HEADER:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;load = HEADER,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type = ro;<br />&nbsp; &nbsp;LOGIC:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load = PRG_ROM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = ro,&nbsp; define = yes;<br />&nbsp; &nbsp;DATA:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;load = PRG_ROM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = ro,&nbsp; define = yes;<br />&nbsp; &nbsp;INTERRUPTS:&nbsp; &nbsp; &nbsp; &nbsp;load = PRG_ROM,&nbsp; &nbsp;start = $FFFA, type = ro;<br />&nbsp; &nbsp;GRAPHICS:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;load = CHR_ROM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = ro;<br />}<br /><br /># We will have to see about this:<br /># SYMBOLS<br /># {<br />&nbsp; &nbsp;# __STACKSIZE__ = $300;<br /># }</div><br />Some further questions that I have about it:<br /><br />6. Is everything correct?<br />7. Do the variable names make sense?<br />8. Is this sufficient for a program written in C?<br />9. Why does ZERO_PAGE has <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">type = rw</tt> even though for everything else the type is only declared in SEGMENTS? Isn't <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">type = zp</tt> in SEGMENTS enough for the compiler to know that it's writable?<br /><br />10. Since the MEMORY section declared the hardware parts and the zero page is just a defined area in the RAM, instead of this here:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"># Memory<br />ZERO_PAGE: start = $0, size = $100, type = rw, define = yes;<br />RAM:&nbsp; &nbsp; &nbsp; &nbsp;start = $0, size = $800,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; define = yes;<br /><br />#Segments<br />COMMON_VARIABLES: load = ZERO_PAGE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type = zp;<br />VARIABLES:&nbsp; &nbsp; &nbsp; &nbsp; load = RAM,&nbsp; &nbsp; &nbsp; &nbsp;start = $200, type = bss, define = yes;</div>wouldn't it be possible and better to write this instead:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"># Memory<br />RAM: start = $0, size = $800, define = yes;<br /><br />#Segments<br />COMMON_VARIABLES: load = RAM, start =&nbsp; &nbsp;$0, size = $100, type = zp;<br />VARIABLES:&nbsp; &nbsp; &nbsp; &nbsp; load = RAM, start = $200,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = bss, define = yes;</div>? (You know, like it's done with the vectors/interrupts.)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>rainwarrior</b> [ Tue Sep 17, 2013 3:47 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">1. If I declare a local variable in a function, where in memory is it saved? At the next free spot of the RAM? Or on the next free spot at (RAM - STACKSIZE)? Or somewhere else?<br />2. Where is a local variable stored if I just omit the stack size in the cfg file?<br />3. Where is a local variable stored if the stack is full?<br />4. Where is a global vaiable stored? Next free spot of RAM?<br /></div><br /><br />1. Local variables go into a register if possible, but on the stack otherwise. (Is up to the compiler's optimization process.)<br />2. I don't know what happens if you omit __STACKSIZE__ in the cfg file. I will presume that either the CRT you are using will define a default value if undefined, or your CRT will fail to link. Personally, I made my own crt0.s (see the example I posted above) and just directly reserved stack space there. If it compiles and links, see 1 for the answer.<br />3. If the stack is full, it overflows, and your program will crash. This is simply something you have to prevent, by not letting your call stack get too deep. (Remember, stack variables are removed from the stack when the function returns. This is part of the reason why they're relatively slow as well, compared to globals.)<br />4. Global variables will be statically allocated into RAM. You can also make function-local static variables, which will also go into RAM instead of the stack.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent"><div class="quotetitle">thefox wrote:</div><div class="quotecontent">As far as I know, __STACKSIZE__ is only required to be valid if you use the heap (i.e. malloc() and friends). Other than that, its value shouldn't matter.</div><br />5. Can somebody else confirm this? (I won't use malloc() and free() in my NES program.)</div><br />I don't know how malloc() or free() are implemented in the CC65 CRT but I wouldn't recommend using them, and there should be a separate heap, they can't be on the stack... I dunno, I'd have to check its CRT implementation.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">...<br />6. Is everything correct?<br />7. Do the variable names make sense?<br />8. Is this sufficient for a program written in C?<br />9. Why does ZERO_PAGE has <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">type = rw</tt> even though for everything else the type is only declared in SEGMENTS? Isn't <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">type = zp</tt> in SEGMENTS enough for the compiler to know that it's writable?<br /></div><br />6, 7, 8. No, the segments need to have specific names for CC65's code generation to be able to use them.<br />9. They are separate definitions. You can place a read only segment into a read-write section of memory, for example.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">10. Since the MEMORY section declared the hardware parts and the zero page is just a defined area in the RAM, instead of this here: ...<br />wouldn't it be possible and better to write this instead: ...<br />(You know, like it's done with the vectors/interrupts.)</div><br />Yes, you could create a single memory block from 0 to 800 and avoid placing a segment on the stack (or create a segment for the stack) but I don't understand the motivation to do it that way. If you like it, sure, but you still end up with one segment for ZP and one segment for RAM to avoid accidentally placing stuff on the hardware stack. My own preference is one memory block for each of these three regions (0-FF, 100-1FF, 200-7FF) but if you want them all in one, that can work fine.<br /><br />In your examples where there is a separate memory block for ZP and RAM, however, I do not understand what you start RAM at 0 instead of $200. If you start it at 0 obviously it overlaps with ZP and the hardware stack, which I think is error prone;if you start needing other segments in RAM, you have to be careful none of them end up in the forbidden region-- isn't it better to just define RAM without that region in it?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>DRW</b> [ Tue Sep 17, 2013 4:16 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">1. Local variables go into a register if possible, but on the stack otherwise.</div><br />But where <em>is</em> the stack in the NES program? In the RAM section? Beginning, end, middle? Somewhere else?<br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent"><div class="quotetitle">DRW wrote:</div><div class="quotecontent"><div class="quotetitle">thefox wrote:</div><div class="quotecontent">As far as I know, __STACKSIZE__ is only required to be valid if you use the heap (i.e. malloc() and friends). Other than that, its value shouldn't matter.</div><br />5. Can somebody else confirm this? (I won't use malloc() and free() in my NES program.)</div><br />I don't know how malloc() or free() are implemented in the CC65 CRT but I wouldn't recommend using them, and there should be a separate heap, they can't be on the stack... I dunno, I'd have to check its CRT implementation.</div><br />I was rather asking: If I <em>don't</em> use malloc(), is it true that __STACKSIZE__ isn't required, as thefox assumed? And what does the stack size have to do with variables that are declared with malloc() (i.e. on the heap) anyway?<br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">6, 7, 8. No, the segments need to have specific names for CC65's code generation to be able to use them.</div><br />I thought the names can be defined at will. They really should have mentioned that this doesn't count for the C compiler.<br />So, just the segments or also the memory names?<br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">9. They are separate definitions. You can place a read only segment into a read-write section of memory, for example.</div><br />But according to that logic, shouldn't every MEMORY location have a type declaration? Why only the zero page?<br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">Yes, you could create a single memory block from 0 to 800 and avoid placing a segment on the stack (or create a segment for the stack) but I don't understand the motivation to do it that way.</div><br />It's because of what Movax12 and tepples said about the vectors location:<br /><div class="quotetitle">Movax12 wrote:</div><div class="quotecontent"><div class="quotetitle">DRW wrote:</div><div class="quotecontent">wouldn't this be more correct:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">ROM0: start = $C000, size = $3FFA, file = %O, fill = yes, define = yes;<br />ROMV: start = $FFFA, size = $6, file = %O, fill = yes;<br /></div><br /></div><br />Yes.<br />Even better: (skipping over other MEMORY and SEGMENT definitions)<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">MEMORY<br />{<br />&nbsp; &nbsp;ROM0:&nbsp; &nbsp;start = $C000, size = $4000, file = %O,&nbsp; &nbsp; fill = yes, define = yes;<br />}<br /><br />SEGMENTS<br />{<br />&nbsp; &nbsp;CODE:&nbsp; &nbsp; &nbsp;load = ROM0,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = ro,&nbsp; define = yes;<br />&nbsp; &nbsp;VECTORS:&nbsp; load = ROM0, start = $FFFA<br />}<br /></div></div><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">&quot;Why should the VECTORS be a segment inside the ROM0 memory instead of a separate memory area?&quot;<br /><br />Because it's in the same bank of the same chip, for one thing. In projects for mappers with 16K banks (UNROM, MMC1), I typically use one <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">MEMORY</tt> per bank.</div><br /><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">isn't it better to just define RAM without that region in it?</div><br />Yeah, in this combination, you're probably right.<br />So, after reading the above quotes, what is more &quot;natural&quot; for CC65: One MEMORY definition for each SEGMENT? Or one MEMORY definition for each separated part of the hardware and various SEGMENTS with their own start address and sizes?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>rainwarrior</b> [ Tue Sep 17, 2013 8:23 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'm not sure how useful it is to answer all these questions before you have even started using CC65. If you want to set up a .cfg that will work with CC65, there are a couple of examples already linked for you (like shiru's guide). It might be a better approach for you to start using one of them, and ask about problems you encounter trying to get them working.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">But where <em>is</em> the stack in the NES program? In the RAM section? Beginning, end, middle? Somewhere else?</div><br />The C stack is defined somewhere, and this depends on whose example you are working with. The only way to answer this question is to look at the CRT implementation you are using. In mine it is in a file called crt0.s, and I place it in its own segment that I called &quot;CSTACK&quot;. In the CC65 library it is also defined in a file called crt0.s and it looks like it just goes at the top of a segment called &quot;SRAM&quot; and grows down into it, but I don't recommend using the NES library that comes with CC65.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">I thought the names can be defined at will. They really should have mentioned that this doesn't count for the C compiler. So, just the segments or also the memory names?</div><br />There are a small number of segments that are required to have a specific name. Actually, you can rename them as a command line option, but this is cumbersome.<br /><a href="http://www.cc65.org/doc/cc65-2.html#ss2.1" class="postlink">http://www.cc65.org/doc/cc65-2.html#ss2.1</a><br />You will need at least these four segments defined:<br />* BSS (variables in RAM)<br />* CODE (compiled C code)<br />* DATA (writable data, is copied from ROM to RAM at startup)<br />* RODATA (read only data).<br />All of the examples have these already defined, and you should just use them.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">But according to that logic, shouldn't every MEMORY location have a type declaration? Why only the zero page?</div><br />Every MEMORY block can have a type declaration, yes, and probably should. If you don't specify you will get a default type. The point of specifying the type is that the linker will prevent you from doing things improper to the type of memory; if you don't bother you just don't get that protection, that's all. It will still build.<br /><br /><div class="quotetitle">DRW wrote:</div><div class="quotecontent">So, after reading the above quotes, what is more &quot;natural&quot; for CC65: One MEMORY definition for each SEGMENT? Or one MEMORY definition for each separated part of the hardware and various SEGMENTS with their own start address and sizes?</div><br />I use MEMORY for hardware regions, and SEGMENTs to align/fill code/data in them. As far as what CC65 needs, only the segments matter. The MEMORY is just telling the linker what to do with the SEGMENTs when you build your ROM file.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>thefox</b> [ Tue Sep 17, 2013 8:46 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">2. I don't know what happens if you omit __STACKSIZE__ in the cfg file. I will presume that either the CRT you are using will define a default value if undefined, or your CRT will fail to link. Personally, I made my own crt0.s (see the example I posted above) and just directly reserved stack space there. If it compiles and links, see 1 for the answer.</div><br /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent"><div class="quotetitle">DRW wrote:</div><div class="quotecontent"><div class="quotetitle">thefox wrote:</div><div class="quotecontent">As far as I know, __STACKSIZE__ is only required to be valid if you use the heap (i.e. malloc() and friends). Other than that, its value shouldn't matter.</div><br />5. Can somebody else confirm this? (I won't use malloc() and free() in my NES program.)</div><br />I don't know how malloc() or free() are implemented in the CC65 CRT but I wouldn't recommend using them, and there should be a separate heap, they can't be on the stack... I dunno, I'd have to check its CRT implementation.<br /></div><br />I checked the library sources and it seems it kind of depends. Some platform's default crt0.s initializes &quot;sp&quot; based on __STACKSIZE__ (e.g. C64) but others (like NES) don't use it at all.<br /><br />Here's the entire list of references to __STACKSIZE__ in the &quot;libsrc&quot; directory:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">e:\dev\cc65-xofeht-fork\libsrc&gt;grep -R __STACKSIZE__ *<br />atmos/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__ZPSAVE_LOAD__, __STACKSIZE__<br />atmos/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />atmos/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />c128/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__RAM_START__, __RAM_SIZE__, __STACKSIZE__<br />c128/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />c128/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />c64/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker generated<br />c64/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />c64/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />common/_heap.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__BSS_RUN__, __BSS_SIZE__, __STACKSIZE__<br />common/_heap.s:&nbsp; &nbsp; &nbsp; &nbsp; sbc&nbsp; &nbsp; &nbsp;#&lt;__STACKSIZE__<br />common/_heap.s:&nbsp; &nbsp; &nbsp; &nbsp; sbc&nbsp; &nbsp; &nbsp;#&gt;__STACKSIZE__<br />geos-common/system/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .import __STACKADDR__, __STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; ; Linker generated<br />geos-common/system/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda #&lt;(__STACKADDR__ + __STACKSIZE__)<br />geos-common/system/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; ldx #&gt;(__STACKADDR__ + __STACKSIZE__)<br />lynx/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__RAM_START__, __RAM_SIZE__, __STACKSIZE__<br />lynx/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />lynx/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />plus4/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker generated<br />plus4/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />plus4/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />runtime/stkchk.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker defined<br />runtime/stkchk.s:&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp;#&lt;__STACKSIZE__<br />runtime/stkchk.s:&nbsp; &nbsp; &nbsp; &nbsp; sbc&nbsp; &nbsp; &nbsp;#&gt;__STACKSIZE__<br />sim6502/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker generated<br />sim6502/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />sim6502/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; ldx&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />supervision/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker generated<br />supervision/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />supervision/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; stz&nbsp; &nbsp; &nbsp;sp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; #&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />vic20/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; .import&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__STACKSIZE__&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Linker generated<br />vic20/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&lt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br />vic20/crt0.s:&nbsp; &nbsp; &nbsp; &nbsp; lda&nbsp; &nbsp; &nbsp;#&gt;(__RAM_START__ + __RAM_SIZE__ + __STACKSIZE__)<br /></div><br /><br />So whether you need __STACKSIZE__ is a combination of 1) whether you supply your own startup code (crt0.s) 2) whether you use the heap (_heap.s uses __STACKSIZE__ to calculate the end of the heap: heapend = sp - STACKSIZE).<br /><br />stkchk.s also references __STACKSIZE__, it's presumably called iff the stack overflow checks are enabled with compiler switches.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>DRW</b> [ Wed Sep 18, 2013 12:53 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">rainwarrior wrote:</div><div class="quotecontent">I'm not sure how useful it is to answer all these questions before you have even started using CC65.</div><br />Yeah, I guess I should try to convert my sample program to how it would look in C now.<br /><br />By the way, are there any tutorials that explain you how you have to set up such a project? I know there are example programs. But I'd rather have a step-by-step explanation. I mean, looking at a huge collection of example code files, you don't really know how to begin. And I'm not a fan of the &quot;This is initialization code. You don't need to understand it and can just use it as it is&quot; mentality. I want to understand what I'm doing and not paste my project together from various different sources. And I understand it better if it's explained chronologically. Otherwise, I have to look through source code and research a whole lot of lines.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>rainwarrior</b> [ Wed Sep 18, 2013 6:47 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Problem with the &quot;nes.cfg&quot; and 1 x 16 KB PRG</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />CC65 is a hobbyist compiler, and it also targets many platforms at once, so NES development of it is a niche of a niche. It doesn't have as large a support base as you may be used to, DRW.<br /><br />There is documentation that explains all of the assembler and linker syntax, if you read it all. However, the workings of its C code generation and the CRT library are not documented much at all. That's kind of normal for a C compiler, though-- the CRT is usually a bit of a black box. This problem is also compounded by the need to customize the CRT library a little if you want to make an NES game with it.<br /><br />Shiru's guide is as close as you'll get to a tutorial, at the moment. My example is open source, but it's not a tutorial. If you want to learn about how CC65 works, start using it and take a look at the assembly code it produces.<br /><br />If you need an explanation of how some particular thing works in CC65 you can ask here, but if you want to know where we find the answers so that you can learn on your own, they're found by using CC65 and seeing what it does, and browsing the CRT library source.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>