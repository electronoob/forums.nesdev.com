<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=12&amp;t=4228" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2008-07-16T22:24:39-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=12&amp;t=4228</id>
<entry>
<author><name><![CDATA[neviksti]]></name></author>
<updated>2008-07-16T22:24:39-07:00</updated>
<published>2008-07-16T22:24:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35017#p35017</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35017#p35017"/>
<title type="html"><![CDATA[Semi-offtopic - Arithmetic coder help]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35017#p35017"><![CDATA[
Oh.  It looks like we posted at the same time.  I hope that is still useful to you.<br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent"><br />I see what you mean about hi and lo having a different MSB yet still being within the range of scale. I wonder how my updated version above is working, then ... weird.<br /></div><br />Your fix works because both the encoder and decoder have exactly the same method of handling that problem.  What you essentially did was output all bits until you regain a position that your encoder expects... so that is where you are losing compression, you are outputting bits you don't need to (but it saves you from needing any extra precision).<br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent"><br />I don't follow this part:<br />    for(i=0;if carry set;i++)   <br />        output_array[out_index-i]++;<br /><br />What do you mean by if carry set?<br /></div><br />Like in assembly language.  I mean "if carry is set from the lo or output[.] addition".  It looks messier in C like code, so I just wrote it that way so the mess wouldn't cover up the simplicity of what is going on.<br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent"><br />I don't follow how you're working with eight-bits at a time like that, either ... I suppose I'll have to get more time, and write a reference implementation to see what yours is doing, step by step.<br /></div><br />It's not that I'm working with eight bits at a time, it's just that I want to shift out 8 bits at a time.  So I need at least "scale * 256" so I can always shift out 8 bits and still have the "range bits" not overflow.<br /><br />Actually, in case there is a circumstance where two renormalizations would be needed, I guess this:<br />"if(range &lt; scale)"<br />should really be something like<br />"while(range &lt; scale)"<br />but with your current value for scale, I don't think that would ever occur.<br /><br /><br />This is fun stuff to play with, but you don't need to worry about any of this if you want to help Andreas and I figure out the remaining parts of the SPC7110 compression since the arithmetic portion has been reproduced exactly for quite awhile.  Actually, even for mode 1 we now understand how the probabilities are calculated as well.  All that we have left is trying to understand how it keeps rearranging its list of pixel values from "least likely" to "most likely".<br /><br />We're so close, but no one has found this last little pattern yet.  The data files I've been posting already abstract out the arithmetic encoding part, so you can jump in immediately if you want (although I completely understand the appeal of working your way up to it first if you wish).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=716">neviksti</a> — Wed Jul 16, 2008 10:24 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2008-07-16T22:07:19-07:00</updated>
<published>2008-07-16T22:07:19-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35016#p35016</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35016#p35016"/>
<title type="html"><![CDATA[Semi-offtopic - Arithmetic coder help]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35016#p35016"><![CDATA[
Ah, lame. I'm getting beaten by a static huffman compressor ... ugh.<br /><br />I see what you mean about hi and lo having a different MSB yet still being within the range of scale. I wonder how my updated version above is working, then ... weird.<br /><br />I don't follow this part:<br />    for(i=0;if carry set;i++)   <br />        output_array[out_index-i]++;<br /><br />What do you mean by if carry set?<br /><br />I don't follow how you're working with eight-bits at a time like that, either ... I suppose I'll have to get more time, and write a reference implementation to see what yours is doing, step by step.<br /><br />Many thanks for the info!<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Wed Jul 16, 2008 10:07 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[neviksti]]></name></author>
<updated>2008-07-16T21:45:41-07:00</updated>
<published>2008-07-16T21:45:41-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35014#p35014</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35014#p35014"/>
<title type="html"><![CDATA[Re: Semi-offtopic - Arithmetic coder help]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35014#p35014"><![CDATA[
I didn't read through all of it yet, but based on your description the errors are probably in disagreements in how rounding occurs between your encoder/decoder, or in your renormalization step.<br /><br />I can see there is at least an error in the renormalization step.<br />Here's from the encoder:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    while&#40;&#40;&#40;hi - lo&#41; + 1&#41; &lt; scale&#41; &#123;<br />      bitval = &#40;bitval &lt;&lt; 1&#41; | &#40;lo &gt;&gt; 15&#41;;<br />      if&#40;++bitpos == 8&#41; &#123; fputc&#40;bitval, fp&#41;; bitval = bitpos = 0; &#125;<br />      lo = &#40;lo &lt;&lt; 1&#41;;<br />      hi = &#40;hi &lt;&lt; 1&#41; + 1;<br />      //printf&#40;&quot;renormalize: range = %0.5x, lo = %0.4x, hi = %0.4x\n&quot;, &#40;hi - lo&#41; + 1, lo, hi&#41;;<br />    &#125;<br /></div><br /><br />Image if (in binary) hi and lo were:<br />hi = 10000000 00000001<br />lo = 01111111 11111111<br /><br />This is an extreme case, but helps make the point well.  The current range is much lower than scale, <em>but we can't determine the output bits yet!</em>.  You are shifting out the bits assuming that at this point hi and lo agree on the highest bit.  This need not be the case.<br /><br />So your code will need to be changed to have some method to give 'arbitrary precision'.  You won't run into this problem with the decoder though, it is just the encoder that has to do this extra lifting.<br /><br />There are many ways to do this, and I'll describe just one (which may be 'non-standard', Andreas can probably comment on this better than me, but this will work).  Instead of your state variables being hi and low, have your state variables be low (which includes an array of the output) and range.<br /><br />So you'd have pseudo code something like:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">uint16 lo=0 &#40;I assume this can hold values &gt; scale*256 below&#41;<br />unsigned range = 0x10000  &#40;I assume this is &gt; scale*256 below&#41;<br />byte output&#91;&#93; &#40;maybe just initially start with an array the size of the uncompressed data + a few bytes to be sure it will fit&#41;<br />out_index = 0<br /><br /><br />for each symbol &#123;<br />    get your probhi and problo values for this symbol<br /><br />    lo += range * &#40;double&#40;problo&#41; / scale&#41;<br />    for&#40;i=0;if carry set;i++&#41;    <br />        output_array&#91;out_index-i&#93;++;<br /><br />    range = range * &#40;double&#40;probhi - problo + 1&#41; / scale&#41;;<br /><br />    if&#40;range &lt; scale&#41; &#123;<br />        output_array&#91;out_index++&#93;=&#40;lo&gt;&gt;8&#41;;<br />        lo &lt;&lt;= 8;<br />        range &lt;&lt;= 8;<br />    &#125;<br />&#125;<br /><br />Then handle the remaining bits in lo &#40;you could just output them all&#41;.  Although sometimes you can save a byte or so by only outputting exactly that which is necessary to land you in the span of values of: &#40;lo&#41; &lt;= x &lt; &#40;lo + range&#41;.<br /></div><br /><br />I think that should work.<br />Regardless of how you decide to adjust your code, you of course need to make the decoder renormalization work the same to keep rounding the same between the two.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=716">neviksti</a> — Wed Jul 16, 2008 9:45 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2008-07-16T21:44:51-07:00</updated>
<published>2008-07-16T21:44:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35013#p35013</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35013#p35013"/>
<title type="html"><![CDATA[Semi-offtopic - Arithmetic coder help]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35013#p35013"><![CDATA[
Ah, found the problem. My lo variable was sometimes being set to higher than hi after performing renormalization. My fix was to just detect this and keep performing renormalization until hi was greater than or equal to lo, but this somehow seems very suboptimal to me ...<br /><br />I tried to understand the "underflow" stuff discussed <a href="http://www.arturocampos.com/ac_arithmetic.html" class="postlink">here</a>, but it made absolutely no sense to me ...<br /><br />In the end, I essentially came up with my own coder from scratch. I really don't even know if it's still technically an arithmetic coder or not. Or whether it's order-0, order-1, or whatever ... how strange.<br /><br />Anyway, the only thing that bothers me now is that <a href="http://www.sable.mcgill.ca/~ebodde/pubs/sable-tr-2007-5.pdf" class="postlink">this PDF's implementation</a> is beating mine in compression ratio.<br /><br />For shell32.dll, 8188kb, mine gets it down to 6195kb, whereas the PDF's version gets 6105kb. For Chrono Trigger (U), 4096kb, mine gets 3687kb, whereas the PDF's version gets 3616kb.<br /><br />But on the bright side, my version is more than twice as fast, even with the linear symbol search. It should be 4x as fast with a binary symbol search. I have a feeling that if I were to handle this "underflow" case correctly, I could probably equal the PDF version in compression ratio, too.<br /><br />So then, anyone have any idea what kind of coder I've implemented here, and any suggestions for compression ratio improvement? I'm not interested in speeding it up, as this is just for learning.<br /><br />New version:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;time.h&gt;<br />#include &lt;conio.h&gt;<br /><br />typedef unsigned char uint8_t;<br />typedef unsigned short uint16_t;<br />typedef unsigned long uint32_t;<br />typedef unsigned long long uint64_t;<br /><br />static const unsigned scalelimit = 511;<br /><br />void aricode&#40;const char *infn, const char *outfn&#41; &#123;<br />  FILE *fp = fopen&#40;infn, &quot;rb&quot;&#41;;<br />  if&#40;!fp&#41; return;<br /><br />  fseek&#40;fp, 0, SEEK_END&#41;;<br />  unsigned size = ftell&#40;fp&#41;;<br />  rewind&#40;fp&#41;;<br /><br />  uint8_t *data = new uint8_t&#91;size&#93;;<br />  fread&#40;data, 1, size, fp&#41;;<br />  fclose&#40;fp&#41;;<br /><br />  fp = fopen&#40;outfn, &quot;wb&quot;&#41;;<br /><br />  //========================================<br />  //generate probability tables<br />  //========================================<br /><br />  unsigned prob&#91;256&#93;;<br />  memset&#40;&amp;prob, 0, sizeof prob&#41;;<br />  for&#40;unsigned i = 0; i &lt; size; i++&#41; prob&#91;data&#91;i&#93;&#93;++;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; if&#40;!prob&#91;i&#93;&#41; prob&#91;i&#93;++;<br /><br />  unsigned scale = 0, scalar = 1;<br /><br />  //search for scalar that gets as close to scalelimit as possible,<br />  //with exceeding it ...<br />  while&#40;true&#41; &#123;<br />    unsigned scalesum = 0;<br />    for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />      unsigned p = double&#40;prob&#91;i&#93;&#41; / size * scalar;<br />      if&#40;p == 0&#41; p = 1;<br />      scalesum += p;<br />    &#125;<br />    if&#40;scalesum &gt; scalelimit&#41; &#123; scalar--; break; &#125;<br />    scalar++;<br />  &#125;<br /><br />  //now scale probabilities by said scalar ...<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />    unsigned p = double&#40;prob&#91;i&#93;&#41; / size * scalar;<br />    prob&#91;i&#93; = &#40;p == 0&#41; ? 1 : p;<br />    scale += prob&#91;i&#93;;<br />  &#125;<br /><br />//this search is much faster, but less optimal<br />//while&#40;true&#41; &#123;<br />//  scale = 0;<br />//  for&#40;unsigned i = 0; i &lt; 256; i++&#41; if&#40;!prob&#91;i&#93;&#41; prob&#91;i&#93; = 1;<br />//  for&#40;unsigned i = 0; i &lt; 256; i++&#41; scale += prob&#91;i&#93;;<br />//  if&#40;scale &lt; scalelimit&#41; break;<br />//  for&#40;unsigned i = 0; i &lt; 256; i++&#41; prob&#91;i&#93; &gt;&gt;= 1;<br />//&#125;<br /><br />  uint16_t problo&#91;256&#93;, probhi&#91;256&#93;;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />    problo&#91;i&#93; = i == 0 ? 0 : probhi&#91;i - 1&#93;;<br />    probhi&#91;i&#93; = problo&#91;i&#93; + prob&#91;i&#93;;<br />  &#125;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; probhi&#91;i&#93;--;<br /><br />  fwrite&#40;&amp;size, 1, 4, fp&#41;;<br />  fwrite&#40;probhi, 1, sizeof probhi, fp&#41;;<br /><br />  //========================================<br />  //encode<br />  //========================================<br /><br />  uint16_t lo = 0x0000;<br />  uint16_t hi = 0xffff;<br /><br />  unsigned bitpos = 0, bitval = 0;<br /><br />  for&#40;unsigned i = 0; i &lt; size; i++&#41; &#123;<br />    unsigned range = &#40;hi - lo&#41; + 1;<br />    uint8_t symbol = data&#91;i&#93;;<br /><br />    hi = lo + range * probhi&#91;symbol&#93; / scale;<br />    lo = lo + range * problo&#91;symbol&#93; / scale;<br /><br />    while&#40;lo &gt; hi || &#40;hi - lo&#41; + 1 &lt;= scale&#41; &#123;<br />      bitval = &#40;bitval &lt;&lt; 1&#41; | &#40;lo &gt;&gt; 15&#41;;<br />      if&#40;++bitpos == 8&#41; &#123; fputc&#40;bitval, fp&#41;; bitval = bitpos = 0; &#125;<br />      lo = &#40;lo &lt;&lt; 1&#41;;<br />      hi = &#40;hi &lt;&lt; 1&#41; + 1;<br />    &#125;<br />  &#125;<br /><br />  for&#40;unsigned i = 0; i &lt; 16; i++&#41; &#123;<br />    bitval = &#40;bitval &lt;&lt; 1&#41; | &#40;lo &gt;&gt; 15&#41;;<br />    if&#40;++bitpos == 8&#41; &#123; fputc&#40;bitval, fp&#41;; bitval = bitpos = 0; &#125;<br />    lo &lt;&lt;= 1;<br />  &#125;<br />  if&#40;bitpos &gt; 0&#41; fputc&#40;bitval, fp&#41;;<br /><br />  //========================================<br />  //finish<br />  //========================================<br /><br />  delete&#91;&#93; data;<br />  fclose&#40;fp&#41;;<br />&#125;<br /><br />void aridecode&#40;const char *infn, const char *outfn&#41; &#123;<br />  FILE *fp = fopen&#40;infn, &quot;rb&quot;&#41;;<br />  if&#40;!fp&#41; return;<br /><br />  fseek&#40;fp, 0, SEEK_END&#41;;<br />  unsigned size = ftell&#40;fp&#41;;<br />  rewind&#40;fp&#41;;<br /><br />  unsigned decompsize;<br />  fread&#40;&amp;decompsize, 1, 4, fp&#41;;<br />  size -= 4;<br /><br />  //========================================<br />  //read probability tables<br />  //========================================<br /><br />  uint16_t problo&#91;256&#93;, probhi&#91;256&#93;;<br />  fread&#40;probhi, 1, sizeof probhi, fp&#41;;<br />  size -= sizeof probhi;<br />  for&#40;int i = 255; i &gt;= 0; i--&#41; problo&#91;i&#93; = &#40;i == 0&#41; ? 0 : probhi&#91;i - 1&#93; + 1;<br /><br />  unsigned scale = 0;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; scale += &#40;probhi&#91;i&#93; - problo&#91;i&#93;&#41; + 1;<br /><br />  uint8_t *data = new uint8_t&#91;size&#93;;<br />  fread&#40;data, 1, size, fp&#41;;<br />  fclose&#40;fp&#41;;<br /><br />  fp = fopen&#40;outfn, &quot;wb&quot;&#41;;<br /><br />  //========================================<br />  //decode<br />  //========================================<br /><br />  uint16_t lo = 0x0000;<br />  uint16_t hi = 0xffff;<br />  uint16_t code = &#40;data&#91;0&#93; &lt;&lt; 8&#41; + data&#91;1&#93;;<br />  unsigned bitval = data&#91;2&#93;, bitpos = 0;<br />  unsigned p = 3;<br /><br />  while&#40;decompsize&#41; &#123;<br />    unsigned range = &#40;hi - lo&#41; + 1;<br />    uint16_t pos = &#40;&#40;code - lo&#41; + 1&#41; * scale / range;<br /><br />    uint8_t symbol;<br />    //O&#40;log n&#41; binary search would be ideal here.<br />    //use O&#40;n&#41; linear search for simplicity ...<br />    for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />      if&#40;pos &lt;= probhi&#91;i&#93;&#41; &#123;<br />        fputc&#40;symbol = i, fp&#41;;<br />        decompsize--;<br />        break;<br />      &#125;<br />    &#125;<br /><br />    hi = lo + range * probhi&#91;symbol&#93; / scale;<br />    lo = lo + range * problo&#91;symbol&#93; / scale;<br /><br />    while&#40;lo &gt; hi || &#40;hi - lo&#41; + 1 &lt;= scale&#41; &#123;<br />      code = &#40;code &lt;&lt; 1&#41; + &#40;&#40;bitval &gt;&gt; &#40;7 - bitpos&#41;&#41; &amp; 1&#41;;<br />      if&#40;++bitpos &gt;= 8&#41; &#123; bitval = data&#91;p++&#93;; bitpos = 0; &#125;<br />      lo = &#40;lo &lt;&lt; 1&#41;;<br />      hi = &#40;hi &lt;&lt; 1&#41; + 1;<br />    &#125;<br />  &#125;<br /><br />  //========================================<br />  //finish<br />  //========================================<br /><br />  delete&#91;&#93; data;<br />  fclose&#40;fp&#41;;<br />&#125;<br /><br />int main&#40;&#41; &#123;<br />  time_t start, end;<br /><br />  printf&#40;&quot;encoding ... &quot;&#41;;<br />  start = clock&#40;&#41;;<br />  aricode&#40;&quot;test.bin&quot;, &quot;test.ari&quot;&#41;;<br />  end = clock&#40;&#41;;<br />  printf&#40;&quot;%d clocks\n&quot;, int&#40;end - start&#41;&#41;;<br /><br />  printf&#40;&quot;decoding ... &quot;&#41;;<br />  start = clock&#40;&#41;;<br />  aridecode&#40;&quot;test.ari&quot;, &quot;output.bin&quot;&#41;;<br />  end = clock&#40;&#41;;<br />  printf&#40;&quot;%d clocks\n&quot;, int&#40;end - start&#41;&#41;;<br /><br />  printf&#40;&quot;done\n&quot;&#41;;<br />  getch&#40;&#41;;<br />  return 0;<br />&#125;</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Wed Jul 16, 2008 9:44 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2008-07-16T17:02:06-07:00</updated>
<published>2008-07-16T17:02:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35001#p35001</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35001#p35001"/>
<title type="html"><![CDATA[Semi-offtopic - Arithmetic coder help]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4228&amp;p=35001#p35001"><![CDATA[
<strong>EDIT:</strong> Got it working, see post below instead.<br /><br />Okay, trying to understand arithmetic coding, so that I can start learning QM-coding and all that. Having almost no luck.<br /><br />I was able to write an encoder, but it seems to crash whenever I try scaling the probability table up.<br /><br />For instance, the below code allows me to compress the Chrono Trigger ROM from 4096kb to 3978kb, and then decompress it successfully.<br /><br />However, when I set a range &gt; 192, it starts failing. The higher the value, the faster it fails. At 16384, compression ratio is great, getting me down to 3500kb (well, figuratively great for pure entropy coding on a mostly already compressed ROM). But I can only decompress the first four bytes correctly before errors occur.<br /><br />Can anyone shed any light on what I'm doing wrong? Many thanks in advance ...<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;conio.h&gt;<br /><br />typedef unsigned char uint8_t;<br />typedef unsigned short uint16_t;<br />typedef unsigned long uint32_t;<br />typedef unsigned long long uint64_t;<br />FILE *fp;<br />uint8_t *data;<br /><br />void aricode&#40;const char *infn, const char *outfn&#41; &#123;<br />  fp = fopen&#40;infn, &quot;rb&quot;&#41;;<br />  if&#40;!fp&#41; return;<br /><br />  fseek&#40;fp, 0, SEEK_END&#41;;<br />  unsigned size = ftell&#40;fp&#41;;<br />  rewind&#40;fp&#41;;<br /><br />  data = new uint8_t&#91;size&#93;;<br />  fread&#40;data, 1, size, fp&#41;;<br />  fclose&#40;fp&#41;;<br /><br />  fp = fopen&#40;outfn, &quot;wb&quot;&#41;;<br /><br />  //========================================<br />  //generate probability tables<br />  //========================================<br /><br />  unsigned otable&#91;256&#93;;<br />  memset&#40;&amp;otable, 0, sizeof otable&#41;;<br />  for&#40;unsigned i = 0; i &lt; size; i++&#41; otable&#91;data&#91;i&#93;&#93;++;<br /><br />  uint16_t ptable_lo&#91;256&#93;, ptable_hi&#91;256&#93;;<br />  memset&#40;&amp;ptable_lo, 0, sizeof ptable_lo&#41;;<br />  memset&#40;&amp;ptable_hi, 0, sizeof ptable_hi&#41;;<br /><br />  unsigned scale = 0;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />    //the higher the scalar, the better the compression.<br />    //optimal value would be 16384, yet this crashes with &gt; 196 ...<br />    unsigned probability = double&#40;otable&#91;i&#93;&#41; / size * 196.0;<br />    if&#40;probability == 0&#41; probability = 1;<br /><br />    unsigned prev = !i ? 0 : i - 1;<br />    ptable_lo&#91;i&#93; = ptable_hi&#91;prev&#93;;<br />    ptable_hi&#91;i&#93; = ptable_lo&#91;i&#93; + probability;<br />    scale += probability;<br />  &#125;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />    ptable_hi&#91;i&#93;--;<br />    //printf&#40;&quot;%3d range = %3d-%3d\n&quot;, i, ptable_lo&#91;i&#93;, ptable_hi&#91;i&#93;&#41;;<br />  &#125;<br />  printf&#40;&quot;scale = %d\n&quot;, scale&#41;;<br /><br />  fputc&#40;size, fp&#41;;<br />  fputc&#40;size &gt;&gt; 8, fp&#41;;<br />  fputc&#40;size &gt;&gt; 16, fp&#41;;<br />  fputc&#40;size &gt;&gt; 24, fp&#41;;<br />  fwrite&#40;ptable_lo, 1, sizeof ptable_lo, fp&#41;;<br />  fwrite&#40;ptable_hi, 1, sizeof ptable_hi, fp&#41;;<br /><br />  //========================================<br />  //encode<br />  //========================================<br /><br />  uint16_t lo = 0x0000;<br />  uint16_t hi = 0xffff;<br /><br />  unsigned bitpos = 0, bitval = 0;<br /><br />  for&#40;unsigned i = 0; i &lt; size; i++&#41; &#123;<br />    unsigned range   = &#40;hi - lo&#41; + 1;<br />    unsigned symbol = data&#91;i&#93;;<br />    unsigned problo = ptable_lo&#91;symbol&#93;;<br />    unsigned probhi = ptable_hi&#91;symbol&#93;;<br />    //printf&#40;&quot;range = %0.5x, lo = %0.4x, hi = %0.4x, sym = %0.2x, pl = %3d, ph = %3d\n&quot;, range, lo, hi, symbol, problo, probhi&#41;;<br /><br />    hi = lo + range * &#40;double&#40;probhi&#41; / scale&#41;;<br />    lo = lo + range * &#40;double&#40;problo&#41; / scale&#41;;<br /><br />    //printf&#40;&quot;adjust: range = %0.5x, lo = %0.4x, hi = %0.4x\n&quot;, &#40;hi - lo&#41; + 1, lo, hi&#41;;<br /><br />    while&#40;&#40;&#40;hi - lo&#41; + 1&#41; &lt; scale&#41; &#123;<br />      bitval = &#40;bitval &lt;&lt; 1&#41; | &#40;lo &gt;&gt; 15&#41;;<br />      if&#40;++bitpos == 8&#41; &#123; fputc&#40;bitval, fp&#41;; bitval = bitpos = 0; &#125;<br />      lo = &#40;lo &lt;&lt; 1&#41;;<br />      hi = &#40;hi &lt;&lt; 1&#41; + 1;<br />      //printf&#40;&quot;renormalize: range = %0.5x, lo = %0.4x, hi = %0.4x\n&quot;, &#40;hi - lo&#41; + 1, lo, hi&#41;;<br />    &#125;<br />  &#125;<br /><br />  if&#40;bitpos &gt; 0&#41; fputc&#40;bitval, fp&#41;;<br />  fputc&#40;lo &gt;&gt; 8, fp&#41;;<br />  fputc&#40;lo, fp&#41;;<br /><br />  //========================================<br />  //finish<br />  //========================================<br /><br />  delete&#91;&#93; data;<br />  fclose&#40;fp&#41;;<br />&#125;<br /><br />void aridecode&#40;const char *infn, const char *outfn&#41; &#123;<br />  fp = fopen&#40;infn, &quot;rb&quot;&#41;;<br />  if&#40;!fp&#41; return;<br /><br />  fseek&#40;fp, 0, SEEK_END&#41;;<br />  unsigned size = ftell&#40;fp&#41;;<br />  rewind&#40;fp&#41;;<br /><br />  unsigned decompsize = fgetc&#40;fp&#41;;<br />  decompsize |= fgetc&#40;fp&#41; &lt;&lt; 8;<br />  decompsize |= fgetc&#40;fp&#41; &lt;&lt; 16;<br />  decompsize |= fgetc&#40;fp&#41; &lt;&lt; 24;<br /><br />  //========================================<br />  //read probability tables<br />  //========================================<br /><br />  uint16_t ptable_lo&#91;256&#93;, ptable_hi&#91;256&#93;;<br />  memset&#40;&amp;ptable_lo, 0, sizeof ptable_lo&#41;;<br />  memset&#40;&amp;ptable_hi, 0, sizeof ptable_hi&#41;;<br /><br />  fread&#40;ptable_lo, 1, sizeof ptable_lo, fp&#41;;<br />  fread&#40;ptable_hi, 1, sizeof ptable_hi, fp&#41;;<br /><br />  unsigned scale = 0;<br />  for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />    scale += ptable_hi&#91;i&#93; - ptable_lo&#91;i&#93; + 1;<br />  &#125;<br />  printf&#40;&quot;scale = %3d\n&quot;, scale&#41;;<br /><br />  size -= 4;<br />  size -= sizeof ptable_lo;<br />  size -= sizeof ptable_hi;<br />  data = new uint8_t&#91;size + 64&#93;;<br />  memset&#40;data, 0, size + 64&#41;;<br />  fread&#40;data, 1, size, fp&#41;;<br />  fclose&#40;fp&#41;;<br /><br />  unsigned p = 0;<br /><br />  fp = fopen&#40;outfn, &quot;wb&quot;&#41;;<br /><br />  //========================================<br />  //decode<br />  //========================================<br /><br />  uint16_t lo = 0x0000;<br />  uint16_t hi = 0xffff;<br />  uint16_t code = 0;<br /><br />  code  = data&#91;p++&#93; &lt;&lt; 8;<br />  code |= data&#91;p++&#93;;<br /><br />  unsigned bitval = data&#91;p++&#93;, bitpos = 0;<br /><br />  unsigned outsize = 0;<br /><br />  while&#40;outsize &lt; decompsize&#41; &#123;<br />    unsigned range = &#40;hi   - lo&#41; + 1;<br />    uint16_t pos   = &#40;code - lo&#41; + 1;<br />    pos = pos * scale / range;<br /><br />    unsigned symbol;<br />    for&#40;unsigned i = 0; i &lt; 256; i++&#41; &#123;<br />      if&#40;pos &gt;= ptable_lo&#91;i&#93; &amp;&amp; pos &lt;= ptable_hi&#91;i&#93;&#41; &#123;<br />        //found symbol<br />        symbol = i;<br />        fputc&#40;symbol, fp&#41;;<br />        outsize++;<br />        break;<br />      &#125;<br />    &#125;<br /><br />    unsigned problo = ptable_lo&#91;symbol&#93;;<br />    unsigned probhi = ptable_hi&#91;symbol&#93;;<br /><br />    hi = lo + range * double&#40;probhi&#41; / scale;<br />    lo = lo + range * double&#40;problo&#41; / scale;<br /><br />    while&#40;&#40;&#40;hi - lo&#41; + 1&#41; &lt; scale&#41; &#123;<br />      code = &#40;code &lt;&lt; 1&#41; + &#40;&#40;bitval &gt;&gt; 7&#41; &amp; 1&#41;;<br />      bitval &lt;&lt;= 1;<br />      if&#40;++bitpos &gt;= 8&#41; &#123; bitval = data&#91;p++&#93;; bitpos = 0; &#125;<br />      lo = &#40;lo &lt;&lt; 1&#41;;<br />      hi = &#40;hi &lt;&lt; 1&#41; + 1;<br />    &#125;<br />  &#125;<br /><br />  //========================================<br />  //finish<br />  //========================================<br /><br />  delete&#91;&#93; data;<br />  fclose&#40;fp&#41;;<br />&#125;<br /><br />int main&#40;&#41; &#123;<br />  aricode&#40;&quot;test.bin&quot;, &quot;test.ari&quot;&#41;;<br />  aridecode&#40;&quot;test.ari&quot;, &quot;output.bin&quot;&#41;;<br /><br />  printf&#40;&quot;done\n&quot;&#41;;<br />  getch&#40;&#41;;<br />  return 0;<br />&#125;</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Wed Jul 16, 2008 5:02 pm</p><hr />
]]></content>
</entry>
</feed>