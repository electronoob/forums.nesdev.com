<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=3957" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2008-03-09T12:41:49-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=3957</id>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2008-03-09T12:41:49-07:00</updated>
<published>2008-03-09T12:41:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31588#p31588</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31588#p31588"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31588#p31588"><![CDATA[
I hadn't really thought about objects that change on the world map. There are a few that actually do. Most of the time, the world map remains the same. I could probably do something where I draw an object's final state on the map, and then I can draw over it if it's supposed to appear different. But I just thought of an idea, I don't know if it's good or not. It could end up saving me a lot of time. So for the RPG map, you know I have to start out at the beginning of a row and decompress my way to the end. This felt to me like a nice/clean/professional way to do it. However, I could save myself A LOT of time by keeping where the pointers are when they stop decompressing in each row on screen. This might be a little complicated, but I'm pretty sure that in the end, it will save me a lot of time.<br /><br />As for the platformer, I'm still a little unsure about the exact level format. I don't know if this sounds weird or not, but I want to still make everything have 16-bit coordinates as if the whole map were one big level. So each room doesn't have a 0,0 coordinate. Since the map is 64x60 screens, I don't see why I should seperate them. But I was thinking of also still keeping all the screen definitions together, and not organize them by room. Just because if I were to define the rooms all in blocks, the "squares" drawn around each room would overlap, which means I'd be wasting space.<br /><br />I'll see about applying the idea I had about saving pointer status to my RPG map. It really could save me a lot of time.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Sun Mar 09, 2008 12:41 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2008-03-09T10:28:22-07:00</updated>
<published>2008-03-09T10:28:22-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31586#p31586</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31586#p31586"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31586#p31586"><![CDATA[
<div class="quotetitle">Bregalad wrote:</div><div class="quotecontent"><br />For example if you want an enemy who is a statue, and when the player approaches it the statue starts to move and attack him. If you do only a sprite approach, when the statue will be scrolled in screen, it will most likely be viewable that it's made of sprites, and the player won't be tricked (especially in my game, where a whole map is scrolled at a time without any care to sprites before it's fully scrolled), so that's not a good approach. However, if you made it BG, and then have the object replace the statue graphics by some other metatile, but then create its own statue sprite, everything will be fine. You then need RAM so that when the player open the menu and close it, you know if you what metatile to draw, that can be a different one than the original when the map was loaded.<br /></div><br />There are different ways to go about this. In my game, background objects are never defined in the level map. They are defined along with all other objects, and they watch the drawing of rows and columns to draw their graphics. To "erase" them I have to read the metatiles from the level map.<br /><br />But I agree that, in this particular case, it is better to have a copy of what exactly is on screen. Then again, RPGs and platformers are totally different games.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sun Mar 09, 2008 10:28 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2008-03-09T02:13:42-07:00</updated>
<published>2008-03-09T02:13:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31584#p31584</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31584#p31584"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31584#p31584"><![CDATA[
Well, scales are often unrealistic. It's very common to see game characters that are as tall as a tree, and sometimes even as tall as a town or only half of the size of a castle (Dragon Warrior, Final Fantasy !)<br /><br />Also, what compression method to use really depends on how you want the game to be. Celius's platformer seems to really need to work with screens, as the game has been designed that way. All white areas don't have to be encoded as long as the scrolling engine doesn't allow scrolling when a screen isn't present in that direction. In the case where screens always scroll only one direction, this even allow clever switching to horizontal and vertical mirroring so that you can always write big blocks of data to nametables without worriying about a row/column format and without having glitches. However, this won't work if scrolling to both directions is needed at the same time.<br /><br />Eventually, having bigger maps often also mean bigger metatiles and then, your decompressed map takes less space since the metatiles are enormous, and you only need to keep track of the metatiles, not lower units. After all it doesn't seem that hard to random-acess a RLE map, so yeah, if it's possible to do it without having it to RAM then do it. Personally I like the RAM approach as the map is "modifiable", but I'll admit I've never made code that modify a map like that in my game yet (but I plan to do it). It's also good with object that interact with their background. For example if you want an enemy who is a statue, and when the player approaches it the statue starts to move and attack him. If you do only a sprite approach, when the statue will be scrolled in screen, it will most likely be viewable that it's made of sprites, and the player won't be tricked (especially in my game, where a whole map is scrolled at a time without any care to sprites before it's fully scrolled), so that's not a good approach. However, if you made it BG, and then have the object replace the statue graphics by some other metatile, but then create its own statue sprite, everything will be fine. You then need RAM so that when the player open the menu and close it, you know if you what metatile to draw, that can be a different one than the original when the map was loaded.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Sun Mar 09, 2008 2:13 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2008-03-08T21:24:44-07:00</updated>
<published>2008-03-08T21:24:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31579#p31579</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31579#p31579"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31579#p31579"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">How big is a pixel in SI units? For example, if an object is 16 pixels tall, how much distance does that represent?<br /></div><br />Why do you think this is important? Because of physics formulas perhaps?</div><br />That, and a couple other reasons.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Anyway, I guess it varies a lot from game to game. A 16x16-pixel block is probably much smaller in "Rescue Rangers" or "Monster in my Pocket" than blocks that are also represented in 16x16 pixels in many other games, right?<br /></div><br />I understand that the <a href="http://en.wikipedia.org/wiki/Scale_%28map%29" class="postlink">scale</a> can vary from game to game, and it can also vary from scene to scene in one game. For example, Zelda II's overworld is scaled differently from its side-scrolling parts. The indoor areas in <a href="http://en.wikipedia.org/wiki/Pok%C3%A9mon_Red_and_Blue" class="postlink">that other game with monsters and pockets</a> are scaled differently from the outdoor areas, as is the case in plenty of other RPGs. It's just a good idea to have some sort of sense of scale while you are designing things, so that you know how big your worlds really are.<br /><br />Example 1: <a href="http://en.wikipedia.org/wiki/Sonic_the_Hedgehog_%28character%29" class="postlink">Wikipedia says Sonic is 100 cm tall</a>. This would put 32px = 1 m, meaning tokumaru's engine supports levels up to about 1 km long.<br /><br />Example 2: In Animal Crossing, an "acre" in outdoor scenes is 16 cells by 16 cells. <a href="http://www.google.com/search?q=1+acre+in+square+meters" class="postlink">Google says an acre is 4047 square meters</a>, and this puts the scale very close to 1 cell = 4 m on a side.<br /><br />My point:<br /><ol style="list-style-type: decimal"><li>A game is a scale model of an imaginary world. If you know the scale of your maps, level designs might end up more consistent. </li><li>If you have game characters talk about units of time in "frames" and units of distance in "pixels" or "screens", that blows holes in the fourth wall. </li><li>Most importantly for this topic: if you know the scale of your maps, you can figure out how big you can reasonably expect a map to be, and you can calculate what kind of compression ratio you will need. </li></ol><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Sat Mar 08, 2008 9:24 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2008-03-08T20:42:01-07:00</updated>
<published>2008-03-08T20:42:01-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31578#p31578</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31578#p31578"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31578#p31578"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />Another question that few people seem to stop to consider: How big is a pixel in SI units? For example, if an object is 16 pixels tall, how much distance does that represent?<br /></div><br />Why do you think this is important? Because of physics formulas perhaps? Anyway, I guess it varies a lot from game to game. A 16x16-pixel block is probably much smaller in "Rescue Rangers" or "Monster in my Pocket" than blocks that are also represented in 16x16 pixels in many other games, right?<br /><br /><div class="quotetitle">Celius wrote:</div><div class="quotecontent"><br />I'm going to look into applying more lookup tables to the method.<br /></div><br />If you got the ROM space to spare, this is always good. Most types of lookup tables are only bad choices for NROM games, where each byte is so very precious.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sat Mar 08, 2008 8:42 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2008-03-08T20:01:26-07:00</updated>
<published>2008-03-08T20:01:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31577#p31577</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31577#p31577"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31577#p31577"><![CDATA[
Well, some sort of good news. I've shortened my routine I posted above to fetch a tile in 98 cycles instead of the original 128. That's still not that impressive. Instead of doing all sorts of bit shifts for the X and Y coordinates, I just used a lookup table to determine the result of the mathematical procedures. I'm going to look into applying more lookup tables to the method.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Sat Mar 08, 2008 8:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2008-03-08T19:16:09-07:00</updated>
<published>2008-03-08T19:16:09-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31576#p31576</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31576#p31576"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31576#p31576"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />The point is that I'm (I'm not sure if Celius is serious about using this approach too) defending the idea that it's possible to do things differently than most games used to. When was the last time you saw a NES game with a level as large as 32768x2048 pixels?<br /></div><br />For comparison, Zelda 1's overworld is only 4096x1408px. It used 16x176 pixel metatiles.<br /><br />Another question that few people seem to stop to consider: How big is a pixel in SI units? For example, if an object is 16 pixels tall, how much distance does that represent?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Sat Mar 08, 2008 7:16 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2008-03-08T19:01:55-07:00</updated>
<published>2008-03-08T19:01:55-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31575#p31575</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31575#p31575"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31575#p31575"><![CDATA[
Yeah, in my current RPG map scrolling engine, it took longer than a frame to decode a column of metatiles. This is really really bad. It took me about 16 scanlines to decode a row with the X position as $FF. Now keep in mind that speed really varies depending on the byte size of the row. I can't really think of too many shortcuts that will allow me to not have to look at every single byte in a row. I COULD split the rows in half like Dwedit suggested. That could greatly increase the size of the map though.<br /><br />I think I'll try to rewrite my routine, and try and make it faster, but I don't know if I really can make it that much faster. There is always the option of doing row/column buffers when the game is scrolling. The fastest traveling vehicle on the world map will be able to go 4 pixels per frame. Final Fantasy games have always worked with 2x2 cells. So when you press up, you move to the 2x2 metatile above the character. So if you're in the fastest vehicle on the world map, it will take 4 frames to scroll from one spot to the next. In that time, I could find the values for the rows/columns surrounding the edges of the screen for where the character is moving to. I could even save lots of time by being able to fetch the values of one of those rows from the screen copy in RAM. For example, if you move one space to the right, the left-most column on screen will be destroyed. And it will also be put back on screen if you choose to move to the left after you've moved to the right. So I could take the column that's being destroyed and hold onto it for one of my updating options. It's an idea I thought of a while ago. So I do have 4 frames where I can do stuff between spaces.<br /><br />As for my platformer, I think the decompression will be a lot faster, since everything is compressed in blocks. The placement of everything can be calculated. However, the RPG map is different, since you have to know everything about a row to determine where exactly a metatile is.<br /><br />And it's an interesting idea, Tokumaru, your idea of "interleaved" data. I suppose things could be a lot faster that way. I think I will use the concept of rooms to make my maps. They're a little too big for complete decompression. Look at this map:<br /><br /><!-- m --><a class="postlink" href="http://guidesmedia.ign.com/guides/000336/images/normal_200_6.jpg">http://guidesmedia.ign.com/guides/00033 ... _200_6.jpg</a><!-- m --><br /><br />Each small blue square represents a screen. If you can't find one, the red ones are save rooms, which also represent a screen. This is the map of Castlevania Symphony of the Night. My map will be very similar. See how some rooms are made up of about 64 screens, which means that I won't have nearly enough room in RAM to deal with that. Oh, and Tokumaru, you were talking earlier about your blank screens issue. Look how many are blank on that map (Everything that's a white square)!<br /><br />I don't think there's much buffering I can do for my platformer. My speeds will definitely increase for updating, due to the fact that I can fetch multiple values at once. But yeah, on the fly decompression would be ideal, since I wouldn't have as many limits. I'm trying to make my game as unlimited as I can, too. I'll do some reworking and get back to you guys. Thanks for the replies!<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Sat Mar 08, 2008 7:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2008-03-08T17:01:23-07:00</updated>
<published>2008-03-08T17:01:23-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31572#p31572</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31572#p31572"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31572#p31572"><![CDATA[
I understand what you are saying, and the options you described are the ones usually used by NES games. I bet almost all games that used WRAM had their active map decompressed there. It sure is great to have quick random access to any metatile, but even WRAM is not large enough for incredibly large maps.<br /><br />I believe that Celius works with the concept of "rooms", which fit very well to the idea of fully decompressing maps to WRAM, and I really think he should do it like this.<br /><br />However, for sonic-sized levels, WRAM isn't enough to decompress all the way to the metatile level. Even the MD titles didn't do it. Levels in Sonic 1 are composed by 16x16-metatile blocks (256x256 pixels), and from Sonic 2 on they used 8x8-metatile blocks (128x128 pixels). With blocks that large you can really build enormous levels. The SMS Sonic games had decompressed levels in RAM, but the basic blocks are 32x32 pixels large. Levels weren't really big, because only 4KB of RAM was dedicated to them I think.<br /><br />The point is that I'm (I'm not sure if Celius is serious about using this approach too) defending the idea that it's possible to do things differently than most games used to. When was the last time you saw a NES game with a level as large as 32768x2048 pixels? I can't even think of a Sonic game that had a level this large. In my engine it is possible, because of this unusual technique.<br /><br />I agree with you that reading individual metatiles is not the fastest task in the game, but i don't think it will cause problems either, as the process isn't THAT slow. There are a few other purposes to reading individual metatiles other than testing for collisions... such as redrawing the background where there was a background object. Such objects aren't very large though.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sat Mar 08, 2008 5:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2008-03-08T11:55:07-07:00</updated>
<published>2008-03-08T11:55:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31560#p31560</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31560#p31560"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31560#p31560"><![CDATA[
Well, in the case of a RPG overworld, you don't bother as much with speed as in a sonic game <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";-)" title="Wink" /><br /><br />Anyway I don't know if it's better to do slow random acess on each row, or slow decompression on each 16 metatiles. In any case, the game would have to be designed so it doesn't lag (or if it does that's just for a frame). Honnestly, a one-frame lag on each 31 metatiles would hardly be noticeable in a RPG when scrolling at the standard 1 pixel per frame speed. Since the player crosses 16-pixel metatiles at a time, the game engine could easily separate the decompressing process in 16 equal parts, so that it does a little of processing in each frame when the player moves beyond screen boundaries.<br /><br />For platformers, more speed is certainly needed, and Celius seems to work with really big metatiles (8x8 tiles), there is only 4x4 of them on the screen at once, that's quite big. I use 4x4 tiles metatiles in the game I'm currently making, and I'm fine with them. A decompressed map is 8x6 metatiles (that leaves room for the status bar) and take 64 bytes of RAM, easily workable in a cartridge with no extra RAM. While I only have one of them loaded at the time currently, I could easily made 2 or 4 of them fit in memory. For platformers I guess the best option is then to still buffer the maps in RAM, because random acess to them rocks (especially in the case where you'd want to re-update the metatiles for other resons than scrolling, which is the case in my game). In any RPG, you're SURE that this will be needed, because of the menus, and additionally some details like doors and chests that are open/closed, or some other background alteration will be needed for most RPGs.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Sat Mar 08, 2008 11:55 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2008-03-08T11:15:35-07:00</updated>
<published>2008-03-08T11:15:35-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31558#p31558</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31558#p31558"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31558#p31558"><![CDATA[
Bregalad, I first considered decompressing 4 screens to RAM, But I figured it could be a slow process (decoding 2 of them, I mean... maybe even 3 when moving diagonally sometimes) and could cause some lag every few seconds when moving really fast.<br /><br />Plus, when you have a limited number of screens loaded, it's not possible to keep track of anything else in the level besides an area slightly larger than the camera. Not that you'll want to have many active objects far away from the camera, because that'd sure be slow, but at least you have the option, in case a particular object needs it. Celius once told me that he needed a boss to keep moving inside it's (quite large) arena even when away from the camera. If not decompressing on the fly, he'd have to buffer the whole arena.<br /><br />Random access to any part of the level is a pretty good advantage overall. You can even have the player moving faster than the camera without worrying about him colliding with the wrong metatiles.<br /><br />And what I'm saying is, althought at first it may look a bit more complicated to read a compressed map directly, once you have the optimized code working it can be done at decent speeds.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sat Mar 08, 2008 11:15 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2008-03-08T03:27:52-07:00</updated>
<published>2008-03-08T03:27:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31536#p31536</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31536#p31536"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31536#p31536"><![CDATA[
If I were to do a large 4-way map handler (either RPG or platformer), I'd definitely decompress the data of 4 "screens" simuntaneously in RAM, so that you can randomly acess each metatile easily. Assuming a "screen" is 32x32 metatiles large, the RAM area needed would be 64x64 bytes, that is 4k. Oh I didn't exept it to be so large before writing this <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";-)" title="Wink" /><br />Anyway, using that method, whenever the player is scolling to a screen, the game should decompress the 2 nexts (either 2 horizontal or 2 vertical) and store it to the unused RAM area on the fly. For example if the player walks down, then as soon as the metatile 31 is out of the top border screen, the game loads the 2 next horizontal screens. This would allow better compression than RLE tough, as the data is only decoded once, and in a sequential order.<br /><br />For random-acessing RLE maps, effectively the best way would be to have a screen-based format (where each screen's row is separately stored to ROM) and it shouldn't be hard to make a routine that gets them in a random order by counting literals and runs. This would allow large areas of water to use the same pointer again and again. Unfortunately, the amount of pointers needed is incredibly large.<br /><br />EDIT : I got my math all wrong above. 1 screen would be 32x30 tiles, not mtattiles, so it would only be 16x16 metatiles (rounded up for simplicity) and then 4 maps in RAM would be 1kb, not 4kb, which is much more reasonnable.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Sat Mar 08, 2008 3:27 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2008-03-07T23:26:32-07:00</updated>
<published>2008-03-07T23:26:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31535#p31535</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31535#p31535"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31535#p31535"><![CDATA[
Celius, this is how I plan on reading a single metatile out of my level map, which is compressed somewhat similarly to yours:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;-- SUBROUTINE --------------------------------------------------<br />;DESCRIPTION:<br />; Reads a single metatile from the level map.<br />;INPUT:<br />; A: index of the metatile inside the screen;<br />; X: Y coordinate of the screen;<br />; Y: X coordinate of the screen;<br />;OUTPUT:<br />; A: index of the metatile;<br />;DESTROYS: A, Y;<br />;----------------------------------------------------------------<br /><br />ReadMetatile:<br />   pha<br />   lda #&#40;&gt;ScreenLarge0&#41; &gt;&gt; 2<br />   sta LargeBlock0+1<br />   lda #&#40;&gt;LargeMedium0&#41; &gt;&gt; 2<br />   sta MediumBlock0+1<br />   lda #&#40;&gt;MediumSmall0&#41; &gt;&gt; 2<br />   sta SmallBlock0+1<br />   lda #&#40;&gt;SmallMeta0&#41; &gt;&gt; 2<br />   sta Metatile0+1<br />   pla<br /><br />   ;Set addresses of the data to read based on the coordinates of the metatile<br />   asl<br />   rol LargeBlock0+1<br />   asl<br />   rol MediumBlock0+1<br />   asl<br />   rol SmallBlock0+1<br />   asl<br />   rol Metatile0+1<br />   asl<br />   rol LargeBlock0+1<br />   asl<br />   rol MediumBlock0+1<br />   asl<br />   rol SmallBlock0+1<br />   asl<br />   rol Metatile0+1<br /><br />   ;Get the index of the screen map<br />   jsr ReadScreenMap<br /><br />   ;Y must be zero because it's not used to index data<br />   ldy #$00<br /><br />   ;Read from structure to structure until reaching the metatile<br />   sta LargeBlock0+0<br />   lda &#40;LargeBlock0&#41;, y<br />   sta MediumBlock0+0<br />   lda &#40;MediumBlock0&#41;, y<br />   sta SmallBlock0+0<br />   lda &#40;SmallBlock0&#41;, y<br />   sta Metatile0+0<br />   lda &#40;Metatile0&#41;, y<br /><br />   ;Return<br />   rts</div><br />Obviously, in order to find the ID (I usually call this "index") of a specific metatile inside the level I must have it's coordinates. They conveniently fit into 24 bits, so I use the three 6502 registers to hold this information:<br /><br />X: YYYYYYYY<br />Y: XXXXXXX<br />A: yyyyxxxx<br /><br />This makes it possible to point to any metatile in the level. Registers X and Y hold the highest bits of each coordinate, so they are directly used to fetch the screen ID. This would be the call to "ReadScreenMap" which just uses a pre-calculated table (which has pointers to each row of the level map) to read a screen from the level map. This happens pretty quick.<br /><br />After I got the screen ID, I must read from structure to structure until I reach the metatile. To do that as quickly as possible, I set up various pointers to the data I need, and have these pointers modified by the coordinates of the metatile, because they are what in fact dictate what I want to read. These are the structures I have, all the way to the metatile:<br /><br />Screen = 2x2 large blocks (256x256 pixels)<br />Large block = 2x2 medium blocks (128x128 pixels)<br />Medium block = 2x2 small blocks (64x64 pixels)<br />Small block = 2x2 metatiles (32x32 pixels)<br />Metatile = 2x2 tiles (16x16 pixels)<br /><br />Since each of these structures is composed by 4 smaller structures there are 4 possibilities for each pointer. I first initialize the pointers with a base value, without the bits that decide which of the 4 possible areas are going to be read. Then I just shift the coordinate bits out of the accumulator into the appropriate pointers. The lower byte of the pointers is always the ID of the previous structure.<br /><br />Now that I think of it, it would probably be faster to transfer that index to Y and always keep the lower byte of the pointers as 0. But the idea is the same. I haven't tested this specific piece of code yet, because I didn't get to the point of reading individual metatiles, so I don't even know how long it takes to execute.<br /><br />I'm also rewriting much of my code now, after the switch to MMC3, and I do see some room for improvement here, so keep in mind that this isn't *exactly* what I'll be using in the final game.<br /><br />For reading rows and columns I use a completely different piece of code (which does work) that is optimized to read a series of metatiles at once. It needs twice as many pointers, because 2 structures are read from each structure this time, but the main idea of the pointers being modified by the coordinates is still there. It is a big unrolled loop, so it's pretty quick.<br /><br />I think it is absolutely possible to have your levels decoded in real time if you have it encoded like this. I can say for sure it works well when scrolling. I may not have tested the single metatile code yet, but you don't usually need to read that many single metatiles. You often just need to read about 5 of them for the main character collision, 1 or 2 for each enemy and that's probably it. So this part may not need to be extra fast, I guess.<br /><br /><strong>EDIT:</strong> Of course you need to have your data interleaved for this to work. Some of you may have noticed that I reeeaaally like interleaved data, because it's usually easier (and faster) to read. It's not as easy to define though, but that should not be a concern. I believe that data should be stored in the best possible way for the program, not for the programmer. If something is too difficult for humans to understand, you can always write simple convertion apps to do the work for you.<br /><br />Anyway, by "interleaved" (I'm not sure if this is the best word for this, so I feel like I should explain) I mean that the top left tile of all metatiles are stored sequentially, then come all the top right tiles, then the bottom left tiles, and so on. Grouping similar entities together makes it simpler to index them (for example, you can read all the tiles of a metatile by using the index of the metatile, without having to increment it after each read tile). It surely is possible to manipulate pointers if you have you data arranged in other ways, but it would probably not be as fast, as the bits of interest might then not be placed so conveniently.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Fri Mar 07, 2008 11:26 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2008-03-07T16:01:43-07:00</updated>
<published>2008-03-07T16:01:43-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31523#p31523</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31523#p31523"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31523#p31523"><![CDATA[
I'm currently making use of the 8K. I have just a little under 5k of RAM left. But that's a lot of RAM. I could really make use of that. I suppose I could decompress whole rows/columns of 8x8 metatiles at once. But still, that seems like it would take a long time. I'll write a sample routine and paste it tomorrow. I should go to bed now.<br /><br />EDIT:<br /><br />So I have made a sample routine to find the value of one 2x2 metatile in an 8x8 metatile. The routine is given X and Y coordinates for which the value can be 0-3. Keep in mind the the meta tiles are defined like this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">8x8Metatile:<br />.db Tile1, Tile2, Tile3, Tile4<br /></div><br /><br />And it will look like this on screen:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">Tile1 Tile2<br />Tile3 Tile4<br /></div><br /><br />So here's my routine. I think I know how it could be optimized slightly:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;In this routine we fetch a single 2x2 metatile out of a large 8x8 metatile.<br />;We come in with the 8x8 metatile ID that we want to fetch the value from.<br />;We also come in with X and Y coordinates for the desired 2x2 metatile.<br />;These values can range from 0-3. Since there are only 2 bits used for<br />;X and Y definitions, we will have both X and Y coords in the same byte.<br />;Like this: 0000YYXX. Of course, YY represents the two bits for the Y coord,<br />;And likewise for the X coord.<br /><br />Get2x2:<br />   lda Desired8x8ID      ;3 ;Here we get the desired pointer value. Every 4 bytes is a definition<br />   asl a         ;5 ;So if I want to see the definitions for metatile number 9, I need to point<br />   rol PointerHigh      ;10 ;to 8x8Metatiles + 36, which is 9 * 4.<br />   rol a         ;12<br />   rol PointerHigh      ;17<br />   sta PointerLow      ;20<br />   clc         ;22<br />   adc #&lt;8x8Metatiles      ;26 ;&lt;- Cycle count error. The assembler figures that out, so it's immediate, which brings<br />   sta PointerLow      ;29 ;The total down by 2.<br />   lda PointerHigh      ;32<br />   adc #&gt;8x8Metatiles      ;36 ;Same for here. Total is now down by 4<br />   sta PointerHigh      ;39<br /><br />   lda XYCoords      ;42 ;In this part, we need to take these bits: 0000Y0X0<br />   and #$08         ;44 ;And turn them into: 000000YX<br />   lsr a         ;46 ;Here we take the most significant bit of the Y coord<br />   lsr a         ;48 ;Shift it over to bit one<br />   sta TempVar      ;51 ;Save it<br />   lda XYCoords      ;54 ;Take the original value<br />   and #$02         ;56 ;AND out everything but the most significant bit of the X coord<br />   lsr a         ;58 ;Shift it over<br />   ora TempVar      ;63 ;OR it with the Y value<br />   tay         ;65 ;Put it in the Y register &#40;This gives us the 4x4 metatile we want to check&#41;<br /><br />   lda &#40;PoiniterLow&#41;,y      ;70 ;We go through the same process we did up on top for the 4x4 metatile<br />   asl a         ;72<br />   rol PointerHigh2      ;77<br />   rol a         ;79<br />   rol PointerHigh2      ;84<br />   sta PointerLow2      ;87<br />   clc         ;89<br />   adc #&lt;4x4Metatiles      ;91<br />   sta PointerLow2      ;94<br />   lda PointerHigh2      ;97<br />   adc #&gt;4x4Metatiles      ;99<br />   sta PointerHigh2      ;102<br /><br />   lda XYCoords      ;105 ;Here we take the LSB of XYCoords &#40;00000Y0X&#41;<br />   and #$04         ;107 ;And turn it into &#40;000000YX&#41;<br />   lsr a         ;109 ;This gives us our desired 2x2 metatile position<br />   sta TempVar      ;112<br />   lda XYCoords      ;115<br />   and #$01         ;117<br />   ora TempVar      ;122<br />   tay         ;124<br /><br />   lda &#40;PointerLow2&#41;,y      ;129<br />   sta Desired2x2      ;132   ;With cycle count error fixed, total is 128 cycles<br />   rts<br /><br />8x8Metatiles:<br /> .db $90,$15,$34,$92<br /> .db $B3,$10,$2A,$2A<br /> ....         ;For 256 more definitions<br /><br />4x4Metatiles:<br /> .db $25,$46,$A3,$44<br /> .db $10,$AD,$3D,$73<br /> ....         ;For 256 more definitions<br /></div><br /><br />So it takes 128 cycles to find a single tile ID. This is not good. I could reduce the overall speed for updating rows and columns by fetching multiple values at the same time. But I don't want it to take more than a scanline to find one of these tiles. And even having it take a scanline may be bad.<br /><br />My idea for optimization would be to not have the X and Y values in one byte. I could use four bytes, and I could have each bit by itself in a byte. I COULD really reduce the speed this way. Any other ideas/comments?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Fri Mar 07, 2008 4:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Dwedit]]></name></author>
<updated>2008-03-07T02:44:12-07:00</updated>
<published>2008-03-07T02:44:12-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31512#p31512</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31512#p31512"/>
<title type="html"><![CDATA[Working through compression]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=3957&amp;p=31512#p31512"><![CDATA[
You know what people did for platformers?  Add 8K of RAM into the cartridge to hold a decompressed map.  Worked for M.C.Kids and Super Mario 3.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=53">Dwedit</a> — Fri Mar 07, 2008 2:44 am</p><hr />
]]></content>
</entry>
</feed>