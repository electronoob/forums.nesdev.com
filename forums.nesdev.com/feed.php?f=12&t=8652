<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=12&amp;t=8652" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2012-05-19T17:25:14-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=12&amp;t=8652</id>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2012-05-19T17:25:14-07:00</updated>
<published>2012-05-19T17:25:14-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94113#p94113</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94113#p94113"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94113#p94113"><![CDATA[
Meet Chester.<br /><img src="http://pineight.com/mw/images/7/74/ACWW_Chester_64px.png" alt="Image" /><br />This was my character back when I played Animal Crossing.<br /><br />You could do what Animal Crossing does: store the offset between the in-game time and the system time. In Animal Crossing, I can't adjust the actual RTC time, which is protected by the system menu's privileges, but I can adjust the in-game time. This is saved as an offset (in seconds?) between the in-game time and the system time. I've used this as a time zone offset when going to different towns.<br /><br />If you implement an RTC using a time zone offset, you can save the offset whenever the player sets the RTC and then load the offset when loading a ROM. That way you get the best of #2 and #3: one RTC tick for every 21.5 million master clock cycles and none of the time-warping having an effect over power cycles.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Sat May 19, 2012 5:25 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-19T16:06:49-07:00</updated>
<published>2012-05-19T16:06:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94108#p94108</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94108#p94108"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94108#p94108"><![CDATA[
&gt; But what I meant was, did you make sure that those effects do NOT occur when NOT using DMA?<br /><br />Aside from having a very long pause between each byte transfer to send to my PC over serial UART (~17KB/s decompression rate), no.<br /><br />I suppose I can stall it out 4x as long to see if there is any difference in output.<br /><br />&gt; For RTCs there are two ways to emulate them:<br /><br />I know of three.<br /><br />1. use PC time. This is the least accurate. It will ignore your in-game features like time setting and 30-second adjust (round to nearest minute, a crude 'slight clock drift' fix.) Games will easily be able to detect this if you use save states, or slower/faster than normal emulation. And most importantly of all, FEoEZ limits you to 1995-2014. It has no events after that. Although you can push it to 2094 manually, I don't know what will happen if you do. And although there isn't a person that will care about this chip in 2094, an emulator that does this will fail then. I confess you have to be hardcore to worry about an event guaranteed to be after your own death.<br /><br />2. let the program code set the RTC time, but only tick the RTC time when a second has passed on your PC. When you unload the game, save the timestamp. When you load the game, add time - timestamp seconds to the RTC clock. The nice thing is this lets you set any time you want in the game, so the time setting stuff isn't useless. The 30-second adjust also works. And importantly, this is needed to pass the SPC7110-RTC self-test without cheating. It's pretty good about keeping your time accurate across runs of the emulator. But this one is also easily detectable via save states and speed adjustments.<br /><br />3. total RTC emulation. Let the program code set the RTC time, and tick the RTC every one emulated second. Save states save the time, load states load the time. You still do the save timestamp on unload, and time - timestamp adjust on load. 30-second adjust of course works, and the game is completely unable to detect any issues with the clock. The big downside here is that the clock desyncs very easy when you start to cheat or speed through dialogue or whatever.<br /><br />I go with option 3. Have to put accuracy before convenience. However, I'm planning to include a time-adjust tool that lets you edit the saved RTC clock to any time you want. Or perhaps I'll just store the saved RTC time in plain text or XML. Then you can just hand-edit it.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Sat May 19, 2012 4:06 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[nocash]]></name></author>
<updated>2012-05-19T11:16:59-07:00</updated>
<published>2012-05-19T11:16:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94104#p94104</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94104#p94104"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94104#p94104"><![CDATA[
&gt; when you read $4800 too quickly, but I haven't gotten to that yet.<br />&gt; Kind of afraid of that, to be honest.<br />Yes, with DMA timings, effects may be frightening. But what I meant was, did you make sure that those effects do NOT occur when NOT using DMA?<br /><br />Maybe there's always a timeout after 8 clks... or maybe a limit on the "while" loop to execute only max so-and-so-many times.<br /><br />For RTCs there are two ways to emulate them:<br />In sync with the SNES CPU: pausing the RTC when emu is paused, and running RTC at double speed when emu is set to run at double speed. From the emulation-view that'd be most accurate.<br />Or, in sync with the PC's RTC: Simply ignore anything written to the RTC registers, and always copy the current PC time to the SNES time. I think, from the user's view, that would appear more accurate.<br />In so far, I wouldn't emulate the RTC edge-cases at all. But anyways, knowing the behaviour on things like invalid BCD values would be interesting.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5211">nocash</a> — Sat May 19, 2012 11:16 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-18T21:10:04-07:00</updated>
<published>2012-05-18T21:10:04-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94075#p94075</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94075#p94075"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94075#p94075"><![CDATA[
I started another thread to discuss the decompression. It's my opinion at this point that our evolution tables are okay.<br />I think the problem is that the chip is 'glitching' out, just like the S-DD1 did. Feed it a certain input pattern and it can't handle it and goes screwy for the rest of that decompression.<br />Usually it would end up repeating the same byte forever (even after 8MB of reads) until the next decompression.<br />My bet is that Epson provided a compressor that could detect when the input would cause a problem and force a 'renormalize' to avoid it.<br />For whatever reason, $4807 -appears- to greatly exacerbate this behavior, as my output logs show errors much faster this way.<br />I believe this error is what throws off my algorithms below, because their first mismatch appears to be the first mismatch read from an offset that would fail on $480b=0.<br />So ... we really need to emulate this 'edge case' that breaks the SPC7110, but I don't have a clue how to do that. I put up a $100 bounty if anyone can figure it out.<br /><br />That said, here's the final word on $4807. Consider it a "length" parameter, and $480b.d0 is the enable setting.<br />length = $480b.d0 &amp; 1 ? $4807 : 1;  //$4807 can be zero<br /><br />The decompressor has to be modified to handle this mode.<br />First, consider that the modes work like this:<br />Mode 0 = 1bpp 8x8 (8 bytes)<br />Mode 1 = 2bpp 8x8 (16 bytes)<br />Mode 2 = 4bpp 8x8 (32 bytes)<br />Mode 3 = invalid (doesn't start the decompression so you always get 0x00)<br />Modes 4-255 = mirrors of 0-3 (decompressor only looks at low two bits.)<br />Now every time the buffer is empty (which it obviously will be at the start of a new decompression), what you want to do is load one tile worth of -output- data from the appropriate mode. To do this, you need to generate a number of input tiles first.<br />So next, load max(1, length) tiles in to dcu_tiledata[256 * 32];<br />Yes, even if length was zero, what ends up happening is the first byte of decompressed output repeats forever, which may not be 0x00, it's up to the data.<br />Now that you have your tiles, call the current mode's below deinterleave function to generate one output tile from your input tile pool into dcu_output[32];<br />from here, $4800 can be read until it's empty (its size is based on the mode: 8, 16 or 32 bytes of data will be in here.)<br />The nice thing about doing it this way is you get rid of bitplanebuffer entirely. You can write to direct offsets during decompression now, so it's unnecessary.<br />After doing all of this, the behavior of $4807 finally becomes rather simple:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void SPC7110::deinterleave_1bpp&#40;unsigned length&#41; &#123;<br />  uint8 *target = dcu_output, *source = dcu_tiledata;<br />  for&#40;unsigned row = 0, sp = 0; row &lt; 8; row++&#41; &#123;<br />    target&#91;row&#93; = source&#91;sp&#93;;<br />    sp += length;<br />  &#125;<br />&#125;<br /><br />void SPC7110::deinterleave_2bpp&#40;unsigned length&#41; &#123;<br />  uint8 *target = dcu_output, *source = dcu_tiledata;<br />  for&#40;unsigned row = 0, sp = 0; row &lt; 8; row++&#41; &#123;<br />    target&#91;row * 2 + 0&#93; = source&#91;sp + 0&#93;;<br />    target&#91;row * 2 + 1&#93; = source&#91;sp + 1&#93;;<br />    sp += 2 * length;<br />  &#125;<br />&#125;<br /><br />void SPC7110::deinterleave_4bpp&#40;unsigned length&#41; &#123;<br />  uint8 *target = dcu_output, *source = dcu_tiledata;<br />  for&#40;unsigned row = 0, sp = 0; row &lt; 8; row++&#41; &#123;<br />    target&#91;row * 2 +  0&#93; = source&#91;sp +  0&#93;;<br />    target&#91;row * 2 +  1&#93; = source&#91;sp +  1&#93;;<br />    target&#91;row * 2 + 16&#93; = source&#91;sp + 16&#93;;<br />    target&#91;row * 2 + 17&#93; = source&#91;sp + 17&#93;;<br />    //the purpose of this is that every time the address crosses over a 16-byte boundary, we add 16 more &#40;so it crosses a 32-byte boundary always.&#41;<br />    //this allows us to never copy the same source word to more than one target word<br />    sp = sp + 2 * length + 16 * &#40;&#40;sp + 2 * length&#41; / 16 - sp / 16&#41;;<br />  &#125;<br />&#125;</div><br /><br />Now here's the thing. Deinterleave is the best name I can come up with for what this is doing.<br />Although the actual effect on using it with data appears to be to -interleave- it, my only theory is that this is meant to compress data that was interleaved in raw form.<br />My guess is that somehow, these functions will shrink the size of the compressed data size in certain cases; but I honestly can't see how.<br /><br />So by all means ... if anyone can make sense of how this would -ever- be useful for -anything-, please let me know, so that we can name the function better.<br /><br />...<br /><br />Anyway, I still need to write emulation of the invalid BCD increment behavior on the RTC, and test some data port behaviors (want to verify the control settings register.)<br />Once that's done, I'll try and get a final doc up on how this all works. It'll be a monster, though. This chip is the epitome of edge case behavior.<br /><br />&gt; You've seen my pseudo-code decompression functions, don't you?<br /><br />They're a bit tricky to follow. I've actually already done a lot of simplifications on the original algorithm (which was designed to show you how the chip works), but it's tricky code.<br /><br />&gt; Timing might be also a problem, at least when using DMAs which expects the decompressed bytes to be ready within 8 clks. But as far as I understood, you are already using non-DMA reads for that purpose? Does that make a visible difference? More distorted results with DMA, and less distorted without DMA?<br /><br />Yes, I was using direct reads. When it comes to $4807=#$ff with mode 2, that would seem to require the SPC7110 to really go into hyperdrive. That's basically 255 bytes that need to be decompressed for every read to $4800.<br /><br />I am betting heavily that a DMA will result in seeing the same value repeated when you read $4800 too quickly, but I haven't gotten to that yet. Kind of afraid of that, to be honest. We likely need the decompression context to be threaded, and consume cycles for each byte output.<br /><br />&gt; Should I conclude the Super-FX is well known ? Because this chip always fascinated me and I always wondered how it works internally.<br /><br />Well, we are using the official mnemonics for the SuperFX opcodes, so take from that what you will. The SuperFX has less added functionality than the SA-1. The latter seemed like Nintendo was holding a contest for who could come up with the most functions to add to the chip. It's so bad that ~30-40% of the chip's functionality are never even used by ANY SA-1 games. Plus SFX doesn't allow both the CPU and chip itself to access the same memory at the same time. The SA1 does this by stalling the opcode cycles on the SA1 side when there would otherwise be a conflict. I'm sure both SFX and SA1 are missing a lot of edge case behavior, though.<br /><br />After I get the RTC BCD and data port last bits in, I'll be happy enough to consider the SPC7110 better emulated than the SFX and SA1.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Fri May 18, 2012 9:10 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2012-05-18T13:58:21-07:00</updated>
<published>2012-05-18T13:58:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94059#p94059</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94059#p94059"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94059#p94059"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Holy shit. Our entire SPC7110 emulation is substantially wrong in so many, many ways ... this is the most poorly emulated of coprocessor of all at this point, even beating out the terrible SA-1 knowledge.<br /></div><br />Should I conclude the Super-FX is well known ? Because this chip always fascinated me and I always wondered how it works internally.<br />"Mode 7" effects on sprites kicks ass.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Fri May 18, 2012 1:58 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[pichichi010]]></name></author>
<updated>2012-05-18T07:24:07-07:00</updated>
<published>2012-05-18T07:24:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94028#p94028</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94028#p94028"/>
<title type="html"><![CDATA[MAD 1 and Address Decoder 74LS139]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=94028#p94028"><![CDATA[
can an Address Decoder 74LS139 be soldered in the same socket of a MAD1 chip and work fine? (save, etc?)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5138">pichichi010</a> — Fri May 18, 2012 7:24 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[nocash]]></name></author>
<updated>2012-05-17T17:18:47-07:00</updated>
<published>2012-05-17T17:18:47-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93988#p93988</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93988#p93988"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93988#p93988"><![CDATA[
I really don't understand the decompression algorithm. You've seen my pseudo-code decompression functions, don't you? They are a bit tighter than the reverse-engineered code, eventuallly making easier to see what is going on, and to spot where overflows might occur.<br /><br />Might be useful if you log min+max values for all variables; espcially on the "top" variable. Then decompress some valid data blocks. That should give you the valid min+max ones. Then decompress some stuff that isn't intended to be decompressed, and watch cases where it exceeds the min+max values.<br /><br />Timing might be also a problem, at least when using DMAs which expects the decompressed bytes to be ready within 8 clks. But as far as I understood, you are already using non-DMA reads for that purpose? Does that make a visible difference? More distorted results with DMA, and less distorted without DMA?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5211">nocash</a> — Thu May 17, 2012 5:18 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-17T01:30:59-07:00</updated>
<published>2012-05-17T01:30:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93945#p93945</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93945#p93945"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93945#p93945"><![CDATA[
Well ... we're in trouble. More info on my board:<br /><!-- m --><a class="postlink" href="http://board.byuu.org/viewtopic.php?f=16&amp;t=2800&amp;start=15">http://board.byuu.org/viewtopic.php?f=1 ... 0&amp;start=15</a><!-- m --><br /><br />But basically, $4807 is some kind of bit deinterleave pattern.<br />I can't even begin to imagine what the hell this could be useful for, since it basically ignores lots of the decompressed output data.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  unsigned stride = 2 * mode, blocksize = 0x20 * mode;<br />  for&#40;unsigned dp = 0, sp = 0; sp &lt; buffer.size&#40;&#41; - blocksize;&#41; &#123;<br />    for&#40;unsigned base = 0x00; base &lt; 0x20; base += 0x10&#41; &#123;<br />      unsigned lp = sp + base;<br />      for&#40;unsigned word = 0; word &lt; 8; word++&#41; &#123;<br />        output&#91;dp++&#93; = buffer&#91;lp + 0&#93;, output&#91;dp++&#93; = buffer&#91;lp + 1&#93;;<br />        //this looks evil, but basically add 0x10 every time we cross a 16-byte boundary<br />        lp = lp + stride + 0x10 * &#40;&#40;lp + stride&#41; / 16 - lp / 16&#41;;<br />      &#125;<br />    &#125;<br />    sp += blocksize;<br />  &#125;</div><br /><br />(It is possible this varies per decompression mode. I haven't gotten that far yet.)<br /><br />But we have much bigger problems now. Apparently our decompression code is incomplete. It breaks down when you hit an edge case like tons of 0xFF values fed in a row. Kind of reminds me of the problem with the S-DD1 that Andreas Naive didn't emulate. The real SPC7110 seems to die and output a constant stream of the same value. Our emulation just keeps on spitting out noise.<br /><br />I cannot emulate $4807 until we emulate register $4800 correctly, because my $4807 falls apart once you start reading past where the SPC7110 dies. And even better, that's a separate issue, because I was trying to deinterleave the data logged from hardware and failed. So the deinterleave goes inside of the decompression, it's not a post-processing effect. Hence, we can't figure it out until we get regular $4800 correct.<br /><br />A DMA may fail (since you have to decode basically 0x400 bytes to get each subsequent byte of output), but my read a byte and send via USART is slow enough that the SPC7110 can keep up, even in the monstrous $4807=#$FF case.<br /><br />I need help from someone who understands the SPC7110 decompression algorithm. There's no way I can fix this myself :(<br />I can supply all the hardware logged data anyone would like, however.<br /><br />Also, $481a always reads out as 0x00. It does however increment the data ROM address as the current code describes. Still can't make $4808 return anything. RTC BCD is insane. Lots of issues with invalid data, but I should be able to RE that from the tables I dumped. 24H mode won't let you set AM/PM bit, 12M mode won't let you set D5 of Hour. RTC ready flag is set ~64 CPU clocks before it's ready. Read without ~4x NOP after and it fails. RTC has its own MDR. It goes crazy if you write to it or strobe CE while doing a 30ADJ and not waiting the 125uS. And the list goes on and on and on and on.<br /><br />&gt; that should be "remainder = dividend (lower 16 bits)", right?<br /><br />Yes, sorry for the mistake.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Thu May 17, 2012 1:30 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[nocash]]></name></author>
<updated>2012-05-16T09:03:48-07:00</updated>
<published>2012-05-16T09:03:48-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93900#p93900</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93900#p93900"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93900#p93900"><![CDATA[
&gt; On division by zero: quotient = 0, remainder = divisor (low 16-bits)<br />that should be "remainder = dividend (lower 16 bits)", right?<br />"divisor" would just mean zero (since it's division by zero).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5211">nocash</a> — Wed May 16, 2012 9:03 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[nocash]]></name></author>
<updated>2012-05-15T13:52:24-07:00</updated>
<published>2012-05-15T13:52:24-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93873#p93873</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93873#p93873"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93873#p93873"><![CDATA[
RTC-4514 Appliction Manual, 21 pages,<br /><!-- m --><a class="postlink" href="http://download.inventronik.de/MiniFlex/datasheets/rtc4513.pdf">http://download.inventronik.de/MiniFlex ... tc4513.pdf</a><!-- m --><br /><br />The time isn't cached/latched during reading, hence the WRAP bit, which tells you that the time changed during reading.<br /><br />Except, I think when setting HOLD, then the is latched, and can be read without wraps. After clearing HOLD it increments the second (if needed). The downside is that it can only "increment by 1" (ie. seconds may get lost if HOLD is set for longer time).<br /><br />And STOP should just completely stop the time.<br /><br />Hour IRQ should trigger each hour (when minutes=00).<br /><br />&gt; there is $4840.d1 ...<br />Huh. what is that? Is it write-able? Does the software use it... maybe as read/write direction flag? Or is it unused by existing code? Or maybe sth like 4bit/8bit data size selection, or serial transfer clock rate...?<br /><br />----<br /><br />Division:<br />&gt; -0x80000000 / -1 = $4828[00 00 00 80; 00 00; 01 00]<br />Good to know. Not too unusual - but note that result "should" be +80000000h (not -80000000h), though that's, of course, impossible for signed 32bit range.<br /><br />Glad to hear that "reset all maths registers to 00" stuff was bogus.<br /><br />----<br /><br />Your findings about decompression &amp; data rom access look great!<br /><br />Don't know if/how I could help there. At the moment I am trying to understand the VS Unisystem (NES-like arcade machine); my brain is currently filled with palettes, checksums, and mapper numbers - and trying to think about decompression just makes me dizzy.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5211">nocash</a> — Tue May 15, 2012 1:52 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-14T20:32:52-07:00</updated>
<published>2012-05-14T20:32:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93817#p93817</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93817#p93817"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93817#p93817"><![CDATA[
Holy shit. Our entire SPC7110 emulation is substantially wrong in so many, many ways ... this is the most poorly emulated of coprocessor of all at this point, even beating out the terrible SA-1 knowledge.<br /><br /><!-- m --><a class="postlink" href="http://byuu.org/temp/spc7110-mmio.txt">http://byuu.org/temp/spc7110-mmio.txt</a><!-- m --><br /><!-- m --><a class="postlink" href="http://byuu.org/temp/spc7110-mcu.txt">http://byuu.org/temp/spc7110-mcu.txt</a><!-- m --> (updated slightly)<br /><br />Where do I even begin ... well, notes are below.<br /><br />nocash, if you'd like to work with me on reverse engineering this more (now, or sometime in the future), feel free to reach me on IRC or somewhere else, and I can run hardware tests that you request and see what happens.<br /><br /><strong>Decompression Unit</strong><br /><br />$480b.d1 does not select between "0 = stream unmodified data ROM data; 1 = stream decompressed data ROM data." As far as I can tell, it has no effect. At least, not on my sample decompression.<br /><br />$480b.d0, however ... wow. Complete mindfuck here. When this bit is set (eg $480b = #$01 or #$03), then $4807 has radical effects on the decompressed output.<br /><br />I posted the tables of various values of $4807 in the mmio.txt file to show what effects it has on the sample decompressed output. I tried to replicate it under emulation through various means (add it to table address index, increment the data ROM read offset by $4807 instead of by 1, etc) to no avail. It ... almost looks like higher values 'compacts' the data more, but ... not quite. It's absolutely screwy. I could **really** use some help here. My worst fear is that this isn't a simple change in the decompression engine, and that there's a lot of additional functionality that we don't yet emulate. That algorithm was absolutely brutal even for neviksti to figure out.<br /><br />I've also confirmed there's nothing special about $50:xxxx. It's a big literal mirror of $4800. Nothing more, nothing less.<br /><br />The DCU status register ($480c) is substantially complex. I've been able to set and clear d0, d1, d2, d4 and d7 bits in it with various parameters. What's most wild is that it seems to start with d7 clear, then after a while d7 gets set forever, until you start a new DMA or read one byte MORE than you set for the compression length. Almost like it forces the chip to start decompressing again? And as we already knew, there's substantial waiting periods that increase more and more when you set a larger index into the decompressed data output (the chip has to decompress up to 64KB before it can start giving valid output.)<br /><br />The data ROM read address is affected by $4834 (but not by $4830-4833.)<br /><br /><strong>Data ROM read unit</strong><br /><br />First of all, the unlocking stuff is bullshit. It was a really awful guess to pass the SPC7110 first-boot self-test.<br />Basically, after power on, if you read from $4810 or $481a before writing to either $4813 or $4818, it returns 0x00.<br />All subsequent reads work as expected. Even without ever writing to any registers.<br />$4813/$4818 writes fill in the buffer, and reads from the buffer cause the SPC7110 to fetch the next byte then.<br /><br />Much worse, however, is that absolutely nothing I try will allow me to read from $481a. The SPC7110 self-test does so, and ends up reading two different values from the port. I mimicked all SPC7110 register writes and reads just like my FEoEZ does, and all I ever get is 0x00.<br /><br />Also, I really hate $4818.d5-d6, it feels like we are emulating two unique settings packed into one. And we still need to find out what happens if you force modes 3-255. Harder to do since I can't modify the data ROM, so we'll have to pick an arbitrary spot to start decoding against.<br /><br />The data ROM read address is affected by $4834 (but not by $4830-4833.)<br /><br /><strong>ALU</strong><br /><br />So there are very, very short delays before MUL/DIV results are valid. The delay length is constant (doesn't short-circuit for easier values, at least as far as my limited testing can tell.) I can't really get exact cycle counts because it completes too fast (1-2 instructions for MUL, 2-3 for DIV.) Reading early gives you pre-computed values. We *may* be able to reverse the algorithm this way, but ... fuck will that be annoying. It was hard enough for the SNES CPU.<br /><br />d0 of $482f (ALU status register) returns 1 if the last operation was a multiply, and 0 if it was a division. Nifty.<br /><br />At least our division by zero emulation was correct.<br /><br />$482e resetting all the registers was complete nonsense. It does no such thing. The only thing that register is for is for setting the signed mul/div mode.<br /><br />Side note: nocash, -0x80000000 / -1 = $4828[00 00 00 80; 00 00; 01 00] {482e=1}. Nothing unusual there.<br /><br /><strong>MCU</strong><br /><br />Nothing more than I've already found here. Still can't get $4830.d0-2 to do anything useful.<br />I did verify that even with non-zero data read from $4800 and $4810, when you read from data ROM address 0x400000+ with $4834.d0-2 = #$00-#$02 (eg not #$03), it still always returns 0x00. Same for the empty bits in registers. There doesn't appear to be an exposed MDR for the SPC7110.<br /><br /><strong>RTC</strong><br /><br />This thing has a whole ton of commands I don't yet support. But I see you've already realized that yourself. Curious how you verified exactly what type of RTC it was? Does it say it on the PCB or something? Some of the functionality of that chip will be nigh impossible to properly emulate ...<br /><br />EDIT: okay, it's a separate chip entirely with a nice part marking, neat.<br />Can I ask where you got your data sheet from? The one I found is much less verbose.<br /><br />I went ahead and emulated all of the chip functionality.<br />I do have some additional questions that I'm hoping you'll know (or the doc will say.)<br /><br />1. you list WRAP for minute, hour, day, month, day of week. But if I set all of those bits to 1 (and clear them all on CE=low of course), it breaks the FEoEZ self-test sequence. Only doing it for minute alone works as expected.<br /><br />2. might be easier to understand if you list the duty cycle as 1/128th a second to match the first rate setting's description as 1/64th. Easy enough to figure out.<br /><br />3. say you set an hour IRQ, does the bit get set when the hour counter is incremented in R4-R5? Or does it do it an hour after IRQs are enabled? Or does it do it every hour after the cart was powered on, or possibly after CE is set to high?<br /><br />4. will the IRQ still fire if the chip is in stop, hold or reset?<br /><br />5. what is the difference between stop and hold?<br /><br />6. is Epson completely silent about the test register? If it's not too screwy, maybe I'll have to stab at that one myself ...<br /><br />7. are the RTC regs cached on CE=low, or are they real-time values? That you say you have to bail out when wrap is set suggests the former ... but that seems wasteful to have all that extra RAM.<br /><br />8. how does wrapping of bad values work? Eg we can test if(++seconds &gt;= 60) minute(); or if((seconds %= 60) == 0) minute(); You mention that time/date can be corrupted on changing AM/PM ... is that from the manual? Any details on how it can be corrupted?<br /><br />9. there is $4840.d1 ... I wonder what that bit is used for. Boy I sure hope it's another RTC stop bit &lt;/sarcasm&gt;<br /><br />10. I don't think our $4842.d7 flag is good enough. It's locking up on rare occasion when I support an actual delay for clearing the flag. I will have to test that further.<br /><br />Looks like the start date is limited to 1995-2014. Guess we better get the game translated before then, huh? :P<br /><br /><strong>MMIO</strong><br /><br />In general, the CPU MDR doesn't fill in the empty bits of MMIO regs either. They're always zero no matter what.<br />But there are registers the SPC7110 doesn't respond to at all. Those return the CPU MDR.<br />And there's no other mirroring other than the repeat in banks $00-3f|80-bf. It's only in $4800-4842.<br /><br />There's a slight persistence to the registers even across power cycles.<br />It's possible to fail out the self-boot test with rapid power cycles (obviously once you pass the test once it never runs again, until you wipe the SRAM.)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Mon May 14, 2012 8:32 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-14T12:45:48-07:00</updated>
<published>2012-05-14T12:45:48-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93791#p93791</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93791#p93791"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93791#p93791"><![CDATA[
It's specifically wise to do this for ROM hacks and translations, because otherwise you can never be 100% certain a game isn't going to try and use that same RAM you think is unused and overwrite at some key point much later in the game.<br /><br />Even if you beat the entire game (with a logger to flag read from / written to RAM addresses), you may have missed some secret/bonus area or obscure event trigger.<br /><br />And considering I want a full line of 16x16 VWF space, I don't want to try and reserve a huge block of 4KB+ of WRAM.<br /><br />It would really be nice to know for sure how &gt;8KB of SRAM works on these SPC7110 carts, but unfortunately no boards ever used more, so we kind of have to guess.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Mon May 14, 2012 12:45 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2012-05-14T10:59:52-07:00</updated>
<published>2012-05-14T10:59:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93782#p93782</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93782#p93782"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93782#p93782"><![CDATA[
The SNES is very different in this regard, as an extra 8kb of SRAM is negligible compared to the system's 128kb, so there is no reason to use it for anything other than saves.<br /><br />It's not like the NES where adding 8kb of SRAM would multiply the amount of RAM by 5, and therefore it can be used for other purposes than saving games.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Mon May 14, 2012 10:59 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2012-05-14T10:31:56-07:00</updated>
<published>2012-05-14T10:31:56-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93777#p93777</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93777#p93777"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93777#p93777"><![CDATA[
I'm certain that some do, yes. SRAM isn't like Flash where you have to worry about write counts.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Mon May 14, 2012 10:31 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2012-05-14T07:15:35-07:00</updated>
<published>2012-05-14T07:15:35-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93771#p93771</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93771#p93771"/>
<title type="html"><![CDATA[fullsnes - new SNES hardware specs]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8652&amp;p=93771#p93771"><![CDATA[
<div class="quotetitle">byuu wrote:</div><div class="quotecontent"><br />Perhaps the SPC7110 designers were unaware of fixed transfer DMA (unlikely)<br /></div><br />Or it could be a design adapted from an architecture without fixed transfer DMA, or one where fixed transfer DMA is slower. Or perhaps it was just cheaper to decode that way.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />That $4830.d7 is SRAM chip enable (rather than just a write protect) was surprising. It will be annoying to have to leave that on in order to use the expanded 64kbit as scratch RAM.<br /></div><br />Do Super NES games actually use cart SRAM as scratch RAM?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon May 14, 2012 7:15 am</p><hr />
]]></content>
</entry>
</feed>