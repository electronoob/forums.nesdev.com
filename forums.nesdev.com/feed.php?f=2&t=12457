<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=12457" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2015-03-28T04:47:52-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=12457</id>
<entry>
<author><name><![CDATA[thefox]]></name></author>
<updated>2015-03-28T04:47:52-07:00</updated>
<published>2015-03-28T04:47:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143910#p143910</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143910#p143910"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143910#p143910"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />Now that I think of it, I'm not sure if only 64 bytes would be enough for keeping track of attributes, since the area covered by the camera can be slightly wider than 256 pixels depending on the alignment with the metatiles. Maybe if you force columns to be recalculated when switching scrolling directions, but I'm not sure. It's something to consider.<br /></div><br />Yeah, that's why I said &quot;roughly 64&quot; originally. I guess 9x9 = 81 bytes should be enough to cover all scenarios. But like you said, addressing the cache becomes trickier, probably need to keep a separate set of counters for the position(s) inside the attribute cache as well. For one-screen mirroring 64 bytes should be enough.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=80">thefox</a> — Sat Mar 28, 2015 4:47 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-03-27T16:12:27-07:00</updated>
<published>2015-03-27T16:12:27-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143882#p143882</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143882#p143882"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143882#p143882"><![CDATA[
<div class="quotetitle">thefox wrote:</div><div class="quotecontent"><br />Interesting. I hadn't thought about doing it on the VRAM copy side.<br /></div><br />Well, my pointers and indices were calculated during draw time, and the VRAM routine just loaded up the indices and jumped to the locations indicated by the pointers. I had separate routines for each kind of VRAM update though, but if you have something more generic already set up (i.e. &quot;copy NN bytes from XXXX to YYYY&quot;) it would probably make more sense to split rows and columns into multiple copy commands beforehand.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I believe I did partial updates in my previous scrolling engine. This time I plan to profile the code before and after any changes.<br /></div><br />Profiling would be a good idea. In my own design, the same logic I used to break name table updates in half was saving me very little time when applied to attributes to be worth the trouble. I gave up on it mostly because my VBlank time was split into &quot;VRAM update slots&quot;, and there were only 2 slots per frame. Taking the DMA transfer, scroll setting and other minor housekeeping tasks into account, there were 840 or so cycles left for each of the 2 update routines. That was enough for updating a row/column of tiles along with a full row/column of attributes, so there really was no reason to insist on the split, because the little time saved wouldn't have been used for anything.<br /><br />Again, if you use a more generic VRAM update system, it might be worth it to reduce the byte count a bit.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Good point about modifying stuff in the middle of the screen. I do want to have support for that, because of the aforementioned genericity goal.<br /></div><br />Yeah, that's a serious requirement for me. I want to be able to destroy/move background objects and have actual content behind them, not only color 0.<br /><br />Now that I think of it, I'm not sure if only 64 bytes would be enough for keeping track of attributes, since the area covered by the camera can be slightly wider than 256 pixels depending on the alignment with the metatiles. Maybe if you force columns to be recalculated when switching scrolling directions, but I'm not sure. It's something to consider.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />You mean 32 metatiles 16x16px that are aligned to the 256x256px metatiles? That's an interesting idea, too.<br /></div><br />Yeah, but I don't fully decode the 16x16s at this time, I just get their indices into a 32-byte array, in which I scan the range I'll actually need and then decode the tile indices and attributes in preparation for the VRAM updates.<br /><br />I didn't do any serious optimization in the reading of the 16x16s in my engine, but since you suggested some kind of unrolling that seemed like a nice place to do it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Hadn't thought about that one either, thanks.<br /></div><br />I'm glad to have given you something to think about. =)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Fri Mar 27, 2015 4:12 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[thefox]]></name></author>
<updated>2015-03-27T15:24:44-07:00</updated>
<published>2015-03-27T15:24:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143880#p143880</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143880#p143880"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143880#p143880"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />Not exactly a trick, more like an advice: Don't bother with vertical alignment between name tables and 256x256-pixel metatiles. Converting between map space and NT space will probably require an awkward and time-consuming division by 15. It's much simpler to just have 2 CameraY coordinates, one relative to the level (which you use to read data from the map) and another one relative to the name tables (which you use for scrolling and drawing). Just update both by the same amount every time and have the NT one wrap from 239-&gt;0 and vice-versa.<br /></div><br />Yeah, I was planning to do this. In my last scroll engine I had actually a separate set of coordinates for each edge of the view area. But I'm not sure if that was a good idea, undecided at this point about whether to do it again. Also not sure whether to do even horizontal alignment. I think it would be kind of nice if there was no requirement about the horizontal map-nametable alignment (except obviously attribute tile alignment requirement, and probably 32x32px metatile alignment would be good to have also).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I accounted for this in the code that draws the tiles to VRAM. The buffers are always 68 (rows) or 60 (columns) bytes, but the code that copied them to VRAM uses counters and/or pointers to break those in 2 parts (actually 4, since each metatile is 2x2 tiles).<br /></div><br />Interesting. I hadn't thought about doing it on the VRAM copy side.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Another advice is: don't bother with partial attribute table updates. The logic to handle name table crossing will take as much time as simply updating an entire row or column, including the parts that are off screen.<br /></div><br />Thanks. I believe I did partial updates in my previous scrolling engine. This time I plan to profile the code before and after any changes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">- Screen crossing<br /></div><br />I handle that by always preparing 2 256x256-pixel metatiles for reading. When I start decoding data from the level map, I get the index of the block where the row/column starts and the one after it. For columns, the second block isn't always used.</div><br />Ah, that's also a good point. Can easily be done since we always know there's at most two.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">- Attribute updates. Need a &quot;cache&quot; in CPU memory of the current attribute contents to be able to construct the updates non-destructively. A cache of roughly 64 bytes should be enough.<br /></div><br />I have all 128 bytes chached just to make them easier to access (i.e. the addresses are always in sync with the attribute tables), but a portion the size of the screen should indeed be enough. In fact, if you don't plan on modifying tiles in the middle of the screen, you could probably get away with keeping track of the edges of the screen only.</div><br />Good point about modifying stuff in the middle of the screen. I do want to have support for that, because of the aforementioned genericity goal.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I was thinking it might make sense to figure out all of the different scenarios (different sub-metatile starting offsets, etc) that can happen, and write (probably with macros) separate routines for handling each one of them.<br /></div><br />I considered doing this too, but routines for columns or rows starting on each of the 256 metatiles of a screen would be too insane to do, and combining that with other solutions (like a pointer system) would probably not result in such an improvement.</div><br />I wasn't actually planning to have a full set of routines for all the options, but figure out a fair set of &quot;similar&quot; ones. But yeah, not really sure yet whether I'll go with this one.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />A solution I have used at some point is to always decode rows and columns that are 32 metatiles wide/tall from the level map using the fastest possible unrolled code, and then extract from there the tiles that are actually necessary. Sounds like a waste of resources, but sometimes it's faster to just do the unrestricted full process (which can usually be optimized) and discard some of the data than worrying about boundaries, counters and such during the process.<br /><br />You could maybe write specific routines for each of the 16 rows and 16 columns, that always read 32 metatiles, and have the VRAM update code only use the part that will be visible next frame.<br /></div><br />You mean 32 metatiles 16x16px that are aligned to the 256x256px metatiles? That's an interesting idea, too. Hadn't thought about that one either, thanks.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=80">thefox</a> — Fri Mar 27, 2015 3:24 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-03-24T07:18:00-07:00</updated>
<published>2015-03-24T07:18:00-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143660#p143660</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143660#p143660"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143660#p143660"><![CDATA[
<div class="quotetitle">thefox wrote:</div><div class="quotecontent"><br />Anyway, I've been thinking of a 6502 implementation of a multidirectional map scroller now, and wanted to ask if anybody has any useful tricks when it comes to that before starting on it.<br /></div><br />Not exactly a trick, more like an advice: Don't bother with vertical alignment between name tables and 256x256-pixel metatiles. Converting between map space and NT space will probably require an awkward and time-consuming division by 15. It's much simpler to just have 2 CameraY coordinates, one relative to the level (which you use to read data from the map) and another one relative to the name tables (which you use for scrolling and drawing). Just update both by the same amount every time and have the NT one wrap from 239-&gt;0 and vice-versa.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- Nametable crossing (both vertical and horizontal). When creating PPU updates, the update needs to be split into two pieces whenever the update would cross a nametable boundary. There should be at most one nametable crossing, since it wouldn't make sense to have row/column updates longer than roughly one nametable width/height. In the typical case there's exactly one crossing.<br /></div><br />I accounted for this in the code that draws the tiles to VRAM. The buffers are always 68 (rows) or 60 (columns) bytes, but the code that copied them to VRAM uses counters and/or pointers to break those in 2 parts (actually 4, since each metatile is 2x2 tiles).<br /><br />Another advice is: don't bother with partial attribute table updates. The logic to handle name table crossing will take as much time as simply updating an entire row or column, including the parts that are off screen.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- Screen crossing. Again, there should be at most one of these per horizontal/vertical update. Not necessarily aligned with nametable crossings.<br /></div><br />I handle that by always preparing 2 256x256-pixel metatiles for reading. When I start decoding data from the level map, I get the index of the block where the row/column starts and the one after it. For columns, the second block isn't always used.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- Different sub-metatile offsets (and metatile boundary crossing). E.g. we might start a vertical update from the left or the right side of a 32x32px metatile (and likewise for the 16x16px metatile within it). Might have a different vertical starting offset, too.<br /></div><br />I use pointers to indicate which parts of the metatile I'll be reading. Each metatile has 4 children, but I only need to read 2, and based on the row/column coordinate I know which 2 those are, so I build a set of pointers before reading the data. This might not work so well in you case, since there are many 32x32-pixel metatiles inside the 256x256 ones, not only 4.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- Attribute updates. Need a &quot;cache&quot; in CPU memory of the current attribute contents to be able to construct the updates non-destructively. A cache of roughly 64 bytes should be enough.<br /></div><br />I have all 128 bytes chached just to make them easier to access (i.e. the addresses are always in sync with the attribute tables), but a portion the size of the screen should indeed be enough. In fact, if you don't plan on modifying tiles in the middle of the screen, you could probably get away with keeping track of the edges of the screen only.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I was thinking it might make sense to figure out all of the different scenarios (different sub-metatile starting offsets, etc) that can happen, and write (probably with macros) separate routines for handling each one of them.<br /></div><br />I considered doing this too, but routines for columns or rows starting on each of the 256 metatiles of a screen would be too insane to do, and combining that with other solutions (like a pointer system) would probably not result in such an improvement.<br /><br />A solution I have used at some point is to always decode rows and columns that are 32 metatiles wide/tall from the level map using the fastest possible unrolled code, and then extract from there the tiles that are actually necessary. Sounds like a waste of resources, but sometimes it's faster to just do the unrestricted full process (which can usually be optimized) and discard some of the data than worrying about boundaries, counters and such during the process.<br /><br />You could maybe write specific routines for each of the 16 rows and 16 columns, that always read 32 metatiles, and have the VRAM update code only use the part that will be visible next frame.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Tue Mar 24, 2015 7:18 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[thefox]]></name></author>
<updated>2015-03-24T05:43:53-07:00</updated>
<published>2015-03-24T05:43:53-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143657#p143657</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143657#p143657"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=143657#p143657"><![CDATA[
I settled on 256x256px metatiles of 32x32px metatiles of 16x16px metatiles for now.<br /><br />I wrote a little utility to convert flat array maps into that format. I was a bit sad to notice that the metatiles from the first level of Batman couldn't fit into the 256 32x32px metatile limit imposed by the format. I think the game originally used 32x16 metatiles.<br /><br />Anyway, I've been thinking of a 6502 implementation of a multidirectional map scroller now, and wanted to ask if anybody has any useful tricks when it comes to that before starting on it. I have implemented one multidirectional scrolling engine in the past, but I want to do this one from scratch. I've already written a prototype of such scroller in Lua, but it uses a very naive way for creating the tile updates.<br /><br />I feel like the hardest part is figuring out how to build the tile update buffers as efficiently as possible. So, here are the basic problems that need to be taken into account:<br /><br />- Nametable crossing (both vertical and horizontal). When creating PPU updates, the update needs to be split into two pieces whenever the update would cross a nametable boundary. There should be at most one nametable crossing, since it wouldn't make sense to have row/column updates longer than roughly one nametable width/height. In the typical case there's exactly one crossing.<br />- Screen crossing. Again, there should be at most one of these per horizontal/vertical update. Not necessarily aligned with nametable crossings.<br />- Different sub-metatile offsets (and metatile boundary crossing). E.g. we might start a vertical update from the left or the right side of a 32x32px metatile (and likewise for the 16x16px metatile within it). Might have a different vertical starting offset, too.<br />- Attribute updates. Need a &quot;cache&quot; in CPU memory of the current attribute contents to be able to construct the updates non-destructively. A cache of roughly 64 bytes should be enough.<br />- Different mirroring modes impose different limitations.<br /><br />I was thinking it might make sense to figure out all of the different scenarios (different sub-metatile starting offsets, etc) that can happen, and write (probably with macros) separate routines for handling each one of them.<br /><br />Any tips or tricks?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=80">thefox</a> — Tue Mar 24, 2015 5:43 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Sik]]></name></author>
<updated>2015-03-07T14:30:59-07:00</updated>
<published>2015-03-07T14:30:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142580#p142580</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142580#p142580"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142580#p142580"><![CDATA[
Eh, it probably still helps with ROM space usage, which is probably what matters most.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4526">Sik</a> — Sat Mar 07, 2015 2:30 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-03-06T15:57:22-07:00</updated>
<published>2015-03-06T15:57:22-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142522#p142522</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142522#p142522"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142522#p142522"><![CDATA[
<div class="quotetitle">Myask wrote:</div><div class="quotecontent"><br />unless one is using nametable-size &quot;screens&quot; so the cuts on the half-metatiles are already in-place.<br /></div><br />True for the misalignment, but the 4/8-way scrolling and the lack of space to put the scrolling seam still applies.<br /><br />Still, I kinda like the idea of assigning attributes to the 32x32-pixel blocks, even if some bit shifting is necessary.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Fri Mar 06, 2015 3:57 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Myask]]></name></author>
<updated>2015-03-06T15:47:31-07:00</updated>
<published>2015-03-06T15:47:31-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142521#p142521</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142521#p142521"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142521#p142521"><![CDATA[
True...unless one is using nametable-size &quot;screens&quot; so the cuts on the half-metatiles are already in-place.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6603">Myask</a> — Fri Mar 06, 2015 3:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-03-06T12:17:38-07:00</updated>
<published>2015-03-06T12:17:38-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142515#p142515</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142515#p142515"/>
<title type="html"><![CDATA[Re: Myask's map data formats maundering...]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142515#p142515"><![CDATA[
<div class="quotetitle">Myask wrote:</div><div class="quotecontent"><br />Attributes should <em>probably</em> be per-32*32px metatile under normal circumstances; this makes it easy to copy into the PPU attribute tables.<br /></div><br />Unless you scroll vertically, in which case blocks in every other screen are misaligned to the attribute grid, and will require you to do some bit shuffling in order to form the attribute bytes. Another factor is that if you're using 8 or 4-way scrolling without extra name table RAM on the cartridge, one of the axes will not have 32 continuous pixels you can modify at once without causing glitches on the opposite side of the screen, so you will have to break up the bits anyway.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Fri Mar 06, 2015 12:17 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[thefox]]></name></author>
<updated>2015-03-06T11:58:45-07:00</updated>
<published>2015-03-06T11:58:45-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142513#p142513</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142513#p142513"/>
<title type="html"><![CDATA[Re: Myask's map data formats maundering...]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142513#p142513"><![CDATA[
<div class="quotetitle">Myask wrote:</div><div class="quotecontent"><br /><span style="font-size: 50%; line-height: normal">Disclaimer: rambling.</span><br /></div><br />Now, something like this is <em>too</em> generic for my purposes. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> And it would destroy performance.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=80">thefox</a> — Fri Mar 06, 2015 11:58 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Myask]]></name></author>
<updated>2015-03-06T02:44:00-07:00</updated>
<published>2015-03-06T02:44:00-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142498#p142498</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142498#p142498"/>
<title type="html"><![CDATA[Myask's map data formats maundering...]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142498#p142498"><![CDATA[
<span style="font-size: 50%; line-height: normal">Disclaimer: rambling.</span><br /><div class="quotetitle">thefox wrote:</div><div class="quotecontent"><br />- Should be generic rather than limited.<br /></div>Unfortunately, the preferred structure of data owes a good deal to its nature. I found reading about the MIDI format (and the superclass it owes its structure to, <a href="http://www.blitter.com/~russtopia/MIDI/~jglatt/tech/aboutiff.htm" class="postlink">Interchange File Formats</a>) to be fascinating; it seems relevant. Of course, 4 bytes for chunk-identification is likely going to be massive overkill for storing level data, but there are benefits to conforming to standards: (partial) compatibility, even if you don't understand every chunk, is feasible as the sizeof field allows you to simply discard unknowns. The non-mandatory nature of chunks suggests to me, one might have 'default' collision data for a metatile, and on occasion have a chunk added to a metatile saying &quot;no, use this collision instead&quot;. Similarly, one might have a &quot;this metatile relies on this memory data&quot;; if one is not making a geomod-fanatic game, this is going to be present in relatively fewer tiles...except for the obvious case of collectibles. A simliar (possibly the same, possibly different, depending on implementation) would be one depending on <em>saved</em> (password/SRAM/etc.) data.<br /><br />Variable-length quantities, like how <a href="http://www.blitter.com/~russtopia/MIDI/~jglatt/tech/midifile/vari.htm" class="postlink">MIDI</a> does for time-deltas <span style="font-size: 50%; line-height: normal">(summary: sign bit of a byte is &quot;is there another byte to this number&quot;)</span> are a simple way of providing extreme extensibility (and, if incautious, buffer overflows) to fields.<br /><br />The problem with this is that often, map-proximate tiles are going to be source-proximate, so you'll have a lot of data redundancy if you do this on a per-tile basis. One could instead specify the first (meta)tile as absolute, and for other (meta)tiles within the (meta)tile, only specify the relative address or lower byte(s), in similar fashion, using VLQs for the subsequent ones.<br /><br />On the crazy side, there will never be a time when you need more than 18 bytes to select a graphical 8px*8px tile on the NES. (16 bytes for the tile, 2 bytes for &quot;ridiculous-mapper&quot; per-8x1-sliver attribute).<br /><br />Attributes should <em>probably</em> be per-32*32px metatile under normal circumstances; this makes it easy to copy into the PPU attribute tables.<br /><br />Collision being stored separately to graphics, and at which level? There are two obvious NES-like cases where you want them disparate (illusionary/invisible walls/structures) as well as for &quot;foreground&quot;.<br /><br />A truly-universal object would just be a function pointer &quot;run this when this scrolls in&quot;, leaving further determination in said code. Obvious extensions are a &quot;dead&quot; or status flag to say when (/not) to run it again. One could store palette changes in this fashion, with a batch at the start of the level to initialize them.<br /><br />If you are doing a &quot;net-of-screens(~256*256px(240?) metatiles)&quot; approach, then one thought is that one might wish to is that one might wish to be able to change the direction of the coordinate system of said 'screen's, so as to more easily be able to extend the level forward. The one UR-scrolling level in SMB3 would have +y be up rather than down, in this thought...but you're likely to not have any need for this sort of affair if you are creating your own tools to produce the data.<br /><br /><span style="font-size: 75%; line-height: normal">Sources: the MIDI Technical Fanatic's Brainwashing Center (mirror)</span><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6603">Myask</a> — Fri Mar 06, 2015 2:44 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-03-05T23:36:21-07:00</updated>
<published>2015-03-05T23:36:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142494#p142494</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142494#p142494"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142494#p142494"><![CDATA[
<div class="quotetitle">Dwedit wrote:</div><div class="quotecontent"><br />You might need 'Tile Destroyed' flags, such as for collecting coins, already hit question blocks, blowing up walls, etc.<br /></div><br />I like to implement all of those as actual objects, not part of the level map. Whenever the camera scrolls, the background objects check for overlaps between themselves and new rows/columns, and &quot;patch&quot; the row/column with their own tiles. This allows breakable/removable blocks to have actual graphics behind them, as apposed to just blank space. Plus, I like that the level map is just the static part, and everything you can interact with is an object.<br /><br />Objects might have permanent state bits assigned to them, so level deformation is possible, as long as the number of removable blocks isn't insanely high to the point where the CPU will have trouble dealing with so many objects or there won't be enough RAM to remember all the states.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Thu Mar 05, 2015 11:36 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[thefox]]></name></author>
<updated>2015-03-05T17:47:26-07:00</updated>
<published>2015-03-05T17:47:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142476#p142476</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142476#p142476"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142476#p142476"><![CDATA[
<div class="quotetitle">Kasumi wrote:</div><div class="quotecontent"><br />I have the map partially in RAM mainly because the screens are compressed in a way that doesn't allow random access, yeah. (Not sure if that means they're no longer considered metatiles. If so, my bad for calling them that.)<br /></div><br />Understood. I think they should still be called metatiles, this method just caught me by surprise since I haven't heard of it before. The first thing that most people would probably think would be that decompressing entire screens while the game was running would be too slow, or at least make for an uneven processing load per frame.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />A map in RAM is also cool if you have some destructibility. You only have to change the state of a tile once when you load it, rather than check if it's solid every single time an object needs to collide with it.<br /></div><br />Definitely. I hadn't even thought of the option of storing only a partial view of the map in RAM (when using a big map), although I probably won't do it because it seems complicated. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Tile drawing and collision detection both read from this RAM to get the 32x32 metatile numbers, so the first change would fix those for free. (This is also why offscreen objects may collide with the wrong things, which wouldn't be a problem with an only ROM approach.)<br /></div><br />Yeah, I had this same problem in STREEMERZ initially. I stored only the visible portion of the map in RAM, until I realized that the player should be able to interact with the walls of the upper/lower room during transitions. Since I wanted to make it behave the same way as the original, I had no option but to modify the code to load an additional couple of tile rows at the top and the bottom of the room. Of course this is not an option with a big map.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Thanks for the reply, I was afraid I was going to have to do a monologue on this one.<br /></div><br />Any time. Not like my game will ever come out anyway, may as well share the thoughts.</div><br />I guess many of us here are in the same boat. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> I have actually realized I like working on engines more than I like working on games, so I'm not going to stress about getting anything complete out of this.<br /><br /><div class="quotetitle">Dwedit wrote:</div><div class="quotecontent"><br />One way I've thought of doing it is to use a big map that corresponds directly to 8x8 areas of the map.<br /></div><br />I want to go on a record to say that it can be really confusing when people talk about &quot;8x8 areas&quot; and don't specify what unit they use (pixels? metatiles? megatiles? inches?). I assume you meant metatiles here. This is why I used pixels all over the place in the original post in case anybody was wondering. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> Still, thanks for the thought on destroyable terrain!<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br /><div class="quotetitle">thefox wrote:</div><div class="quotecontent">- Should be generic rather than limited. I don't mind losing a little bit in efficiency (in space and time) due to this. No object based formats like used in SMB1.<br /></div><br />What's wrong in general with an object-based format?</div><br />I didn't say anything was wrong with it. I said it's not a generic format, at least I think most people would feel limited by it.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=80">thefox</a> — Thu Mar 05, 2015 5:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2015-03-05T15:35:02-07:00</updated>
<published>2015-03-05T15:35:02-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142461#p142461</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142461#p142461"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142461#p142461"><![CDATA[
<div class="quotetitle">thefox wrote:</div><div class="quotecontent"><br />- Should be generic rather than limited. I don't mind losing a little bit in efficiency (in space and time) due to this. No object based formats like used in SMB1.<br /></div><br />What's wrong in general with an object-based format?<br /><br /><div class="quotetitle">Kasumi wrote:</div><div class="quotecontent"><br />A map in RAM is also cool if you have some destructibility. You only have to change the state of a tile once when you load it, rather than check if it's solid every single time an object needs to collide with it.<br /></div><br />In a 2-way scroller like SMB2, if you're not going to have destructible objects above destructible objects, you could always use a single destruction bit per column.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Thu Mar 05, 2015 3:35 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Dwedit]]></name></author>
<updated>2015-03-05T14:59:05-07:00</updated>
<published>2015-03-05T14:59:05-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142458#p142458</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142458#p142458"/>
<title type="html"><![CDATA[Re: Map data formats]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12457&amp;p=142458#p142458"><![CDATA[
You might need 'Tile Destroyed' flags, such as for collecting coins, already hit question blocks, blowing up walls, etc.<br />One way I've thought of doing it is to use a big map that corresponds directly to 8x8 areas of the map.  It would have numbers in it, such as FF for nothing destroyable, otherwise it would have a unique number for each area containing destructible tiles, think of them as 'cell numbers'.  This does not necessarily need to be in RAM, it could be in ROM.<br />Then you have the tiles destroyed bits, 8 bytes total per 'cell number', this is just the 64 bits of flags for whether tiles are destroyed or not.<br />Use a table to map a metatile to a 'destroyed' metatile.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=53">Dwedit</a> — Thu Mar 05, 2015 2:59 pm</p><hr />
]]></content>
</entry>
</feed>