<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - the Power Glove</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">the Power Glove</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>4</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roni</b> [ Sat Dec 19, 2009 8:17 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />So I've acquired access to the use of a power glove, and I've decided to research its operation, since I can't find proper documentation on it. I mean, there's all sorts of stuff out on the internal functioning, but not from a NES programmer's point of view. What interests me the most is the games that (apparently) send their own custom configuration to the glove, separate from the 14 preprogrammed settings; the only one I know of being Bad Street Brawler. As I type this I realize I should probably be dowloading and disassembling the rom and looking for code around $4016/7 accesses but it might not be that simple. Any suggestions for writing a Power Glove test ROM?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Zepper</b> [ Sat Dec 19, 2009 4:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><!-- m --><a class="postlink" href="http://nesdev.com/bbs/viewtopic.php?p=6736#6736">http://nesdev.com/bbs/viewtopi ... =6736#6736</a><!-- m -->

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roni</b> [ Sun Dec 20, 2009 9:24 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />and why does the <a href="http://wiki.nesdev.com/w/index.php/NES_controller_port_pinout" class="postlink">NES controller port pinout</a> on the wiki redirect to itself?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun Dec 20, 2009 11:04 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Oops, my bad. Fixed.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roni</b> [ Tue Jan 19, 2010 3:03 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>seriously...</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />can anyone help me figure out what this chart means? you can skip the basics, I just want to figure out how to use this information.
<br /><img src="http://i49.tinypic.com/ff1hd0.jpg" alt="Image" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Tue Jan 19, 2010 3:23 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />"LATCH" is the last value WRITTEN to D0 of $4016.
<br />"CLOCK" pulses happen whenever $4016 is READ. At that point, the CPU samples the state of lines D0, D3, and D4 from the controller; do you have traces of those?
<br />For a standard controller, LATCH goes 1 then 0, followed by 8 clocks, as seen in the data packet.
<br />But what's happening in this init sequence is the NES sending data to the controller.
<br />
<br />A bit deletion due to DPCM on this sort of stream would be a pain.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roni</b> [ Thu Jan 21, 2010 8:21 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">A bit deletion due to DPCM on this sort of stream would be a pain.</div>
<br />
<br />That's good to know...if I ever plan to use the glove beyond visual-only programs, I'll remember to take caution with the DPCM channel or not use it at all. Do you think it's necessary to wait the exact number of microseconds as specified in the diagram, or am I not understanding it correctly? Could it just be a measurement of some natural function of the NES, or some arbitrary measurement from a specific game?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Thu Jan 21, 2010 8:26 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />The -LATCH pulses with duration on the order of 10000 µs are probably a wait just less than a frame, as 16640 µs = 1 NTSC NES frame. The +LATCH pulses on the order of 1000 µs are probably just a couple thousand CPU cycles, just long enough to show that it's not a regular controller.
<br />
<br />It'd be possible to make a timing circuit to clean up clock signal distortions caused by the DPCM channel's DMA unit, much like the timing circuit in the MMC3's scanline counter that spreads A12 pulses. I wonder whether the glove has one.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sun Mar 18, 2012 6:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />OMG necrobump!  (sorry, mods)
<br />
<br />Did this exploration ever turn into anything?  I'm contemplating poking around with a Power Glove myself, and while other sources like <!-- m --><a class="postlink" href="http://textfiles.fisher.hu/programming/gla-91o">http://textfiles.fisher.hu/programming/gla-91o</a><!-- m --> and <!-- m --><a class="postlink" href="http://wiki.hak5.org/index.php?title=Episode_2x03">http://wiki.hak5.org/index.php?title=Episode_2x03</a><!-- m --> do support the idea that the output of the glove is deterministic and meaningful and that the startup sequence is reproducible, those time delays do seem both arbitrary and difficult to get out of a NES.
<br />
<br />I would accept that the init sequence listens for 4 clocks, then a low-&gt;high-&gt;low latch followed by 7 bytes of data and a final latch hold/release, and I would accept that the hardware in the glove may only buffer 8 bytes at a time and thus require 2 frames to fully deliver a packet.  I'm curious what the tolerances are on those 7212µs, 2260µs and 892µs waits are, though.  Specific times keyed to some timer in the glove?  Just arbitrary values someone pulled with a scope from Super Glove Ball representing the particular code that game ran?  If I were to just NMIwait a full frame for each, would it still work, or are instruction-timing loops to precise µs values really needed?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Fri Mar 23, 2012 7:43 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">*crickets chirp*</div><br /><br />Okay.  I'll take that as a "no."<br /><br />I'm still going to take a swing at it, and I might as well throw my thoughts here.<br /><br />From an interface perspective, I'm guessing the design was not SO pathological as to require cycle-precise timing to initialize the glove.  Worst-case scenario I may need to disassemble Super Glove Ball and just yank its code between those first 4 $4016 reads and wherever I can pin down the end of that sequence being, <em>but...</em><br /><br />From an electrical engineering perspective, I doubt that initial latch low/high hold is being timed explicitly on the glove.  Building in timing hardware specifically to prevent people who didn't know to wait precisely 7212µs / 2260µs would be pathological and expensive and easily defeated by some college kid with a good scope.  I suspect this is just a function of the setup code of whatever game the trace was recorded from, and for my first pass, I plan to just 4-clock, NMIwait, latch up, NMIwait, latch down and go.  If that fails, I can always add code.  Having some pause in there is probably a good thing- crunchy semi-analog electronics are likely to need some time to warm up or enter steady-state after being activated, but I will be surprised and depressed if the precise wait times are really required.  Also, those first 4 clocks?  I'm guessing that's the game "asking" whatever's connected whether it's a Glove.  This would make more sense if, say, regular pads returned up/down/left/right bits first and the game could check whether, say, up and down were simultaneously held (if so, probably not a regular pad), but even so, who holds A+B+Start+Select at startup?  This may still be what was showing up on the trace, we'll never know what the game was doing with the returned bits.  If so, it may not even be a required part of the init- the init may begin with the long hold of the latch, or even with the first clock/poll that (unusually) occurs with the latch still raised.<br /><br />From a low-level architectural programming perspective, the poster in that newsgroup snapshot who states<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Well, if anyone is interested, the 7 bytes sent to init the glove seem<br />to be: 0x06, 0xC1, 0x08, 0x00, 0x02, 0xFF, 0x01</div>
<br />probably has the right idea, and even the right interpretation of the bytes.  My 2 cents as to how that message breaks down is not that it's a "program" per se, but rather a configuration, bookended with the sorts of things you'd want as a Glove-side engineer to verify the message was correct.  To wit, I would propose
<br /><strong>$06:</strong> "6 bytes of data will be included in this packet"
<br /><strong>$C1 $08 $00 $02:</strong> "go into manual-override mode and start sending me packets conforming to these parameters:..." (no clue what each byte individually represents... $08 may be bits-precision-on-position, $C1 may be as simple as "12-position angular resolution, data returned in steps of 1", but really I'm just taking stabs in the dark.  the $C may also refer to 12 bytes of data in the return packet, or the $8 may be requesting 8-ish bytes of non-"junk" data in the return.  $00 $02 may be 2's complement on the position data with 0 as center. The world may never know.)
<br /><strong>$FF:</strong> "here's an easily-identifiable stop-byte.  Message ends."
<br /><strong>$01:</strong> "The message I sent should have checksum $01, if it doesn't you missed something"  (or, meh, this may be real data on the order of $FF-range precision in units of $01, or in $01 byte per axis)
<br />
<br /><em>If</em> I'm on the right track, posterity may just need to sit back and accept the 2-frame 12-byte packets half full of "junk" because I have no thoughts on what the checksum algo might be (other than that it can probably be computed sequentially bit by bit and take up no more than 1 byte of Glove-side memory.  Could it be as simple as an odd/even sum result of the pre-stopbyte bytes?  Or an odd/even count of 1s in the bitstream?)  Anyway, without cracking the checksum, the Glove would probably reject any variation to the 4 real parameters.
<br />
<br />And the "junk" bytes in the return packet?  Probably not <em>strictly</em> junk.  It would be appallingly wasteful to force NES developers to take a 50% hit in sampling rate when all the "good" data is in the first 8 bytes.  I think the newsgroup also observed the last byte seems to correlate to whether or not the glove is pointed at the speaker array.  If it's something as crazy-straightforward as the levels/timings the mics are detecting, it really would look kinda like noise and be ultimately unuseful save in some explicitly designed cases.  It may also be that the data packet in "hi-res" mode is 12 bytes always regardless, and the particular hi-res configuration sent to the glove only uses 6-7 of them, with the rest reserved in case of later need.  If the return packet isn't fixed-at-12-bytes because of potential data usage, the only other explanation I can think of is that  the glove itself needs X amount of time to sample its hardware and may force the NES dev to poll it a few extra times before it's required to return real data just so it has time to get its bits in order.  Glove-side register timing is one likely candidate for that blatant vblank wait after the first 8 bytes- if the glove has only 8 regs lined up for data output, it probably needs a breather to shift the remaining 4 bytes in.  Still, if I get as far as seeing any data out of the glove, I'll probably test it with the delay and with trying to grab all 12 bytes in one frame.  
<br />OR we could turn the Glove-needs-time hypothesis inside out and posit that perhaps the 12-byte return is an <em>artifact</em> rather than an <em>intent</em>: it may be that the glove takes Xµs to get a new frame of data any which way, whether it's polled 8 times, 12 times, or 100 times in the interim, and at that wonderful timing everyone's reproduced from that trace diagram, there just happen to be 11 samples between the header byte marking the start of real data and the header byte marking the next start of real data.  This would be consistent with observations on the newsgroup that the first bytes out of the glove came from the middle of the "packet": Glove don't care.  Glove gonna put Glove's data on the line when Glove's ready, regardless of what big Mr. NES coder's timeline is.  It's the game's job to listen for the header byte and jump into the datastream when Glove says so.
<br />
<br />But until I get my just-ordered flashcart and start dumping some builds to hardware, I won't really know a thing.  And when/if I do get data off the glove onto the NES, I'll try to keep the board updated.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Mar 24, 2012 4:20 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">LoneKiltedNinja wrote:</div><div class="quotecontent">From an electrical engineering perspective, I doubt that initial latch low/high hold is being timed explicitly on the glove..</div><br />True, the Super NES Mouse is widely thought to require somewhat specific timing: 16 bits fast, then a delay, than 16 bits slow, to match what Mario Paint does. But it's just an SPI device like any other Super NES controller, and it accepts any reasonable timing. Thwaite works fine even though it reads 8 bits, then pause, then 24 bits.<br /><br />On the other hand, the 6-button controller for the Sega Genesis treats a long period without a reread and a short period without a reread as different commands. Short means toggle between sets of buttons; long (over 10 ms or so) means reset back to the first set.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">From an electrical engineering perspective, I doubt that initial latch low/high hold is being timed explicitly on the glove.</div><br />Unless it's waiting to be sure that some analog to digital conversion has completed, like the 555-timed counter in a Vaus controller. You recognized that:<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">the only other explanation I can think of is that  the glove itself needs X amount of time to sample its hardware</div><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">but even so, who holds A+B+Start+Select at startup?</div><br />Imagine a multicart where A+B+Select+Start is the command to switch games. Game Boy games and Nintendo's falling block games for NES tend to use this chord as reset.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">But until I get my just-ordered flashcart and start dumping some builds to hardware, I won't really know a thing.  And when/if I do get data off the glove onto the NES, I'll try to keep the board updated.</div>
<br />And even once you do release docs and demos, don't expect people to jump to buy a $100 Power Glove to make and test games.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Mar 24, 2012 9:18 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">True, the Super NES Mouse is widely thought to require somewhat specific timing: 16 bits fast, then a delay, than 16 bits slow, to match what Mario Paint does. But it's just an SPI device like any other Super NES controller, and it accepts any reasonable timing. Thwaite works fine even though it reads 8 bits, then pause, then 24 bits.<br /><br />On the other hand, the 6-button controller for the Sega Genesis treats a long period without a reread and a short period without a reread as different commands. Short means toggle between sets of buttons; long (over 10 ms or so) means reset back to the first set.</div><br /><br />Interesting to know there is that degree of subtlety going on.  Still, I can hold out hope that if the Glove differentiates between "long" and "short" holds, it at least doesn't differentiate between "long" and "very long."<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Unless it's waiting to be sure that some analog to digital conversion has completed, like the 555-timed counter in a Vaus controller.</div><br />Not familiar with that one.  But again, a delay to sample or reach steady-state or reach timer completion wouldn't throw me.  It's a delay with both lower AND upper bounds that would be a pain.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Imagine a multicart where A+B+Select+Start is the command to switch games. Game Boy games and Nintendo's falling block games for NES tend to use this chord as reset.</div><br />I concede there are scenarios that use button chords as triggers, but in those cases it's something the player is instructed to do.  My only point is that in a game where the player was not expected to hold particular buttons at startup, but which may or may not be played with the Glove, it would be convenient for the Glove to return some known unusual button combo at first poll.  The Glove Ball manual points out that the game will know a glove is plugged in as soon as it starts up, and even flash the screen until the glove is calibrated and pointed at the speaker rig, which lends credence to the first poll being a detection and some return byte containing "is the world sane?" data.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">...And even once you do release docs and demos, don't expect people to jump to buy a $100 Power Glove to make and test games.</div>
<br />Touché <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />  But actually, while I'm not planning a game, I wouldn't be surprised if what I am planning ends up selling a few Power Gloves to the right sorts of people if it works...
<br />
<br />This weekend I plan to rough out a test ROM to try the init routine and display whatever data comes back.   Hopefully the flashcart arrives this week, and I can spend next weekend fiddling with the test ROM until useful data comes out of the Glove.  Once I have X, Y, rotation and button data reliably, it will hopefully be only one more weekend before I have a proper release.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Mar 31, 2012 2:21 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Round 1 tests: 
<br />
<br />* Super Glove Ball can flash the glove into high-res mode even after it's been initialized into low-res mode to operate a flashcart bootloader.  Thus, the timing of the initialization relative to system start appears immaterial.
<br />
<br />* in a first round of tests with purely arbitrary init pauses... a) my graphics went totally fubar because I was trying to fit glove init code in around arbitrary graphics init without NMI waits, but b) I seem to have... gotten the Glove's attention.  Not flashed it, but got its attention.  If I plug it in mid-runtime and then hit reset so my test rom picks it up, it goes straight into controller-emulation buttons-only without the usual need to press Start.
<br />
<br />* This thing either has some massive electric fields stored in it, or else has some way to write back to the CPU through the controller port O_O;  The first half-dozen times I started up with it plugged in, I got absolute rainbow scanline garbage.  Unplug it, NES boots fine.  Plug it in, finally I start getting some games coming up, but they're moderately tile-garbaged.  More unplugs/replugs/jiggles, and finally I can boot cleanly.  I just need to remember to flex my fingers and disable A/B autofire before pressing Start because it seems to like booting with those on <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />
<br />
<br />Next round: new test rom, taking my time to init the graphics, and then possibly throwing actual timing loops for the long waits.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Mar 31, 2012 4:31 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Round 2 test:
<br />
<br />* Initialization successful.  Or... at least I got it to beep at me and go into crazy-LED-flicker mode, but I really think the init message got through.  My timing on the polling to get data out is still way off- when they say "22µs between clocks" they apparently really f'real MEAN "22µs between clocks," and right now that screws up my inline-graphics-write timing, but I can do things which cause promisingly deterministic changes in the screen-garbage I am seeing, so I really think it's just down to timing my reads right and being a little more professional with my PPU work.
<br />
<br />The init code as such:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; &#91;various other code omitted&#93;<br />nmiVectorPointsHere:<br />&nbsp; &nbsp;; cache regs<br />&nbsp;sta nmi_acache<br />&nbsp;stx nmi_xcache<br />&nbsp;sty nmi_ycache<br />&nbsp;lda $2002&nbsp; &nbsp;; clear vblank interrupt<br />&nbsp;lda #$00<br />&nbsp;sta $2000&nbsp; &nbsp;; reset vblank interrupt generation<br />&nbsp;lda #$80&nbsp; &nbsp;<br />&nbsp;sta $2000&nbsp; &nbsp;; re-set vblank interrupt generation<br />&nbsp;<br />&nbsp;inc timerlow&nbsp; &nbsp;&nbsp; &nbsp;; increase the timer every frame<br />&nbsp;bne nmi_no_inchi&nbsp; &nbsp;; if timer lobyte is 0<br />&nbsp;inc timerhi&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; then inc the hibyte<br />nmi_no_inchi:<br /><br />&nbsp;inc nmi_count<br />&nbsp; &nbsp;; uncache regs<br />&nbsp;lda nmi_acache<br />&nbsp;ldx nmi_xcache<br />&nbsp;ldy nmi_ycache<br /><br />&nbsp;rti<br /><br />; waits a number of 1/60 second NMI-clocked frames, then returns<br />waitloop:<br />&nbsp;lda waitdelay&nbsp; &nbsp;; load the number of frames to wait<br />&nbsp;clc<br />&nbsp;adc timerlow&nbsp; &nbsp;; calculate an exit time<br />&nbsp;waitloop_innerloop:<br />&nbsp;cmp timerlow<br />&nbsp;bne waitloop_innerloop&nbsp; &nbsp;; loop until we reach the exit time<br />&nbsp;rts<br />&nbsp;<br />; waits for a NMI<br />waitNMI:<br />&nbsp;lda #0<br />&nbsp;sta nmi_count<br />waitNMI_loop<br />&nbsp;cmp nmi_count<br />&nbsp;beq waitNMI_loop<br />&nbsp;rts<br />&nbsp;<br />&nbsp; &nbsp; ; Mein Timingfheurer says clocks need to come at 22microsecond intervals<br />&nbsp; &nbsp; ; or, per calculations below, 39.38 cycles.&nbsp; Call it 39 for convenience.<br />&nbsp; &nbsp; ; lda &#91;absolute&#93; takes 4 cycles, so pad with 35 cycles<br />&nbsp; &nbsp; ; since we'll be doing this oh-so-many times, make it a routine.&nbsp; jsr/rts soak cycles nicely anyway.<br />&nbsp; &nbsp; ; after jsr and rts, we only need 22 cycles.&nbsp; 2 10s and a 2.<br />waitGloveClock:<br />&nbsp; &nbsp; ; jsr soaks 6 cycles<br />&nbsp;ldx #2 ; 2 cycles<br />waitGloveClockDelay:<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dey ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne waitGloveClockDelay ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;ldx #0 ; 2 cycles to absorb the lack of branch<br />&nbsp;<br />&nbsp;rts ; 7 cycles<br />&nbsp;<br />&nbsp; &nbsp; ; Mein Timingfheurer also says bytes need to be spaced by 96microseconds<br />&nbsp; &nbsp; ; or, per calculations below, 171.84 cycles.&nbsp; Call it 173 for convenience.<br />&nbsp; &nbsp; ; since we'll be doing this oh-so-many times, make it a routine.&nbsp; jsr/rts soak cycles nicely anyway.<br />&nbsp; &nbsp; ; after jsr and rts, we need 160 cycles.&nbsp; 16 10s.<br />waitGloveByte:<br />&nbsp; &nbsp; ; jsr soaks 6 cycles<br />&nbsp;ldx #16 ; 2 cycles<br />waitGloveByteDelay:<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dey ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne waitGloveByteDelay ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;; usual wait-2 here is soaked by the initial ldx.<br />&nbsp;<br />&nbsp;rts ; 7 cycles<br /><br />startVectorPointsHere:<br />; &#91;graphics setup code omitted&#93;<br /><br />glovePing:<br />&nbsp; &nbsp; ; per The Infallable Trace Diagram, at startup<br />&nbsp; &nbsp; ; knock knock<br />&nbsp;lda #1<br />&nbsp;sta $4016<br />&nbsp;lda #0<br />&nbsp;sta $4016<br />&nbsp;<br />&nbsp;lda $4016<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016<br />&nbsp;jsr waitGloveClock<br />&nbsp; &nbsp; ; who's there?&nbsp; I don't care; I declare it to be a Power Glove<br />&nbsp; &nbsp; ; the actual return bits suggesting this to be a Power Glove are left as an exercise to posterity.<br />&nbsp; &nbsp; <br />gloveFlag:<br />&nbsp; &nbsp; ; we &quot;need&quot; to wait 7212 microseconds<br />&nbsp; &nbsp; ; at 1.79MHz, 1 cycle is about .559 microseconds<br />&nbsp; &nbsp; ; meaning we need to burn 12909.48 cycles.&nbsp; Call it 12910.<br />&nbsp; &nbsp; ; so construct a quick 10-cycle loop and run it 1291 times.&nbsp; <br />&nbsp; &nbsp; ; Or how abut 1290, since there are a few other extraneous instructions being thrown about?<br />&nbsp; &nbsp; <br />&nbsp;ldx #0 ; 1-byte immediate = 2 cycles load-&gt;store EXTRA<br />&nbsp;<br />gloveFlagDelay1: ; 10-cycle 256-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay1 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />gloveFlagDelay2: ; 10-cycle 256-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay2 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />gloveFlagDelay3: ; 10-cycle 256-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay3 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />gloveFlagDelay4: ; 10-cycle 256-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay4 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />gloveFlagDelay5: ; 10-cycle 256-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay5 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />&nbsp; &nbsp; ; at this point we have only 10 more loops to go, so<br />&nbsp;ldx #10 ; 2 cycles EXTRA<br />&nbsp;<br />gloveFlagDelay6: ; 10-cycle 10-loop<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveFlagDelay6 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />&nbsp;<br />&nbsp; &nbsp; ; now that we've done some stuff for 7212 microseconds or close-e-dang-nuff<br />&nbsp; &nbsp; ; start a nice wide latch pulse to let the Glove know config data is coming<br />&nbsp;lda #1<br />&nbsp;sta $4016 <br />&nbsp;<br />&nbsp;<br />gloveInit:<br />&nbsp; &nbsp; ; we &quot;need&quot; to wait 2260 microseconds<br />&nbsp; &nbsp; ; at 1.79MHz, 1 cycle is about .559 microseconds --== NOTE: PAL SYSTEMS RUN AT 1.66! ==--<br />&nbsp; &nbsp; ; meaning we need to burn 4045.4 cycles.&nbsp; Call it 4045.<br />&nbsp; &nbsp; ; so construct a quick 10-cycle loop and run it 404.5 times.&nbsp; <br />&nbsp; &nbsp; ; Or how abut 404, since there are a few other extraneous instructions being thrown about?<br />&nbsp; &nbsp; <br />&nbsp;ldx #0 ; 1-byte immediate = 2 cycles load-&gt;store EXTRA<br />&nbsp;<br />gloveInitDelay1: <br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveInitDelay1 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />&nbsp; &nbsp; ; only need 148 more, so<br />&nbsp;ldx #148 ; 2 cycles EXTRA<br />&nbsp;<br />gloveInitDelay2: <br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveInitDelay2 ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />&nbsp; &nbsp; ; now that we've done some more stuff for &quot;2260&quot; microseconds <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; &quot;yo, Glove, listen up&quot;<br />&nbsp;lda #0<br />&nbsp;sta $4016<br />&nbsp; &nbsp; ; pad a few cycles, maybe not the full 5micro, but give it some time<br />&nbsp; &nbsp; ; besides, this will make switching the latch faster<br />&nbsp; &nbsp; ldx #0<br />&nbsp; &nbsp; ldy #1<br />&nbsp;<br />&nbsp; &nbsp; ; 0x06, 0xC1, 0x08, 0x00, 0x02, 0xFF, 0x01 - a magic spell?<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; $06 = %00000110 ?= &quot;hey Glove, listen for 6 bytes of data&quot;<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $C1 = %11000001 ?= ... no clue. $C byte return packets?<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $08 = %00001000 ?= ... no clue. $08 bit precision?<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $00 = %00000000 ?= ... no clue<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $02 = %00000010 ?= ... no clue<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $FF = %11111111 ?= &quot;stopbyte- message ends&quot;<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 1<br />&nbsp;<br />&nbsp;jsr waitGloveByte<br />&nbsp;<br />&nbsp; &nbsp; ; $01 = %00000001 ?= &quot;have a checksum!&quot;<br />&nbsp;stx $4016<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;lda $4016 ; 0<br />&nbsp;jsr waitGloveClock<br />&nbsp;sty $4016<br />&nbsp;lda $4016 ; 1<br />&nbsp;<br />&nbsp;<br />&nbsp; &nbsp; ; 892 microseconds is 1596.68 cycles<br />&nbsp; &nbsp; ; that's ~like~ 1600, or 160 10-loops<br />&nbsp;ldx #160 ; 2 cycles EXTRA<br />&nbsp;<br />gloveClearDelay: <br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;iny ; 2 cycles, dummy op<br />&nbsp;dex ; 2 cycles<br />&nbsp;bne gloveClearDelay ; branch takes 2 cycles to load/compare, and an additinal 2 if the branch is taken<br />&nbsp;iny ; 2 cycle dummy to absorb the 2 cycles of not-branching<br />&nbsp;<br />&nbsp; &nbsp; ; aaaaand clear.&nbsp; Finally.<br />&nbsp;stx $4016<br />&nbsp;<br />&nbsp;lda #3<br />&nbsp;sta waitdelay<br />&nbsp; &nbsp; ; go make a sandwich &#40;for something like 40000 microseconds.&nbsp; Honestly, if it cares at this point, I will be sad.&#41;<br />&nbsp;jsr waitloop<br />&nbsp;<br />&nbsp;jmp main_loop</div>
<br />
<br />What's that?  "How did I find the exact cycle-count for instructions"?  By putting a frelling 6502 together in Verilog some 7 years ago as a class project <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />  And keeping mercifully good notes on the architectural state machine I derived, which iirc matched someone else's cycle-count chart which I appear to have lost.  If this site is still taking docs, I might be able to dig up and submit anything useful I still have around.
<br />
<br />edit: n/m- found it.  Cycle counts were also staring me in the face on a chart I wasn't looking for them on.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Mar 31, 2012 9:56 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Round 3 test:
<br />
<br />* First piece of new NES software to successfully use the PowerGlove hi-res mode in... 20 years?   First piece of new PG code on any platform in... 10?  Anyway, I've cracked it.
<br />
<br />* Secret PowerGlove mantra? "Slow the fsck down."  Performance only improved/stabilized the more room I gave it around clocks &amp; latches.  Now that I've got a stable demo, I can start pulling the small delays and see whether all of them are ~really~ needed, but at very least you need to give it time to capture its data.  2 60Hz frames to stream out a packet, and 2 more before you ask it again.
<br />
<br />* the "header" byte seems to uniformly be %01011111 ($5F).  You should key into this, because if you don't give the glove quite enough time between polls, or if you make it compute too much at once (e.g. by closing a fist to trigger all finger sensors while moving/rotating), the packet does seem to drift a few bytes.  Give it time to relax again and it seems to straighten itself out.
<br />
<br />* the buttons byte is in an odd format, not the usual NES 1-bit-per-button.  I'll post a full breakdown at some point, but in general the indications are one button at a time is available on any given sample, stored as a numeric code in the 4 lowbits.  Either Start or Select also shows up in bit 7 (high).  Bits 6-4 seem to be 1 when any button is down, 0 otherwise.
<br />
<br />* bytes are returned high bit to low bit, in case there was any question
<br />
<br />* Z (screen-depth) position seems to maybe be absolute, X and Y seem to reset with the Center button (although holding Center is one of those taxing things that will throw your packet timing off).  Haven't gone into values in depth, but they do appear to be 2's complement, and they also appear amazingly stable.  Not rock-solid, but better than the impression I got from the newsgroup thread.
<br />
<br />* rotation is in something like clock-hour increments, as reported elsewhere.  The high 4 bits are 1s, the low bits register at very most 16 positions, but 12 or 8 wouldn't surprise me on closer investigation.
<br />
<br />This code will get you values out of the glove, but I don't yet promise it's optimal.
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />main_loop: <br />&nbsp;<br />&nbsp;jsr waitNMI<br />&nbsp;<br />; &#91;ppu code omitted&#93;<br />&nbsp;<br />&nbsp;<br />&nbsp;ldx #0 ; byte index<br />glovePollLoop1Byte:<br />&nbsp;ldy #0 ; bit counter<br />&nbsp; &nbsp; ; latch - 5microseconds = ~9 cycles<br />&nbsp;lda #1<br />&nbsp;sta $4016 ; 4 cycles<br />&nbsp;inx ; 2 cycle dummy<br />&nbsp;dex ; 2 cycle undo-dummy<br />&nbsp;lda #0 ; 2 cycles<br />&nbsp;sta $4016 ; 4 cycles<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;<br />glovePollLoop1Bit:<br />&nbsp;lda $4016 ; 4 cycles<br />&nbsp;lsr A ; 2 cycles<br />&nbsp;; rol gloveData,X ; 6 cycles<br />&nbsp;.db $36,$20 ; stupid nesasm<br />&nbsp; &nbsp; ; and with the bne, that's 20 cycles of the 39 we &quot;need&quot;<br />&nbsp; &nbsp; ; for now, I'm going to cross my fingers.<br />&nbsp; &nbsp; ; ... or not<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;dec temp0 ; 6 cycles dummy<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;cmp #0 ; 2 cycles dummy<br />&nbsp;iny ; 2 cycles<br />&nbsp;cpy #8 ; 2 cycles<br />&nbsp;bne glovePollLoop1Bit ; 4 cycles when we care<br />&nbsp;<br />&nbsp;stx temp0 ; waitGloveByte makes x 0<br />&nbsp;jsr waitGloveByte<br />&nbsp;ldx temp0<br />&nbsp;<br />&nbsp;inx<br />&nbsp;cpx #8<br />&nbsp;bne glovePollLoop1Byte<br />&nbsp;<br /><br />&nbsp; &nbsp; ; in this respect, I'll believe The Infallible Trace Diagram, at least for now<br />&nbsp; &nbsp; ; a 64-bit shift register would have been prime hardware, and 96-bits would<br />&nbsp; &nbsp; ; have been just plain odd.&nbsp; Probably the Glove does need time to shift in<br />&nbsp; &nbsp; ; the remaining 4 bytes.<br />&nbsp;<br />&nbsp;jsr waitNMI<br />&nbsp;<br />; &#91;ppu code omitted&#93;<br />&nbsp;<br />&nbsp; &nbsp; ; and we're back.<br />&nbsp;ldx #8 ; byte index<br />&nbsp;glovePollLoop2Byte:<br />&nbsp;ldy #0 ; bit counter<br />&nbsp; &nbsp; ; latch - 5microseconds = ~9 cycles<br />&nbsp;lda #1<br />&nbsp;sta $4016 ; 4 cycles<br />&nbsp;inx ; 2 cycle dummy<br />&nbsp;dex ; 2 cycle undo-dummy<br />&nbsp;lda #0 ; 2 cycles<br />&nbsp;sta $4016 ; 4 cycles<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;<br />glovePollLoop2Bit:<br />&nbsp;lda $4016 ; 4 cycles<br />&nbsp;lsr A ; 2 cycles<br />&nbsp;; rol gloveData,X ; 6 cycles<br />&nbsp;.db $36,$20 ; stupid nesasm<br />&nbsp; &nbsp; ; and with the bne, that's 20 cycles of the 39 we &quot;need&quot;<br />&nbsp; &nbsp; ; for now, I'm going to cross my fingers.<br />&nbsp; &nbsp; ; ... or not<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;dec temp0 ; 6 cycles dummy<br />&nbsp;inc temp0 ; 6 cycles dummy<br />&nbsp;cmp #0 ; 2 cycles dummy<br />&nbsp;iny ; 2 cycles<br />&nbsp;cpy #8 ; 2 cycles<br />&nbsp;bne glovePollLoop2Bit ; 4 cycles when we care<br />&nbsp;<br />&nbsp;stx temp0 ; waitGloveByte makes x 0<br />&nbsp;jsr waitGloveByte<br />&nbsp;ldx temp0<br />&nbsp;<br />&nbsp;inx<br />&nbsp;cpx #12<br />&nbsp;bne glovePollLoop2Byte<br />&nbsp;<br />&nbsp; &nbsp; ; and that's a wrap<br /><br />&nbsp; &nbsp; ; and in closing, yes, it really does need 2 full 60Hz frames<br />&nbsp; &nbsp; ; to get its bits together for the next poll.&nbsp; 15fps updates ftw.<br />&nbsp;jsr waitNMI<br />&nbsp;jsr waitNMI<br /><br />&nbsp;jmp main_loop&nbsp; &nbsp;; loop<br /></div>

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>4</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>