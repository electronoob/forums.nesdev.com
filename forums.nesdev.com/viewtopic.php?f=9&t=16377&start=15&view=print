<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - EPROM LPT Programmer?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">EPROM LPT Programmer?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=9&amp;t=16377">http://forums.nesdev.com/viewtopic.php?f=9&amp;t=16377</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>krzysiobal</b> [ Sun Sep 03, 2017 10:04 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />The higher the frequency, the smaller inductor you can use. Check what inductor you have and use frequency adequate for it. Many DC step-ups work at 100 kHz, but it requires at least 100uH inductor in your case. The frequency cannot be too low (below 20 kHz), because you will hear `buzz` from inductor.<br /><br /> <br />V ripple is desired oscillation of voltage at output, check datasheet of memory in what range the voltage can be (100mV ripple should be OK).<br /><br />Long time ago I built step up for my Willem LPT programmer (because the original was not able to generate 25V). By using jumpers, I was able to force my step up to produce one of four most common voltages for programming eproms: 12.75V, 16V, 21V, 25V. Here is schematics with values:<br /><a href="https://obrazki.elektroda.pl/1732240200_1504458183.png" class="postlink"><img src="https://obrazki.elektroda.pl/1732240200_1504458183_thumb.jpg" alt="Image" /></a>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Sun Sep 03, 2017 10:23 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Assuming 10% or 5% permissible ripple is a standard rule-of-thumb. Specifically in the case of the 6.5V Vcc during programming, however, the part has a 7V absolute maximum, so 10% is too big there. The examples given in the MC34063 datasheet use much lower tolerances; as little as 1.2‰.<br /><br />The available sizes of inductor and capacitor usually put some limits on fmin, as does the boost converter. The lower the frequency, the bigger the capacitor, inductor, and lower permissible series resistance of the inductor. The higher the frequency, the greater the losses in the inductor. See this article: <!-- m --><a class="postlink" href="http://www.eetimes.com/document.asp?doc_id=1272335">http://www.eetimes.com/document.asp?doc_id=1272335</a><!-- m -->

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Wed Sep 06, 2017 2:03 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I made some modification to the schematic :<br />VCC is only 5v USB (no 6.5v at all)<br />Using a 47uF on VCC line made the read process more stable<br />VPP 13v is generated by using MC34063<br />Instead of 33K pull down resistors I used 10K pull up resistors (same as <a href="http://www.bwass.org/bucket/willem_SCH3Bx.pdf" class="postlink">Willem Programmer</a>)<br /><br />But unfortunately Writing EPROM doesn't work.<br />Nothing is written to the first 36 bytes.<br />Then it starts to write a byte and fails the next one, and so on.<br />Here is my code for write process :<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/* Pin16 : Out : Reset&nbsp; &nbsp;&nbsp; &nbsp;==&gt; Reset&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;*/<br />/* Pin14 : Out : D_Strobe&nbsp; &nbsp;==&gt; Clock + /CE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;*/<br />/* Pin11 : In&nbsp; : Wait&nbsp; &nbsp;&nbsp; &nbsp;&lt;== Q0&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;*/<br />/* Pin1&nbsp; : Out : Write&nbsp; &nbsp;&nbsp; &nbsp;==&gt; swtich{ 13v ==&gt; /GVPP }&nbsp; &nbsp;*/<br /><br />&nbsp; &nbsp;long int i, persent=1;<br />&nbsp; &nbsp;unsigned char* byte;<br />&nbsp; &nbsp;byte = (unsigned char*) malloc (1048576);<br /><br />&nbsp; &nbsp;/* Load write.bin to into byte */<br />&nbsp; &nbsp;FILE *fp;<br />&nbsp; &nbsp;fp = fopen(&quot;write.bin&quot;, &quot;rb&quot;);<br />&nbsp; &nbsp;for ( i=0 ; i&lt;1048576 ; i=i+1)<br />&nbsp; &nbsp;&nbsp; &nbsp;byte&#91;i&#93; = getc(fp);<br />&nbsp; &nbsp;fclose(fp);&nbsp; &nbsp;<br /><br />&nbsp; &nbsp;/* Clear time-out bit &#91;bit0&#93; */<br />&nbsp; &nbsp;Out32 ( 0x379, 255 );<br /><br />&nbsp; &nbsp;/* Initiate the control port : 00000100 */<br />&nbsp; &nbsp;/* Set bit5 to 0 to disable Bidirectional Data */<br />&nbsp; &nbsp;/* Set bit2 &#91;pin16&#93; to 1 to reset 4040 */<br />&nbsp; &nbsp;Out32 ( 0x37A, 4 );<br /><br />&nbsp; &nbsp;/* Set bit2 &#91;pin16&#93; to 0 to make 4040 ready to count */<br />&nbsp; &nbsp;Out32 ( 0x37A, 0 );<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;/* Write buffer to EPROM */<br />&nbsp; &nbsp;/* 1048576 dec = 100000 hex */<br />&nbsp; &nbsp;for ( i=0 ; i&lt;1048576 ; i=i+1 )<br />&nbsp; &nbsp;{<br />&nbsp; &nbsp;&nbsp; &nbsp;Out32 ( 0x37C, byte&#91;i&#93; );<br /><br />&nbsp; &nbsp;/* Manually generate a clock to force Wait line low again */<br />&nbsp; &nbsp;&nbsp; &nbsp;Out32 ( 0x37A, 2 );<br />&nbsp; &nbsp;&nbsp; &nbsp;Out32 ( 0x37A, 0 );<br /><br />&nbsp; &nbsp;/* Calculate persentage of the process */<br />&nbsp; &nbsp;&nbsp; &nbsp;if (i==(persent*10485))<br />&nbsp; &nbsp;&nbsp; &nbsp;{<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf(&quot;Writing %%%d\r&quot;, persent);<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;persent=persent+1;<br />&nbsp; &nbsp;&nbsp; &nbsp;}<br />&nbsp; &nbsp;}</div><br /><br />Any idea how to fix it?

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10044&amp;mode=view"><img src="./download/file.php?id=10044&amp;t=1" alt="01.PNG" /></a><br />
			<span class="gensmall">01.PNG [ 62.21 KiB | Viewed 1473 times ]</span>
		

		<br />
	</td>
				</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10043&amp;mode=view"><img src="./download/file.php?id=10043&amp;t=1" alt="02.png" /></a><br />
			<span class="gensmall">02.png [ 13.35 KiB | Viewed 1473 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Wed Sep 06, 2017 10:44 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />With UVEPROM programming, you <em>have</em> to <br /><br />* Write the byte<br />* See if the byte is programmed<br />* Repeat until either it succeeds or you time out.<br /><br />You can't just blindly write values to it, because you will either overprogram (and prematurely age the part) or underprogram (and the programmed values won't show up). Each individual bit has its own threshold for the amount of time needed to shove the correct amount of charge into it, and it gets longer the more time that bit is programmed and erased.<br /><br />The amount of time you're supposed to use per bit varies by the specific part being programmed. ST's M27C801's datasheet says &quot;50µs for each byte, repeat up to 25 times per byte&quot;. Older parts are often even slower.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Wed Sep 06, 2017 11:50 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I applied a 6.5v to VCC of EPROM and write was successful!<br /><br />A rapid programming algorithm is suggested in AT27C080 datasheet :<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Rapid programming algorithm<br />A 50μs CE pulse width is used to program. The address is set to the first location. VCC is raised to 6.5V and OE/VPP is raised to 13.0V. Each address is first programmed with one 50μs CE pulse without verification. Then a verification reprogramming loop is executed for each address. In the event a byte fails to pass verification, up to 10 successive 50μs pulses are applied with a verification after each pulse. If the byte fails to verify after 10 pulses have been applied, the part is considered failed. After the byte verifies properly, the next address is selected until all have been checked. OE/VPP is then lowered to VIL and VCC to 5.0V. All bytes are read again and compared with the original data to determine if the device passes or fails.</div><br /><br />Why is it needed to verify every byte up to 10 times after programming? <br />Isn't it enough to read the whole eprom data and compare it with the original data?<br />So that the whole process will be easier.<br /><br />Is it possible to use LPT-Pin17 to generate a 50uS for /CE?

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10052&amp;mode=view"><img src="./download/file.php?id=10052&amp;t=1" alt="EPP_Write.jpg" /></a><br />
			<span class="gensmall">EPP_Write.jpg [ 109.85 KiB | Viewed 1440 times ]</span>
		

		<br />
	</td>
				</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10050&amp;mode=view"><img src="./download/file.php?id=10050&amp;t=1" alt="AT27C080_Write.png" /></a><br />
			<span class="gensmall">AT27C080_Write.png [ 49.22 KiB | Viewed 1440 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Wed Sep 06, 2017 12:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">FARID wrote:</div><div class="quotecontent">Why is it needed to verify every byte up to 10 times after programming? <br /></div>It's not &quot;verify&quot; a byte 10 times.<br /><br />It's &quot;see if you've successfully programmed it yet&quot;, and after verification fails 10 times, the part is assumed too damaged to <em>ever</em> be programmed.<br /><br />Like I said, every byte will require a different amount of time spent attempting to shove electrons into the floating gate of the UVEPROM. This is an analog effect, and is affected by the specific floating gate's history. So when they say &quot;50µs, up to 10 times&quot;, they mean &quot;any given byte will require a maximum of 25 microcoulombs to be programmed and if that isn't enough the bit will never work&quot;

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Wed Sep 06, 2017 10:12 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If I want to use burn-verify-reburn-compare method I have to change the whole logic of the programmer, in that case even EPP handshake may become unusable.<br /><br />So how about this method : burn-compare<br />At the start of the programming I ask the user about the condition of the EPROM which can be one of these : new, used, weary<br />According to the condition of the EPROM I can adjust the width of the burn pulse :<br />new : 100us<br />used : 500us<br />weary : 1000us<br />After burning I can read the whole EPROM and compare it with the original data to check if the burn process was successful.<br /><br />Is this possible?

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10062&amp;mode=view"><img src="./download/file.php?id=10062&amp;t=1" alt="condition_based_algorithm.png" /></a><br />
			<span class="gensmall">condition_based_algorithm.png [ 46.84 KiB | Viewed 1404 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Wed Sep 06, 2017 10:26 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />That will damage your parts. Asking the user isn't good enough. Both because of user error, and also because different parts of the ROM age at different rates, so different amounts of time will be required on a byte-by-byte basis.<br /><br />The reason that EEPROMs often say <br /><blockquote style="margin-left: 1%; padding-left: 1%; border-left: 3px solid #555577;">
Embedded algorithms for completely self-timed write/erase operations
</blockquote> is exactly because of this annoyance that you're dealing with. <br /><br />Do you really have to do it? No, you're free to destroy your parts by whatever method you choose. Will it instantly destroy parts? No, I'd guess that most of them would survive one or two reprogrammings in this blind way.<br /><br /><br />It's definitely worth pointing out that you are already <em>not using the EPP handshake</em>. You are faking it by having the computer manually drive the WAIT line high and then low, which tricks the EPP hardware into thinking it's getting a handshake.<br /><br />There's also no reason that your 4040s have to be clocked by the same /DSTROBE signal that reads or writes from the ROM.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Thu Sep 07, 2017 12:11 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It's definitely worth pointing out that you are already <em>not using the EPP handshake</em>. You are faking it by having the computer manually drive the WAIT line high and then low, which tricks the EPP hardware into thinking it's getting a handshake.</div><br /><br />Are you referring to this part of the code? :<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; &nbsp; Out32 ( 0x37C, byte&#91;i&#93; );<br /><br />&nbsp; &nbsp;/* Manually generate a clock to force Wait line low again */<br />&nbsp; &nbsp; &nbsp; Out32 ( 0x37A, 2 );<br />&nbsp; &nbsp; &nbsp; Out32 ( 0x37A, 0 );</div><br /><br />D_strobe causes a clock on 4040<br />Q0 of 4040 goes high which is used as wait signal<br />So an EPP handshake happens<br />But after handshaking Q0 stays high, on the other hand to start another EPP handshake wait must be low, so by generating a manual clock on 4040, Q0 goes low<br />So I think I use EPP handshake at least alternatively<br /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">That will damage your parts. Asking the user isn't good enough. Both because of user error, and also because different parts of the ROM age at different rates, so different amounts of time will be required on a byte-by-byte basis.</div><br />Let's say the worst scenario happens : <br />user choose weary option and burn the EPROM with 1000us pulse, while the condition of the EPROM is new and it actually require 50us pulse to be successfully programed. <br />It seems that the whole life of the EPROM becomes 1/20, no?<br />While most of the times an EPROM is programmed a few times and then is used for years, so I feel that cutting their life even with 1:20 ratio is not that much critical, or is it?<br />Or maybe this makes the problem?! : 20 times * 50 us burn pulse != 1 time * 1000 us burn pulse<br /><br />Also here is an approximate calculation which shows the current code works (by sheer chance?!) very close to the appropriate burn pulse (neither overprogram nor underprogram) :<br />With my code burn process takes 60 sec = 60000000 us<br />Total bytes of 27C080 : 100000 hex = 1048576 dec<br />60000000 / 1048576 = 57 us<br />So each byte receives about 57 us burning pulse which seems good, no?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Thu Sep 07, 2017 3:27 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">FARID wrote:</div><div class="quotecontent">So I think I use EPP handshake at least alternatively<br /></div>Fair enough.<br /><br />Specifically, what happens is:<br />* EPP data write<br />** R/W is brought low<br />** /DSTROBE goes low. Programming cycle #1<br />** 4040 increments, bringing WAIT high<br />** ROM drives value onto data bus<br />** /DSTROBE goes high<br />* manual Centronics port drive /DSTROBE low. Increments '4040, which brings WAIT low and changes the address seen by the ROM. <strong>Programming cycle #2 with ... hopefully $FF on the data bus? Therefore not actually a problem?</strong><br />* manual Centronics port drive /DSTROBE high. Programming cycle #2 ends.<br />* repeat<br /><br />What I'm suggesting is:<br />* Use a NAND gate to combine /DSTROBE and /ASTROBE and drive +WAIT<br />* Use /ASTROBE to increment the '4040<br /><br />This provides two big advantages:<br />* Increment behavior is not tied to programming or reading, so bytes can be re-read, re-programmed, or skipped altogether.<br />* No need to manually toggle /DSTROBE an extra time; API is simpler.<br /><br />At some point in the past I was going to suggest using a CD4060, because it includes an integral oscillator (i.e. inverter) ... but it also has a ÷8 divider on its outputs, so that isn't tremendously useful.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It seems that the whole life of the EPROM becomes 1/20, no?<br /></div>That is <em>probably</em> correct, but I'm not confident.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Or maybe this makes the problem?! : 20 times * 50 us burn pulse != 1 time * 1000 us burn pulse<br /></div>While it does seem likely to me that there are some transition times such that those two numbers don't work out to be equal, instead I suspect that overburning a pristine EPROM will damage it more than had it gradually gotten there.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">While most of the times an EPROM is programmed a few times and then is used for years, so I feel that cutting their life even with 1:20 ratio is not that much critical, or is it?<br /></div>You're probably right.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So each byte receives about 57 us burning pulse which seems good, no?<br /></div>I suspect that much less than 50% of the time is spent with /DSTROBE asserted. You're probably underburning the EPROM, which won't harm anything—bits may just fall out too early. It'll be hard to tell by how much unless you get access to an oscilloscope to watch the /DSTROBE signal during programming. And certainly you can't be meaningfully overburning the EPROM if you're only spending 60µs per bit, when it's rated to a minimum of 50µs.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Fri Sep 08, 2017 12:53 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Programming cycle #2 with ... hopefully $FF on the data bus? Therefore not actually a problem?</div><br />So a bus conflict? Maybe it explains the <a href="http://forums.nesdev.com/download/file.php?id=10044&amp;mode=view" class="postlink">strange writing behavior</a> that I had when I used only 5v (not 6.5v) for writing. <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">* Use /ASTROBE to increment the '4040</div><br />Awesome idea thanks<br /><br />So what do you think about this design by using <a href="http://www.onsemi.com/pub/Collateral/MC74HC4051A-D.PDF" class="postlink">4053</a> :<br /><br />Init state : <br />write (Pin1) : high ==&gt; A + B : 4053 {5V ==&gt; EPROM VCC , GND ==&gt; /GVPP}<br />D_Strobe (Pin14) : high ==&gt; C + /CE : 4053 { GND ==&gt; Wait (Pin11) } : EPROM is disabled<br />Reset (Pin16) : high ==&gt; 4040 Reset<br />A_Strobe (Pin17) : high ==&gt; 4040 Clock<br /><br />Setup 4040 :<br />Reset goes low : 4040 is ready to count<br /><br />Read operation :<br />Read from EPP data register<br />Write is high : 5v ==&gt; EPROM VCC, GND ==&gt; /GVPP<br />D_Strobe goes low<br />EPROM /CE goes low : EPROM becomes enabled<br />Wait goes high : EPP Reading handshake starts <br />Data is read from Parallel Port Pins<br />D_Strobe goes high<br />EPROM /CE goes high : EPROM becomes disabled<br />Wait goes low : EPP Reading handshake ends<br />Manually force A_Strobe low then high to generate a clock for 4040<br />Repeat from beginning to deal with the next byte<br /><br />Write operation :<br />Write to EPP data register<br />Halt the program for 50us<br />Write goes low : 6.5v ==&gt; EPROM VCC, 13v ==&gt; /GVPP<br />D_Strobe goes low<br />EPROM /CE goes low : EPROM becomes enabled<br />Wait goes high : EPP Writing handshake starts <br />Data is written to EPROM<br />D_Strobe goes high<br />EPROM /CE goes high : EPROM becomes disabled<br />Wait goes low : EPP Writing handshake ends<br />Write goes high : 5v ==&gt; EPROM VCC, GND ==&gt; /GVPP<br /><br />{<br />To verify a loop of Reading handshake can be started here.<br />If verify doesn't pass start reprogramming the same byte again<br />If verify pass continue<br />}<br /><br />Manually force A_Strobe low then high to generate a clock for 4040<br />Repeat from beginning to deal with the next byte

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10079&amp;mode=view"><img src="./download/file.php?id=10079&amp;t=1" alt="Schematic.png" /></a><br />
			<span class="gensmall">Schematic.png [ 14.58 KiB | Viewed 1339 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Fri Sep 08, 2017 10:44 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">FARID wrote:</div><div class="quotecontent">So a bus conflict? Maybe it explains the <a href="http://forums.nesdev.com/download/file.php?id=10044&amp;mode=view" class="postlink">strange writing behavior</a> that I had when I used only 5v (not 6.5v) for writing. <br /></div>No, I don't think so. For almost all UVEPROMs, programming $FF is the same as skipping the programming cycle altogether.<br /><br />Of course, if the data pins <em>don't</em> have a weak pull-up and instead just float, then you're spending a few moments programming a bad value in instead.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So what do you think about this design by using [three independent analog multiplexers]:<br /><br />Init state : <br />write (Pin1) : high ==&gt; A + B : 4053 {5V ==&gt; EPROM VCC , GND ==&gt; /GVPP}<br />D_Strobe (Pin14) : high ==&gt; C + /CE : 4053 { GND ==&gt; Wait (Pin11) } : EPROM is disabled<br />Reset (Pin16) : high ==&gt; 4040 Reset<br />A_Strobe (Pin17) : high ==&gt; 4040 Clock<br /></div>I don't think the 4053 can pass voltages outside of its supply rails. If you instead try to supply it with the output of the boost converter, then the 3.3V logic from the parallel port is no longer high enough to control the multiplexers.<br /><br />I'd probably just switch to using bare BJTs at this point, even though it's bigger.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Manually force A_Strobe low then high to generate a clock for 4040<br /></div>I was thinking you'd use the NAND gate so that the hardware would automatically acknowledge both /DSTROBE and /ASTROBE. The only thing that you lose by manually toggling the pins is speed.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Write goes low : 6.5v ==&gt; EPROM VCC, 13v ==&gt; /GVPP<br />D_Strobe goes low<br /></div>I worry whether the setup time is long enough? The M27C801 datasheet I keep referring to wants 2µs during which 13V is presented on Vpp before /E drops.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Halt the program for 50us<br /></div>That won't make /Dstrobe stay low for a whole 50µs.<br /><br />On the other hand, I'm pretty certain you can also get away with shorter programming. The only important thing is measuring how much shorter it is.<br /><br />—<br /><br />I think it's worth pointing out that you don't need to do the verification step immediately after programming. You can do something like<br />1) read ROM to blank check ROM (make sure that all bits that are desired to remain 1 are currently 1; it doesn't actually need to be blank)<br />** if any bits that should be 1are 0, then the ROM needs to be erased and programming cannot continue.<br />2) program bytes that need to be changed<br />3) reread ROM to see what bits are still 1 that need to become 0<br />4a) if any bits that should be 1 are 0, something bad happened, and programming cannot continue<br />4b) if any bits that should be 0 are 1, then increment pass counter, and if we haven't done too many passes, go to step 2. If we've done too many passes, the ROM is probably used up.<br />4c) if all bits that should be 0 are 0, programming is done.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Sat Sep 09, 2017 11:33 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If you instead try to supply it with the output of the boost converter, then the 3.3V logic from the parallel port is no longer high enough to control the multiplexers.</div><br /><br />You were right 4053 doesn't work.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I was thinking you'd use the NAND gate so that the hardware would automatically acknowledge both /DSTROBE and /ASTROBE. The only thing that you lose by manually toggling the pins is speed.</div><br /><br />I try to keep the hardware as simple as possible, even if I costs a little speed.<br /><br />So here is a new design with BJTs.<br />But I don't know what is the best value for R11, R13, R14, can you help me with them please?

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10092&amp;mode=view"><img src="./download/file.php?id=10092&amp;t=1" alt="BJT_Schematic.png" /></a><br />
			<span class="gensmall">BJT_Schematic.png [ 18.79 KiB | Viewed 1278 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Sat Sep 09, 2017 6:30 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />BJTs have a few relevant behaviors here.<br /><br />The first one is called &quot;β&quot; or &quot;h<sub>FE</sub>&quot;. When allowed, a BJT in the &quot;forward active&quot; region will permit current flowing through the collector I<sub>C</sub> equal to β times the current through the base I<sub>B</sub>.<br /><br />The second one is what happens when the BJT tries to draw more current through the collector (according to β) than is available. Then the BJT is in &quot;saturation&quot;. Saturation has both a useful property: the voltage between the collector and emitter becomes very small (&quot;V<sub>CEsat</sub>&quot;); and a bad one: exiting saturation takes extra time.<br /><br />In a situation like the inverter (R13, R14, Q4) it's often desirable to set R13/R14 so that it <em>just barely</em> enters saturation, so that it exits saturation a little more readily. The other important thing is that the WAIT pin <em>probably</em> has a pull-up inside your parallel port, and you might be able to elide R13 altogether.<br /><br />Finally, for R11, the situation is similar, but now the voltage of the BJT's emitter will rise proportionate to the amount of current flowing through the resistor R12. Once again, you want the BJT to just go into saturation when READ//WRITE is high.<br /><br />So:<br />* look up hFE for the BJTs you are using<br />* measure what pullup is on the WAIT pin, if any (If none, use 4.7kΩ for R13)<br />* calculate R14 such that the BJT Q4 will just go into saturation when /DSTROBE is high.<br />* calculate the amount of current through R9/R10 and the amount of current that should be flowing through R12 when it's conducting<br />* calculate R11 such that the BJT Q3 will (again) just go into saturation when READ//WRITE is high.<br /><br />One concern:<br /><br />When the device is not plugged in to the parallel port, current can &quot;shoot through&quot; from 13V via Q1+R6 through Q2 and R8 to R11, Q3, and R12. You might need to add an extra stage of buffering to prevent that.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FARID</b> [ Sun Sep 10, 2017 11:52 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: LPT EPROM Reader?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I calculated R11 manually and its value is 430K<br />But <a href="https://www.petervis.com/GCSE_Design_and_Technology_Electronic_Products/transistor_base_resistor_calculator/transistor_base_resistor_calculator.html" class="postlink">Transistor Base Resistor Calculator</a> gives different value.<br />Where is my mistake?

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10111&amp;mode=view"><img src="./download/file.php?id=10111&amp;t=1" alt="01.jpg" /></a><br />
			<span class="gensmall">01.jpg [ 65.6 KiB | Viewed 1218 times ]</span>
		

		<br />
	</td>
				</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10110&amp;mode=view"><img src="./download/file.php?id=10110&amp;t=1" alt="02.jpg" /></a><br />
			<span class="gensmall">02.jpg [ 79.08 KiB | Viewed 1218 times ]</span>
		

		<br />
	</td>
				</tr>
			
				<tr>
					<td>
			<a href="./download/file.php?id=10109&amp;mode=view"><img src="./download/file.php?id=10109&amp;t=1" alt="03.jpg" /></a><br />
			<span class="gensmall">03.jpg [ 73.6 KiB | Viewed 1218 times ]</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>