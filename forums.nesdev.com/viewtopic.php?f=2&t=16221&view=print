<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Pallete affects scroll value</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Pallete affects scroll value</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=16221">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=16221</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>7</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Mon Jul 17, 2017 4:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hello, I have a question about the pallet and the screen. Every 6 frames I update the pallete, the scroll value gets affected temporally. How can you fix this?<br /><br /><span style="color: #FF0000">HERE'S THE CODE:</span><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">NMI:<br /><br />&nbsp; INC scroll<br />&nbsp; &nbsp;; add one to our scroll variable each frame<br /><br /><br />NTSwapCheck:<br />&nbsp; LDA scroll ; check if the scroll just wrapped from 255 to 0<br />&nbsp; BNE NTSwapCheckP2&nbsp; <br />NTSwap:<br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; load current nametable number (0 or 1)<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exclusive OR of bit 0 will flip that bit<br />&nbsp; STA nametable&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; so if nametable was 0, now 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; if nametable was 1, now 0<br />NTSwapCheckP2:<br /><br /><br />NTSwapCheckP2:<br />&nbsp; LDA scrolly&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check if the scroll just wrapped from 255 to 0<br />&nbsp; BNE NTSwapCheckP3<br /><br />NTSwap2:<br />&nbsp; LDA nametabley&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; load current nametable number (0 or 1)<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exclusive OR of bit 0 will flip that bit<br />&nbsp; STA nametabley&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; so if nametable was 0, now 1&nbsp; <br /><br />NTSwapCheckP3:<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />NewAttribCheck:<br />&nbsp; LDA scroll<br />&nbsp; AND #%00011111&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check for multiple of 32<br />&nbsp; BNE NewAttribCheckDone&nbsp; &nbsp; ; if low 5 bits = 0, time to write new attribute bytes<br />&nbsp; jsr DrawNewAttributes<br />NewAttribCheckDone:<br /><br />&nbsp; &nbsp;<br />&nbsp; &nbsp;<br />NewColumnCheck:<br />&nbsp; LDA scroll<br />&nbsp; AND #%00000111&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; throw away higher bits to check for multiple of 8<br />&nbsp; BNE NewColumnCheckDone&nbsp; &nbsp; ; done if lower bits != 0<br />&nbsp; JSR DrawNewColumn&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if lower bits = 0, time for new column<br />&nbsp; <br />&nbsp; lda columnNumber<br />&nbsp; CMP #$FE<br />&nbsp; BCC DT9<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA scroll+2<br />&nbsp; <br />&nbsp; <br />DT9:<br />&nbsp; <br />&nbsp; lda columnNumber<br />&nbsp; clc<br />&nbsp; adc #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; go to next column<br />&nbsp; and #%11111111&nbsp; &nbsp; &nbsp; &nbsp;; only 256 columns of data, throw away top bit to wrap<br />&nbsp; sta columnNumber<br />&nbsp; <br />&nbsp; lda scroll+2<br />&nbsp; clc<br />&nbsp; adc #$01 <br />&nbsp; STA scroll+2<br />&nbsp; <br />&nbsp; <br />&nbsp; JSR Scrollcheck<br />&nbsp; &nbsp;<br />&nbsp; <br />NewColumnCheckDone:<br /><br />&nbsp; <br />&nbsp;<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA $2003&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; LDA #$02<br />&nbsp; STA $4014&nbsp; &nbsp; &nbsp; &nbsp;; sprite DMA from $0200<br />&nbsp; <br />&nbsp; <br />&nbsp; JSR LoadPalettes2<br /><br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; ; clean up PPU address registers<br />&nbsp; STA $2006<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; STA $2005&nbsp; &nbsp; &nbsp; &nbsp; ; write the horizontal scroll count register<br /><br />&nbsp; LDA scrolly&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no vertical scrolling<br />&nbsp; STA $2005<br />&nbsp; <br />&nbsp; <br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; ;;This is the PPU clean up section, so rendering the next frame starts properly.<br />&nbsp; LDA #%10010000&nbsp; &nbsp;; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1<br />&nbsp; ORA nametable&nbsp; &nbsp; ; select correct nametable for bit 0<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA #%00011110&nbsp; &nbsp;; enable sprites, enable background, no clipping on left side<br />&nbsp; STA $2001<br />&nbsp;<br />&nbsp; <br /><br />&nbsp; <br />&nbsp; JSR Updating<br />&nbsp; JSR Gravity<br />&nbsp; JSR ReadController1<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA T<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA D<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA D+1<br />&nbsp; <br /><br />&nbsp;LDA buttons<br />&nbsp; AND #%10000000 ; only look at bit 0<br />&nbsp; BEQ ReadADone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BCS ReadADone<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br /><br />&nbsp; ; save sprite X position<br />ReadADone:&nbsp; <br />&nbsp; <br />&nbsp;LDA buttons<br />&nbsp;AND #%00000001 ; only look at bit 0<br />&nbsp; BEQ ReadRightDone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA D<br />&nbsp; <br />&nbsp; LDA player&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; CLC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; ADC #$01&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; STA player<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA pdirection<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA T<br />&nbsp; ; save sprite X position<br />ReadRightDone: <br /><br />&nbsp;LDA buttons<br />&nbsp;AND #%00000010 ; only look at bit 0<br />&nbsp; BEQ ReadLeftDone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; LDA player&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; SEC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; SBC #$01&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; STA player<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA pdirection<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA T<br />&nbsp; ; save sprite X position<br />ReadLeftDone: <br /><br />&nbsp; <br />&nbsp;LDA buttons<br />&nbsp;AND #%00100000 ; only look at bit 0<br />&nbsp; BEQ ReadUpDone<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA buttons<br />&nbsp; AND #%00010000<br />&nbsp; <br />&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; LDA gamestate<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA gamestate<br />&nbsp; <br />ReadUpDone:<br />; run normal game engine code here<br />&nbsp;; reading from controllers, etc<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; RTI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return from interrupt<br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp;<br /><br />DrawNewColumn:<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp;; calculate new column address using scroll register<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; shift right 3 times = divide by 8<br />&nbsp; STA columnLow&nbsp; &nbsp; ; $00 to $1F, screen is 32 tiles wide<br /><br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp;; calculate new column address using current nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of nametable base address ($2000) can change to lower name table $2000 = ADC #$20 $2800 = ADC #$28<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $20 or $24 for nametable 0 or 1<br /><br />&nbsp; LDA columnNumber&nbsp; ; column number * 32 = column data offset<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; JSR levelselect<br />&nbsp; <br /><br />DrawColumn:<br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDX #$1E&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; copy 30 bytes<br />&nbsp; LDY #$1E<br />DrawColumnLoop:<br />&nbsp; LDA &#91;sourceLow&#93;, y<br />&nbsp; STA $2007<br />&nbsp; INY<br />&nbsp; DEX<br />&nbsp; BNE DrawColumnLoop<br /><br />&nbsp; <br /><br /><br />&nbsp; <br />DrawNewColumn2:<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp;; calculate new column address using scroll register<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; shift right 3 times = divide by 8<br />&nbsp; STA columnLow2&nbsp; &nbsp; ; $00 to $1F, screen is 32 tiles wide<br /><br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp;; calculate new column address using current nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$28&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of nametable base address ($2000) can change to lower name table $2000 = ADC #$20 $2800 = ADC #$28 changes what loads the name table in the bottem name table in<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $20 or $24 for nametable 0 or 1<br /><br />&nbsp; LDA columnNumber2&nbsp; ; column number * 32 = column data offset<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; STA sourceLow2<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh2<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #$04<br />&nbsp; STA sourceLow2<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #$04<br />&nbsp; STA sourceHigh2<br /><br />DrawColumn2:<br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDX #$1E&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 30 bytes<br />&nbsp; LDY #$1E<br />DrawColumnLoop2:<br />&nbsp; LDA &#91;sourceLow2&#93;, y<br />&nbsp; STA $2007<br />&nbsp; INY<br />&nbsp; DEX<br />&nbsp; BNE DrawColumnLoop2<br /><br />&nbsp; <br /><br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />&nbsp; <br /><br />&nbsp; <br />&nbsp; <br />DrawNewAttributes:<br />&nbsp; LDA nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$23&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of attribute base address ($23C0)<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $23 or $27 for nametable 0 or 1<br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; CLC<br />&nbsp; ADC #$C0<br />&nbsp; STA columnLow&nbsp; &nbsp; &nbsp;; attribute base + scroll / 32<br /><br />&nbsp; LDA columnNumber&nbsp; ; (column number / 4) * 8 = column data offset<br />&nbsp; AND #%11111100<br />&nbsp; ASL A<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #LOW(attribData)<br />&nbsp; STA sourceLow<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #HIGH(attribData)<br />&nbsp; STA sourceHigh<br /><br />&nbsp; LDY #$00<br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />DrawNewAttributesLoop<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDA &#91;sourceLow&#93;, y&nbsp; &nbsp; ; copy new attribute byte<br />&nbsp; STA $2007<br />&nbsp; <br />&nbsp; INY<br />&nbsp; CPY #$08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 8 attribute bytes<br />&nbsp; BEQ DrawNewAttributesLoopDone <br />&nbsp; <br />&nbsp; LDA columnLow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; next attribute byte is at address + 8<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA columnLow<br />&nbsp; JMP DrawNewAttributesLoop<br />DrawNewAttributesLoopDone:<br /><br />&nbsp; RTS<br /><br />DrawNewAttributes2:<br />&nbsp; LDA nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$23&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of attribute base address ($23C0)<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $23 or $27 for nametable 0 or 1<br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; CLC<br />&nbsp; ADC #$C0<br />&nbsp; STA columnLow&nbsp; &nbsp; &nbsp;; attribute base + scroll / 32<br /><br />&nbsp; LDA columnNumber&nbsp; ; (column number / 4) * 8 = column data offset<br />&nbsp; AND #%11111100<br />&nbsp; ASL A<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #$04<br />&nbsp; STA sourceLow2<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #$04<br />&nbsp; STA sourceHigh2<br /><br />&nbsp; LDY #$00<br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />DrawNewAttributesLoop2<br />&nbsp; LDA columnHigh2<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDA &#91;sourceLow2&#93;, y&nbsp; &nbsp; ; copy new attribute byte<br />&nbsp; STA $2007<br />&nbsp; <br />&nbsp; INY<br />&nbsp; CPY #$08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 8 attribute bytes<br />&nbsp; BEQ DrawNewAttributesLoopDone2 <br />&nbsp; <br />&nbsp; LDA columnLow2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; next attribute byte is at address + 8<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA columnLow2<br />&nbsp; JMP DrawNewAttributesLoop2<br />DrawNewAttributesLoopDone2:<br /><br /><br />&nbsp; <br /><br /><br />&nbsp; rts<br /><br />; skip the update function<br />LoadPalettes2:<br /><br /><br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1+5<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1+6<br />&nbsp; <br />&nbsp; LDX #$00<br />&nbsp; <br />LP2:<br />&nbsp; <br />&nbsp; LDA #$3F<br />&nbsp; STA $2006<br />&nbsp; LDA Timer1+6<br />&nbsp; STA $2006<br />&nbsp; <br />&nbsp; LDA paletteswap , x<br />&nbsp; STA $2007<br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; INX<br />&nbsp; <br />&nbsp; INC Timer1+5<br />&nbsp; <br />&nbsp; INC Timer1+6<br />&nbsp; <br />&nbsp; LDA Timer1+5<br />&nbsp; CMP #$20<br />&nbsp; BEQ Fin<br />&nbsp; <br />&nbsp; <br />&nbsp; JMP LP2<br />&nbsp; <br />Fin:<br /><br /><br />&nbsp; <br />&nbsp; <br />&nbsp; RTS<br />&nbsp;<br />&nbsp;</div><br />I have also read this:<br /><!-- m --><a class="postlink" href="https://wiki.nesdev.com/w/index.php/The_frame_and_NMIs">https://wiki.nesdev.com/w/index.php/The_frame_and_NMIs</a><!-- m --><br />And I don't Understand what he mean to do for lda needppureg<br />Please first explain what the problem is before showing the code.<br />Thanks.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>dougeff</b> [ Mon Jul 17, 2017 5:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><s>The PPU is weird. The PPU Address &#40;$2006&#41; shares bits with the scroll &#40;$2005&#41;. Writing to one affects the other.<br /><br />After writing to the PPU, you must set a nametable&#40;write to $2000&#41;, and set a scroll position &#40;2 writes to $2005&#41;</s><br /><br />Edit. I think you are doing what i said.<br /><br />Probably a timing issue. Writing outside V-blank.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Mon Jul 17, 2017 5:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Not sure if it's the culprit, but I see that you have &quot;PPU cleanup&quot; twice and one of them comes after your scroll updates.<br /><br />I see some other bad things as well. You have logic at the beginning of your NMI handler, logic is better to have in the main loop, or after all graphic updates (OAM, VRAM and certain register updates) in the NMI, else it will steal vblank time. The NMI handler first needs to backup registers A, X and Y to stack (unless you are doing the all-in-NMI approach) then immediately do graphic updates. The order of the graphic updates is ideally something like this:<br />1) Check your render flag and skip all graphic updates if clear (read bellow)<br />2) Read $2002 to reset high/low latch<br />3) Sprite updates (OAM DMA)<br />4) Background updates<br />5) Palette updates<br />6) $2000 and $2001 updates<br />7) Scroll updates ($2005)<br />4, 5 and 6 can probably come in any order, but OAM DMA should be done early for PAL compatibility and Scroll should be updated last because PPU register writes affects the scroll register.<br /><br />After all the graphic updates, you can have things that don't have to be in vblank, like sound updates or controller updates, though I heard controller updates are better to have in your main loop to avoid possible inconsistencies. Sound is best to be in NMI though since it ensures mostly constant tempo timing.<br /><br />About the needppureg flag, he uses it whenever he has made changes to $2000 or $2001 in their buffers so that the NMI only updates them when the flag is set. I don't think it's really necessary to make them conditional separately. You should make the whole graphic update block conditional though. Have a render flag that is set at the end of each main loop and cleared at the end of each NMI. If the flag is not set, jump past all the graphic updates (but not sound and everything after that). That way there is no risk for drawing partly updated frames when the game lags.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Tue Jul 18, 2017 7:53 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />What logic is at the main loop?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Tue Jul 18, 2017 10:56 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Everything in your NMI before the sprite DMA looks like logic to me (it does not write to VRAM, OAM or PPU registers, so it's not graphic updates). It should be in your main loop.<br /><br />Is the main loop in your NMI? In that case it should come after the graphic updates, because the first part of the NMI always happens during the vblank interval, which is limited. The article you linked to explains this too.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>dougeff</b> [ Tue Jul 18, 2017 8:59 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Definitely writing to PPU outside V-blank. I dropped your code into a blank template, and put some breakpoints on when the final scroll setting is done. About every 8 frames, you are clear down to scanline 7, occasionally more, by the time you set the scroll for the screen. [I had to make some assumptions, since you didn't provide the entire source code, I might be off by a few lines]<br /><br />Eliminating the line...<br />jsr LoadPalettes2 (you are updating the entire palette, every frame)<br />-I don't know why you said &quot;Every 6 frames&quot;. It happens every frame.<br /><br />...improves this quite a bit, but still hitting scanline 1 occasionally, which would shift the entire screen by 1 pixel. Jittery. If you tightened your code a bit (made loops slightly more efficient). You could probably avoid the scroll shift entirely.<br /><br />A more ideal solution, would be to do most of the calculations before hand (outside of NMI). Load all updates into a buffer (also outside of NMI), and make a much more efficient system of writing to the PPU. Then you could put the palette updates back in.<br /><br /><br /><br /><br />EDIT: also...<br /><br />[deleted some code advice, I didn't like my wording]<br /><br />You need to be careful about which direction PPU writes are going. You specifically set it to +32 in the DrawColumn / DrawColumn2 subroutines, but that comes after the attribute table subroutine, and it's still set to +1 mode from the end of the NMI write to $2000 [I guess that won't cause a problem, now that I look at it]. Further, it is still in +32 mode (sometimes) when it gets to LoadPalettes2, which needs it to be in +1 mode.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Thu Jul 20, 2017 6:27 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><span style="color: #4000FF">Cool.  <img src="./images/smilies/icon_mrgreen.gif" alt=":mrgreen:" title="Mr. Green" /> </span><br />1. Is updating the palette EVERY FRAME a bad thing and can it be done with buffering?<br />2 whuts buffering?<br />3 pla does What?<br />Also Would It help to give you the .nes file for reference?<br />Heres the new CODE:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">LoadPalettes2:<br /><br /><br />&nbsp; LDA #%00000000&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1+5<br />&nbsp; STA Timer1+6<br />&nbsp; <br />&nbsp; LDX #$00<br />&nbsp; <br />LP2:<br />&nbsp; <br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; LDA #$3F<br />&nbsp; STA $2006<br />&nbsp; LDA Timer1+6<br />&nbsp; STA $2006<br />&nbsp; <br />&nbsp; LDA paletteswap , x<br />&nbsp; STA $2007<br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; INX<br />&nbsp; <br />&nbsp; INC Timer1+5<br />&nbsp; <br />&nbsp; INC Timer1+6<br />&nbsp; <br />&nbsp; LDA Timer1+5<br />&nbsp; CMP #$20<br />&nbsp; BEQ Fin<br />&nbsp; <br />&nbsp; <br />&nbsp; JMP LP2<br />&nbsp; <br />Fin:<br /><br /><br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; RTS<br />&nbsp;</div><br />NOW, to learn buffering.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Fri Jul 21, 2017 2:47 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />1. Not a bad thing as long as it is updated in vblank, and yes buffering is the preferable way to do it. The palette isn't that big but if you are short on vblank time you could make a buffer system that only updates parts of the palette instead of the whole palette every time. You could also make a buffer system that updates nametable and palette together so that changing BG characters also changes their colours at the same time.<br /><br />2. Buffering is keeping a copy of whatever you buffer (usually graphic updates) in a RAM area. You update this buffer in your game logic (main loop) and in the beginning of NMI (vblank) you just copy the contents of this buffer to VRAM/OAM etc. This way you can keep game logic and graphic updates separate. You are already buffering the OAM by using the RAM area $0200 to $02FF as an OAM buffer (or shadow OAM as they also call it). But DMA can only be used for OAM (sprite attributes), not for VRAM (nametable and palette), so you have to code a different buffer system for those. Updates to $2000 and $2001 should also be buffered in their own RAM registers so that they are also only changed in vblank.<br /><br />3. PLA pulls the topmost value from the stack and puts it in the accumulator. If you have your main loop outside of NMI handler (in your RESET handler), you need to backup both the accumulator and the index registers X and Y on the stack at the start of your NMI handler and pull them out again in reverse order. PHA pushes the accumulator on to the stack but there are no instructions for pushing or pulling X or Y to or from stack, so you have to transfer X and Y into A first (using TXA/TYA when pushing and TAX/TAY after pulling):<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">NMI:<br />&nbsp; pha<br />&nbsp; txa<br />&nbsp; pha<br />&nbsp; tya<br />&nbsp; pha&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;save A, X and Y to the stack<br /><br />;(NMI code here)<br /><br />&nbsp; pla<br />&nbsp; tay<br />&nbsp; pla<br />&nbsp; tax<br />&nbsp; pla&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;restore A, X and Y from the stack<br />&nbsp; rti<br /></div><br />This is needed because the NMI is an interrupt that could happen at any time in your main loop, and since both main and NMI uses the registers it could mess up your code. You don't need to backup the status flags however, because they are backed up automatically whenever an interrupt occurs.<br /><br />The NES file would help, but the whole source code would help more.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Fri Jul 21, 2017 1:01 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; .inesprg 1&nbsp; ; 1x 16KB PRG code<br />&nbsp; .ineschr 4&nbsp; &nbsp;; 1x&nbsp; 8KB CHR data<br />&nbsp; .inesmap 4&nbsp; &nbsp;; mapper 0 = NROM, no bank swapping<br />&nbsp; .inesmir 2&nbsp; &nbsp;; background mirroring<br />&nbsp; <br /><br />;;;;;;;;;;;;;;;<br />&nbsp; &nbsp; .rsset $0000&nbsp; ;;start variables at ram location 0<br />&nbsp; <br /><br />paletteswap&nbsp; &nbsp; &nbsp;.rs 32<br />scroll&nbsp; &nbsp; &nbsp;.rs 3<br />D&nbsp; &nbsp; &nbsp;.rs 2 <br />scrolly&nbsp; &nbsp; &nbsp;.rs 1 <br />gravity&nbsp; &nbsp; .rs 1<br />buttons&nbsp; &nbsp; .rs 1<br />gamestate&nbsp; .rs 4<br />progress&nbsp; &nbsp;.rs 1<br />buttonslay .rs 1<br />player&nbsp; &nbsp; &nbsp;.rs 2<br />feet&nbsp; &nbsp; &nbsp; &nbsp;.rs 1<br />jheight&nbsp; &nbsp; .rs 1<br />pdirection .rs 5<br />grounded .rs 1<br />Frame .rs 1<br />Fr .rs 1<br />Timer1 .rs 12<br />ANT .rs 4<br />T .rs 1<br />Srt .rs 6<br /><br />Ant .rs 1<br />L .rs 1<br />BCount .rs 16<br />JumpState .rs 3<br />nametable&nbsp; .rs 1<br />nametabley&nbsp; .rs 1&nbsp; ;&nbsp; ; which nametable to use, 0 or 1<br />columnLow&nbsp; .rs 1&nbsp; ; low byte of new column address<br />columnHigh .rs 1&nbsp; ; high byte of new column address<br />sourceLow&nbsp; .rs 1&nbsp; ; source for column data<br />sourceHigh .rs 1<br />columnNumber .rs 1<br />columnNumber2 .rs 1<br />sourceLow2&nbsp; .rs 1&nbsp; ; source for column data<br />sourceHigh2 .rs 1<br />columnLow2&nbsp; .rs 1&nbsp; ; low byte of new column address<br />columnHigh2 .rs 1&nbsp; ; hi<br /><br /><br />&nbsp; ; which column of level data to<br /><br /><br /><br />GROUND&nbsp; &nbsp; &nbsp;= $B1&nbsp; ;<br /><br /><br /><br />;;;;;;;;;;;;;;;<br /><br /><br />&nbsp; .bank 0<br />&nbsp; .org $C000<br />&nbsp; <br />&nbsp; vblankwait:<br />&nbsp; BIT $2002<br />&nbsp; BPL vblankwait<br />&nbsp; RTS<br />&nbsp; <br />&nbsp; <br />&nbsp; RESET:<br />&nbsp; SEI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; disable IRQs<br />&nbsp; CLD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; disable decimal mode<br />&nbsp; LDX #$40<br />&nbsp; STX $4017&nbsp; &nbsp; ; disable APU frame IRQ<br />&nbsp; LDX #$FF<br />&nbsp; TXS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Set up stack<br />&nbsp; INX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now X = 0<br />&nbsp; STX $2000&nbsp; &nbsp; ; disable NMI<br />&nbsp; STX $2001&nbsp; &nbsp; ; disable rendering<br />&nbsp; STX $4010&nbsp; &nbsp; ; disable DMC IRQs<br />&nbsp; lda #%00000001<br />&nbsp; sta $4017 ;enable Square 1<br />&nbsp; <br />&nbsp; &nbsp; ;square 1<br />&nbsp; lda #%00000000 ;Duty 10, Length Counter Disabled, Saw Envelopes disabled, Volume F<br />&nbsp; sta $4000<br />&nbsp; &nbsp; <br />&nbsp; lda #$C9&nbsp; &nbsp; ;0C9 is a C# in NTSC mode<br />&nbsp; sta $4002&nbsp; &nbsp;;low 8 bits of period<br />&nbsp; lda #$00<br />&nbsp; sta $4003 <br />&nbsp; <br />&nbsp; &nbsp;<br />&nbsp; JSR vblankwait&nbsp; &nbsp; &nbsp;<br /><br />clrmem:<br />&nbsp; LDA #$00<br />&nbsp; STA $0000, x<br />&nbsp; STA $0100, x<br />&nbsp; STA $0200, x<br />&nbsp; STA $0400, x<br />&nbsp; STA $0500, x<br />&nbsp; STA $0600, x<br />&nbsp; STA $0700, x<br />&nbsp; LDA #$FE<br />&nbsp; STA $0300, x<br />&nbsp; INX<br />&nbsp; BNE clrmem<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;JSR vblankwait&nbsp; &nbsp;<br /><br />&nbsp; <br />LoadPalettes:<br />&nbsp; LDA $2002&nbsp; &nbsp; ; read PPU status to reset the high/low latch<br />&nbsp; LDA #$3F<br />&nbsp; STA $2006&nbsp; &nbsp; ; write the high byte of $3F00 address<br />&nbsp; LDA #$00<br />&nbsp; STA $2006&nbsp; &nbsp; ; write the low byte of $3F00 address<br />&nbsp; LDX #$00<br />LoadPalettesLoop:<br />&nbsp; LDA palette, x&nbsp; &nbsp; &nbsp; &nbsp; ;load palette byte<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; STA $2007&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;write to PPU<br />&nbsp; INX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;set index to next byte<br />&nbsp; CPX #$20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; BNE LoadPalettesLoop <br /><br />&nbsp; LoadPalettesLoop1:<br />&nbsp; LDA palette, x&nbsp; &nbsp; &nbsp; &nbsp; ;load palette byte<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; STA paletteswap, x&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;write to PPU<br />&nbsp; INX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;set index to next byte<br />&nbsp; CPX #$20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; BNE LoadPalettesLoop1&nbsp; &nbsp;;if x = $20, 32 bytes copied, all done<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />LoadPSprites:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDX #$00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; start at 0<br />LoadSpritesLoopP:<br />&nbsp; LDA Playersprites, x&nbsp; &nbsp; &nbsp; &nbsp; ; load data from address (sprites +&nbsp; x)<br />&nbsp; STA $0200, x&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; store into RAM address ($0200 + x)<br />&nbsp; INX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; X = X + 1<br />&nbsp; CPX #$08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Compare X to hex $20, decimal 32<br />&nbsp; BNE LoadSpritesLoopP&nbsp; &nbsp;; Branch to LoadSpritesLoop if compare was Not Equal to zero<br />&nbsp; <br />LoadESprites:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDX #$00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; start at 0<br />LoadSpritesLoopE:<br />&nbsp; LDA Esprites, x&nbsp; &nbsp; &nbsp; &nbsp; ; load data from address (sprites +&nbsp; x)<br />&nbsp; STA $0218, x&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; store into RAM address ($0200 + x)<br />&nbsp; INX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; X = X + 1<br />&nbsp; CPX $FF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Compare X to hex $20, decimal 32<br />&nbsp; BNE LoadSpritesLoopE&nbsp; &nbsp;; Branch to LoadSpritesLoop if compare was Not Equal to zero<br />&nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br />&nbsp; &nbsp;<br />&nbsp; <br />InitializeNametables:<br />&nbsp; LDA #$01<br />&nbsp; STA nametable<br />&nbsp; LDA #$00<br />&nbsp; STA scroll<br />&nbsp; STA columnNumber<br />InitializeNametablesLoop:<br />&nbsp; JSR DrawNewColumn<br />&nbsp; ; draw bg column<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go to next column<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA scroll<br />&nbsp; INC columnNumber<br />&nbsp; LDA columnNumber&nbsp; &nbsp; &nbsp; ; repeat for first nametable <br />&nbsp; CMP #$20<br />&nbsp; BNE InitializeNametablesLoop<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA nametable<br />&nbsp; LDA #$00<br />&nbsp; STA scroll<br />&nbsp; JSR DrawNewColumn&nbsp; &nbsp; &nbsp;; draw first column of second nametable<br />&nbsp; INC columnNumber<br />&nbsp; <br />&nbsp; LDA #$00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set back to increment +1 mode<br />&nbsp; STA $2000<br />InitializeNametablesDone:<br /><br /><br />InitializeAttributes:<br />&nbsp; LDA #$01<br />&nbsp; STA nametable<br />&nbsp; LDA #$00<br />&nbsp; STA scroll<br />&nbsp; STA columnNumber<br />InitializeAttributesLoop:<br />&nbsp; JSR DrawNewAttributes&nbsp; &nbsp; &nbsp;; draw attribs<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go to next column<br />&nbsp; CLC<br />&nbsp; ADC #$20<br />&nbsp; STA scroll<br /><br />&nbsp; LDA columnNumber&nbsp; &nbsp; &nbsp; ; repeat for first nametable <br />&nbsp; CLC <br />&nbsp; ADC #$04<br />&nbsp; STA columnNumber<br />&nbsp; CMP #$20<br />&nbsp; BNE InitializeAttributesLoop<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA nametable<br />&nbsp; LDA #$00<br />&nbsp; STA scroll<br />&nbsp; JSR DrawNewAttributes&nbsp; &nbsp; &nbsp;; draw first column of second nametable<br />InitializeAttributesDone:<br /><br />&nbsp; LDA #$21<br />&nbsp; STA columnNumber<br /><br /><br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$10<br />&nbsp; STA paletteswap<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; LDA #$80<br />&nbsp; STA player<br />&nbsp; <br />&nbsp; LDA #$FE<br />&nbsp; STA scrolly<br />&nbsp; <br />&nbsp; LDA #$80<br />&nbsp; STA player+1<br />&nbsp; <br />&nbsp; LDA #$08<br />&nbsp; STA pdirection+1<br />&nbsp; <br />&nbsp; LDA #$06<br />&nbsp; STA ANT<br />&nbsp; <br />&nbsp; LDA #$08<br />&nbsp; STA ANT+1<br />&nbsp; <br />&nbsp; LDA #$0A<br />&nbsp; STA ANT+2<br />&nbsp; <br />&nbsp; LDA #$06<br />&nbsp; STA ANT+3<br />&nbsp; <br />&nbsp; LDA #$06<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gamestate+1<br />&nbsp; <br />&nbsp; <br /><br /><br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #%10010000&nbsp; &nbsp;; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1<br />&nbsp; STA $2000<br /><br />&nbsp; LDA #%00011000&nbsp; &nbsp;; enable sprites, enable background, no clipping on left side<br />&nbsp; STA $2001<br /><br />Forever:<br />&nbsp; JMP Forever&nbsp; &nbsp; &nbsp;;jump back to Forever, infinite loop<br />&nbsp; <br /><br /><br />NMI:<br /><br /><br /><br />&nbsp; <br /><br />&nbsp; INC scroll<br />&nbsp; &nbsp;; add one to our scroll variable each frame<br /><br /><br />NTSwapCheck:<br />&nbsp; LDA scroll ; check if the scroll just wrapped from 255 to 0<br />&nbsp; BNE NTSwapCheckP2&nbsp; <br />NTSwap:<br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; load current nametable number (0 or 1)<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exclusive OR of bit 0 will flip that bit<br />&nbsp; STA nametable&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; so if nametable was 0, now 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; if nametable was 1, now 0<br /><br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; so if nametable was 0, now 1&nbsp; <br /><br />NTSwapCheckP2:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA $2003&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; LDA #$02<br />&nbsp; STA $4014&nbsp; &nbsp; &nbsp; &nbsp;; sprite DMA from $0200<br />&nbsp; <br />NewAttribCheck:<br />&nbsp; LDA scroll<br />&nbsp; AND #%00011111&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check for multiple of 32<br />&nbsp; BNE NewAttribCheckDone&nbsp; &nbsp; ; if low 5 bits = 0, time to write new attribute bytes<br />&nbsp; jsr DrawNewAttributes<br />&nbsp; <br />NewAttribCheckDone:<br /><br />&nbsp; &nbsp;<br />&nbsp; &nbsp;<br />NewColumnCheck:<br />&nbsp; LDA scroll<br />&nbsp; AND #%00000111&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; throw away higher bits to check for multiple of 8<br />&nbsp; BNE NewColumnCheckDone&nbsp; &nbsp; ; done if lower bits != 0<br />&nbsp; JSR DrawNewColumn&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if lower bits = 0, time for new column<br />&nbsp; <br />&nbsp; lda columnNumber<br />&nbsp; CMP #$FE<br />&nbsp; BCC DT9<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA scroll+2<br />&nbsp; <br />&nbsp; <br />DT9:<br />&nbsp; <br />&nbsp; <br />&nbsp; lda columnNumber<br />&nbsp; clc<br />&nbsp; adc #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; go to next column<br />&nbsp; and #%11111111&nbsp; &nbsp; &nbsp; &nbsp;; only 256 columns of data, throw away top bit to wrap<br />&nbsp; sta columnNumber<br />&nbsp; <br />&nbsp; lda scroll+2<br />&nbsp; clc<br />&nbsp; adc #$01 <br />&nbsp; STA scroll+2<br />&nbsp; <br />&nbsp; <br />&nbsp; JSR Scrollcheck<br />&nbsp; &nbsp;<br />&nbsp; <br />NewColumnCheckDone:<br /><br />&nbsp; <br /><br />&nbsp; JSR LoadPalettes2<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; STA $2006<br />&nbsp; <br />&nbsp; &nbsp;;;This is the PPU clean up section, so rendering the next frame starts properly.<br />&nbsp; LDA #%10010000&nbsp; &nbsp;; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1<br />&nbsp; ORA nametable&nbsp; &nbsp; ; select correct nametable for bit 0<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA #%0001100&#91;0&nbsp; &nbsp;; enable sprites, enable background, no clipping on left side<br />&nbsp; STA $2001<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; STA $2005&nbsp; &nbsp; &nbsp; &nbsp; ; write the horizontal scroll count register<br /><br />&nbsp; LDA scrolly&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no vertical scrolling<br />&nbsp; STA $2005<br />&nbsp; <br />&nbsp; <br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp;<br />&nbsp;<br />&nbsp; <br /><br />&nbsp; <br />&nbsp; JSR Updating<br />&nbsp; JSR ReadController1<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA T<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA D<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA D+1<br />&nbsp; <br /><br />&nbsp;LDA buttons<br />&nbsp; AND #%10000000 ; only look at bit 0<br />&nbsp; BEQ ReadADone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BCS ReadADone<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br /><br />&nbsp; ; save sprite X position<br />ReadADone:&nbsp; <br />&nbsp; <br />&nbsp;LDA buttons<br />&nbsp;AND #%00000001 ; only look at bit 0<br />&nbsp; BEQ ReadRightDone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA D<br />&nbsp; <br />&nbsp; LDA player&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; CLC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; ADC #$01&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; STA player<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA pdirection<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA T<br />&nbsp; ; save sprite X position<br />ReadRightDone: <br /><br />&nbsp;LDA buttons<br />&nbsp;AND #%00000010 ; only look at bit 0<br />&nbsp; BEQ ReadLeftDone&nbsp; &nbsp;; branch to ReadADone if button is NOT pressed (0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; LDA player&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; SEC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; SBC #$01&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; STA player<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA pdirection<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA T<br />&nbsp; ; save sprite X position<br />ReadLeftDone: <br /><br />&nbsp; <br />&nbsp;LDA buttons<br />&nbsp;AND #%00100000 ; only look at bit 0<br />&nbsp; BEQ ReadUpDone<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA buttons<br />&nbsp; AND #%00010000<br />&nbsp; <br />&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; LDA gamestate<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA gamestate<br />&nbsp; <br />ReadUpDone:<br />; run normal game engine code here<br />&nbsp;; reading from controllers, etc<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; RTI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return from interrupt<br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp;<br /><br />DrawNewColumn:<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp;; calculate new column address using scroll register<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; shift right 3 times = divide by 8<br />&nbsp; STA columnLow&nbsp; &nbsp; ; $00 to $1F, screen is 32 tiles wide<br /><br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp;; calculate new column address using current nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of nametable base address ($2000) can change to lower name table $2000 = ADC #$20 $2800 = ADC #$28<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $20 or $24 for nametable 0 or 1<br /><br />&nbsp; LDA columnNumber&nbsp; ; column number * 32 = column data offset<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; JSR levelselect<br />&nbsp; <br /><br />DrawColumn:<br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDX #$1E&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; copy 30 bytes<br />&nbsp; LDY #$1E<br />DrawColumnLoop:<br />&nbsp; LDA &#91;sourceLow&#93;, y<br />&nbsp; STA $2007<br />&nbsp; INY<br />&nbsp; DEX<br />&nbsp; BNE DrawColumnLoop<br /><br />&nbsp; <br /><br /><br />&nbsp; <br />DrawNewColumn2:<br />&nbsp; LDA scroll&nbsp; &nbsp; &nbsp; &nbsp;; calculate new column address using scroll register<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; shift right 3 times = divide by 8<br />&nbsp; STA columnLow2&nbsp; &nbsp; ; $00 to $1F, screen is 32 tiles wide<br /><br />&nbsp; LDA nametable&nbsp; &nbsp; &nbsp;; calculate new column address using current nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$28&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of nametable base address ($2000) can change to lower name table $2000 = ADC #$20 $2800 = ADC #$28 changes what loads the name table in the bottem name table in<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $20 or $24 for nametable 0 or 1<br /><br />&nbsp; LDA columnNumber2&nbsp; ; column number * 32 = column data offset<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; STA sourceLow2<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh2<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #$04<br />&nbsp; STA sourceLow2<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #$04<br />&nbsp; STA sourceHigh2<br /><br />DrawColumn2:<br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDX #$1E&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 30 bytes<br />&nbsp; LDY #$1E<br />DrawColumnLoop2:<br />&nbsp; LDA &#91;sourceLow2&#93;, y<br />&nbsp; STA $2007<br />&nbsp; INY<br />&nbsp; DEX<br />&nbsp; BNE DrawColumnLoop2<br /><br />&nbsp; <br /><br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />&nbsp; <br /><br />&nbsp; <br />&nbsp; <br />DrawNewAttributes:<br />&nbsp; LDA nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$23&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of attribute base address ($23C0)<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $23 or $27 for nametable 0 or 1<br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; CLC<br />&nbsp; ADC #$C0<br />&nbsp; STA columnLow&nbsp; &nbsp; &nbsp;; attribute base + scroll / 32<br /><br />&nbsp; LDA columnNumber&nbsp; ; (column number / 4) * 8 = column data offset<br />&nbsp; AND #%11111100<br />&nbsp; ASL A<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #LOW(attribData)<br />&nbsp; STA sourceLow<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #HIGH(attribData)<br />&nbsp; STA sourceHigh<br /><br />&nbsp; LDY #$00<br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />DrawNewAttributesLoop<br />&nbsp; LDA columnHigh<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDA &#91;sourceLow&#93;, y&nbsp; &nbsp; ; copy new attribute byte<br />&nbsp; STA $2007<br />&nbsp; <br />&nbsp; INY<br />&nbsp; CPY #$08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 8 attribute bytes<br />&nbsp; BEQ DrawNewAttributesLoopDone <br />&nbsp; <br />&nbsp; LDA columnLow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; next attribute byte is at address + 8<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA columnLow<br />&nbsp; JMP DrawNewAttributesLoop<br />DrawNewAttributesLoopDone:<br /><br />&nbsp; RTS<br /><br />DrawNewAttributes2:<br />&nbsp; LDA nametable<br />&nbsp; EOR #$01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; invert low bit, A = $00 or $01<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; shift up, A = $00 or $02<br />&nbsp; ASL A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; $00 or $04<br />&nbsp; CLC<br />&nbsp; ADC #$23&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add high byte of attribute base address ($23C0)<br />&nbsp; STA columnHigh&nbsp; &nbsp; ; now address = $23 or $27 for nametable 0 or 1<br />&nbsp; <br />&nbsp; LDA scroll<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; CLC<br />&nbsp; ADC #$C0<br />&nbsp; STA columnLow&nbsp; &nbsp; &nbsp;; attribute base + scroll / 32<br /><br />&nbsp; LDA columnNumber&nbsp; ; (column number / 4) * 8 = column data offset<br />&nbsp; AND #%11111100<br />&nbsp; ASL A<br />&nbsp; STA sourceLow<br />&nbsp; LDA columnNumber<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; LSR A<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #$04<br />&nbsp; STA sourceLow2<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #$04<br />&nbsp; STA sourceHigh2<br /><br />&nbsp; LDY #$00<br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />DrawNewAttributesLoop2<br />&nbsp; LDA columnHigh2<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the high byte of column address<br />&nbsp; LDA columnLow<br />&nbsp; STA $2006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the low byte of column address<br />&nbsp; LDA &#91;sourceLow2&#93;, y&nbsp; &nbsp; ; copy new attribute byte<br />&nbsp; STA $2007<br />&nbsp; <br />&nbsp; INY<br />&nbsp; CPY #$08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy 8 attribute bytes<br />&nbsp; BEQ DrawNewAttributesLoopDone2 <br />&nbsp; <br />&nbsp; LDA columnLow2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; next attribute byte is at address + 8<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA columnLow2<br />&nbsp; JMP DrawNewAttributesLoop2<br />DrawNewAttributesLoopDone2:<br /><br /><br />&nbsp; <br /><br /><br />&nbsp; rts<br />&nbsp;<br />levelselect:<br /><br />&nbsp; LDA gamestate+1<br />&nbsp; CMP #$00<br />&nbsp; BEQ l00<br />&nbsp; <br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #LOW(columnDatay)<br />&nbsp; STA sourceLow<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #HIGH(columnDatay)<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; RTS<br />l00:<br /><br />&nbsp; LDA sourceLow&nbsp; &nbsp; &nbsp; &nbsp;; column data start + offset = address to load column data from<br />&nbsp; CLC <br />&nbsp; ADC #LOW(columnData)<br />&nbsp; STA sourceLow<br />&nbsp; LDA sourceHigh<br />&nbsp; ADC #HIGH(columnData)<br />&nbsp; STA sourceHigh<br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />Scrollcheck:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA columnNumber<br />&nbsp; CMP #$00<br />&nbsp; BCC Neve<br />&nbsp; <br />Sc:<br />&nbsp; <br />&nbsp; LDA scroll+2<br />&nbsp; CMP #$20<br />&nbsp; BEQ Endt<br />&nbsp; <br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />Neve:<br /><br />&nbsp; LDA #$FF<br />&nbsp; STA columnNumber<br />&nbsp; <br />Endt:<br />&nbsp; LDA columnNumber<br />&nbsp; CLC <br />&nbsp; <br />&nbsp; ADC #$20<br />&nbsp; STA columnNumber<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA scroll+2&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />;;;;;;;;;;;;;;&nbsp; <br /><br />&nbsp; JMP BulletM<br /><br /><br /><br /><br />BulletM:<br />&nbsp; CLC <br />&nbsp; ADC #$02<br />&nbsp; RTS<br /><br />&nbsp; <br /><br /><br />&nbsp; <br />&nbsp; Updating:<br /><br />&nbsp;<br />&nbsp;<br /><br /><br />&nbsp;<br />&nbsp; <br />&nbsp; LDA Frame<br />&nbsp; CMP #$3C<br />&nbsp; BCS AniFrame <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Frame<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA Timer1+3<br />&nbsp; CMP #$00<br />&nbsp; BEQ No<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1+3<br />&nbsp; <br />&nbsp; JMP FS2<br />&nbsp; <br />No:<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA Timer1+3<br />&nbsp; <br />FS2:<br /><br />&nbsp; <br />&nbsp; LDA Timer1+11<br />&nbsp; CMP #$03<br />&nbsp; BEQ No2<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA Timer1+10<br />&nbsp; <br />&nbsp; JMP FSl<br />&nbsp; <br />No2:<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA Timer1+3<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; JMP FSl<br />&nbsp; <br /><br />&nbsp; <br /><br />&nbsp; <br />FSl:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA paletteswap+17<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA paletteswap+17 <br />&nbsp; <br />&nbsp; LDA paletteswap<br />&nbsp; CMP #$1D<br />&nbsp; BCS Flu<br />&nbsp; <br />&nbsp; JMP Fly<br />&nbsp; <br />&nbsp; <br />Flu:<br />&nbsp; <br />&nbsp; LDA #$10<br />&nbsp; STA paletteswap<br /><br />Fly:<br />&nbsp; <br /><br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$02<br />&nbsp; BCS AniFrame<br />&nbsp; <br />AniFrame:<br /><br />&nbsp; <br />&nbsp; <br />&nbsp; LDA Srt<br />&nbsp; STA $0211<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA $0215<br />&nbsp; <br />&nbsp; LDA Srt+1<br />&nbsp; STA $0209<br />&nbsp; <br />&nbsp; LDA Srt+2<br />&nbsp; STA $020D<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; STA $0219<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; STA $021B<br />&nbsp; <br />&nbsp; LDA Timer1+1<br />&nbsp; STA $021A<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />Vertical:<br /><br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; STA $0200<br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; STA $0204<br /><br />&nbsp; LDA player+1 <br />&nbsp; CLC<br />&nbsp; ADC #$08&nbsp; ; A = A - 1<br />&nbsp; STA $0208<br /><br />&nbsp;LDA player+1<br />&nbsp; CLC<br />&nbsp; ADC #$08&nbsp; ;&nbsp; &nbsp; &nbsp;; A = A - 1<br />&nbsp; STA $020C<br /><br />&nbsp; LDA player+1<br />&nbsp; CLC<br />&nbsp; ADC #$0F&nbsp; ; A = A - 1<br />&nbsp; STA $0210<br /><br />&nbsp; LDA player+1<br />&nbsp; CLC<br />&nbsp; ADC #$0F&nbsp; ;&nbsp; &nbsp; &nbsp;; A = A - 1<br />&nbsp; STA $0214<br /><br />Direction:<br />&nbsp; LDA pdirection<br />&nbsp; CMP #$01<br />&nbsp; BCS Right<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA pdirection+1<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA pdirection+3<br />&nbsp; <br />&nbsp; LDA #$08<br />&nbsp; STA pdirection+2<br />&nbsp; <br />&nbsp; BCC DDIR<br />&nbsp; <br />Right:<br /><br />&nbsp; LDA #$08<br />&nbsp; STA pdirection+1<br />&nbsp; <br />&nbsp; LDA #$40<br />&nbsp; STA pdirection+3<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA pdirection+2<br />&nbsp; <br />DDIR:<br />&nbsp; <br />&nbsp; LDA pdirection+3<br />&nbsp; STA $0202<br />&nbsp; STA $0206<br />&nbsp; STA $020A<br />&nbsp; STA $020E<br />&nbsp; STA $0212<br />&nbsp; STA $0216<br />&nbsp; <br />&nbsp; LDA player<br />&nbsp; CLC<br />&nbsp; ADC #$04<br />&nbsp; STA $0203<br />&nbsp; <br />&nbsp; <br /><br />&nbsp; LDA player<br />&nbsp; CLC<br />&nbsp; ADC pdirection+1 ; A = A - 1<br />&nbsp; STA $020B<br /><br />&nbsp;LDA player<br />&nbsp; CLC<br />&nbsp; ADC pdirection+2&nbsp; ;&nbsp; &nbsp; &nbsp;; A = A - 1<br />&nbsp; STA $020F<br /><br />&nbsp; LDA player<br />&nbsp; CLC<br />&nbsp; ADC pdirection+1&nbsp; ; A = A - 1<br />&nbsp; STA $0213<br /><br />&nbsp; LDA player<br />&nbsp; CLC<br />&nbsp; ADC pdirection+2&nbsp; ;&nbsp; &nbsp; &nbsp;; A = A - 1<br />&nbsp; STA $0217<br />&nbsp; <br />Gravity:<br /><br />&nbsp;<br /><br />&nbsp; <br />&nbsp; LDA #GROUND<br />&nbsp; CLC<br />&nbsp; ADC #$01 <br />&nbsp; STA feet<br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; CLC<br />&nbsp; ADC #$08<br />&nbsp; STA grounded<br />&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; &nbsp;<br />&nbsp; <br />&nbsp; LDA grounded<br />&nbsp; CMP #GROUND<br />&nbsp; BEQ Fl<br />&nbsp; <br />&nbsp; JMP NP1<br />&nbsp; <br />AnimationP3:<br />&nbsp; JMP AnimationP1<br />&nbsp; <br />Fl:<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BCC AnimationP3<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BEQ Jump<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BEQ Jump<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$02<br />&nbsp; BEQ Delay<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$03<br />&nbsp; BEQ FP1<br />&nbsp; <br />NP1:<br />&nbsp; <br />&nbsp; LDA JumpState+2<br />&nbsp; CMP #$01<br />&nbsp; BEQ Fl<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; JMP Fl<br />&nbsp; <br /><br />Jump:<br /><br />&nbsp; <br /><br /><br />&nbsp; LDA #$01<br />&nbsp; STA JumpState+2<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; CMP #$80<br />&nbsp; BEQ Pa2<br />&nbsp; <br />&nbsp; JMP Can<br />&nbsp; <br />Pa2:<br />&nbsp; <br />&nbsp; LDA scroll+1<br />&nbsp; CMP #$FF<br />&nbsp; BEQ Can<br />&nbsp; <br />&nbsp; LDA scroll+1<br />&nbsp; CMP #$00<br />&nbsp; BEQ Can<br />&nbsp; <br />&nbsp; LDA scrolly<br />&nbsp; SEC<br />&nbsp; SBC jheight<br />&nbsp; STA scrolly<br />&nbsp; <br />Can:<br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; SEC<br />&nbsp; SBC jheight<br />&nbsp; STA player+1<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CMP #$18<br />&nbsp; BCC AnimationP1<br />&nbsp; <br />&nbsp; LDA #$02<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; JMP AnimationP1<br />&nbsp; <br />FDP1:<br />&nbsp; JMP FallDone<br /><br />AnimationP1:<br />&nbsp; <br />&nbsp; JMP Animation<br /><br />&nbsp; FP1:<br />&nbsp; JMP Fall<br />&nbsp; <br /><br /><br />&nbsp; <br />Delay:<br /><br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; SEC<br />&nbsp; SBC jheight<br />&nbsp; STA player+1<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CMP #$1E<br />&nbsp; BCS P2<br />&nbsp; <br />&nbsp; LDA Timer1+3<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; JMP AnimationP1<br />&nbsp; <br />P2:<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CMP #$25<br />&nbsp; BCS P3<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; <br />&nbsp; JMP AnimationP1<br />&nbsp; <br />AnimationP2:<br />&nbsp; BCC AnimationP1<br />&nbsp; <br />P3:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CMP #$2A<br />&nbsp; BCS P4<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; JMP AnimationP1<br />&nbsp; <br />P4:<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; <br />&nbsp; JMP AnimationP1<br />&nbsp; <br /><br />&nbsp; <br />Fall:<br />&nbsp; <br />&nbsp; LDA grounded<br />&nbsp; CMP feet<br />&nbsp; BCS FDP1<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA jheight<br />&nbsp; <br />&nbsp; LDA #$01<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA player+1<br />&nbsp; CLC<br />&nbsp; ADC gravity<br />&nbsp; STA player+1<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CMP #$15<br />&nbsp; BCS MV<br />&nbsp; <br />&nbsp; LDA JumpState+1<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; BCC AnimationP2<br />&nbsp; <br />MV:<br />&nbsp; <br />&nbsp; LDA #$02<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; JMP AnimationP2<br />&nbsp;<br />&nbsp;<br /><br />&nbsp;<br /><br />&nbsp; <br /><br />&nbsp; <br />FallDone:<br /><br />&nbsp; LDA #$01<br />&nbsp; STA JumpState+2<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA gravity<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA JumpState+1<br />&nbsp; <br />&nbsp; BCC AnimationP2<br />&nbsp; <br />&nbsp; <br />FireJump:<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />Animation:<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$01<br />&nbsp; BEQ JAniP<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$02<br />&nbsp; BEQ DAniP<br />&nbsp; <br />&nbsp; LDA JumpState<br />&nbsp; CMP #$03<br />&nbsp; BEQ FAniP<br />&nbsp; <br />&nbsp; LDA T<br />&nbsp; CMP #$01<br />&nbsp; BCC&nbsp; Rss<br />&nbsp; <br />&nbsp; LDA Timer1<br />&nbsp; CMP #$0F<br />&nbsp; BCS&nbsp; ResP2<br />&nbsp; <br />&nbsp; LDA Timer1<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA Timer1<br />&nbsp;<br />&nbsp; BCC SAni<br />&nbsp;<br />&nbsp;<br />ResP1:<br />&nbsp;BCC Res<br />&nbsp;<br />ResP2:<br />&nbsp;BCS Res<br />&nbsp;<br />&nbsp;<br />Rss:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Ant<br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; LDA #$06<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$02<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; BCC DoneP1<br />&nbsp; <br />&nbsp; <br />Res:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; LDA Ant<br />&nbsp; CLC<br />&nbsp; ADC #$01<br />&nbsp; STA Ant<br />&nbsp; BCC DoneP1<br />&nbsp; <br />Rse:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Ant<br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; BCC DoneP1<br />&nbsp; <br />JAniP:<br />&nbsp; <br />&nbsp; JMP JAni<br />&nbsp; RTS<br />&nbsp; <br />&nbsp; <br />FAniP:<br />&nbsp; <br />&nbsp; JMP FAni<br />&nbsp; RTS<br />&nbsp; <br />DAniP:<br />&nbsp; <br />&nbsp; JMP DAni<br /><br /><br />&nbsp; RTS<br /><br />SAni:<br /><br />&nbsp;LDA JumpState<br />&nbsp;CMP #$01<br />&nbsp;BEQ JAni <br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp;<br />FrameA1:<br />&nbsp; LDA Ant<br />&nbsp; CMP #$01<br />&nbsp; BEQ FA2<br />&nbsp; LDA #$0C<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$04<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$10<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; BCC DoneP1<br />&nbsp; <br /><br />&nbsp; <br />FA2:<br />&nbsp; <br />&nbsp; LDA Ant<br />&nbsp; CMP #$02<br />&nbsp; BEQ FA3<br />&nbsp; LDA #$0A<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$02<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; BCC DoneP1<br /><br />FA3:<br />&nbsp; <br />&nbsp; LDA Ant<br />&nbsp; CMP #$03<br />&nbsp; BEQ FA4<br />&nbsp; LDA #$0C<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$0E<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$0F<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; <br />&nbsp; BCC DoneP1<br />&nbsp; <br />RsP1:<br />&nbsp; BCC Done<br />&nbsp; <br />&nbsp; DoneP1:<br />&nbsp; BCC Done<br />&nbsp; <br /><br />&nbsp; <br />&nbsp; FA4:<br />&nbsp; <br />&nbsp; LDA Ant<br />&nbsp; CMP #$04<br />&nbsp; BEQ Rse<br />&nbsp; LDA #$0A<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$02<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; BCC DoneP1<br />&nbsp; <br />&nbsp; LDA Ant<br />&nbsp; CMP #$03<br />&nbsp; BCS&nbsp; RsP1<br />&nbsp; <br /><br /><br /><br /><br />JAni:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Ant<br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; LDA #$08<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$04<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; JMP Done<br />&nbsp; <br />DAni:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Ant<br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; LDA #$25<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$23<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; JMP Done<br />&nbsp; <br />FAni:<br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Ant<br />&nbsp; LDA #$00<br />&nbsp; STA Timer1<br />&nbsp; <br />&nbsp; LDA #$0C<br />&nbsp; STA Srt<br />&nbsp; <br />&nbsp; LDA #$24<br />&nbsp; STA Srt+1<br />&nbsp; <br />&nbsp; LDA #$03<br />&nbsp; STA Srt+2<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; JMP Done<br /><br />Done:<br /><br />&nbsp; <br /><br />ReadController1:<br />&nbsp; LDA #$01<br />&nbsp; STA $4016<br />&nbsp; LDA #$00<br />&nbsp; STA $4016<br />&nbsp; LDX #$08<br />ReadController1Loop:<br />&nbsp; LDA $4016<br />&nbsp; LSR A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; bit0 -&gt; Carry<br />&nbsp; ROL buttons&nbsp; &nbsp; &nbsp;; bit0 &lt;- Carry<br />&nbsp; DEX<br />&nbsp; BNE ReadController1Loop<br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br />ReadController2:<br />&nbsp; LDA #$01<br />&nbsp; STA $4016<br />&nbsp; LDA #$00<br />&nbsp; STA $4016<br />&nbsp; LDX #$08<br />ReadController2Loop:<br />&nbsp; LDA $4017<br />&nbsp; LSR buttonslay&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; bit0 -&gt; Carry<br />&nbsp; ROL buttons&nbsp; &nbsp; &nbsp;; bit0 &lt;- Carry<br />&nbsp; DEX<br />&nbsp; BNE ReadController2Loop<br />&nbsp; <br />&nbsp; RTS<br />&nbsp; <br /><br />&nbsp; <br /><br /><br /><br />&nbsp; <br />&nbsp; RTS<br /><br />LoadPalettes2:<br /><br /><br />&nbsp; LDA #%00000000&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA $2002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read PPU status to reset the high/low latch<br />&nbsp; <br />&nbsp; <br />&nbsp; LDA #$00<br />&nbsp; STA Timer1+5<br />&nbsp; STA Timer1+6<br />&nbsp; <br />&nbsp; LDX #$00<br />&nbsp; <br />LP2:<br />&nbsp; <br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; LDA #$3F<br />&nbsp; STA $2006<br />&nbsp; LDA Timer1+6<br />&nbsp; STA $2006<br />&nbsp; <br />&nbsp; LDA paletteswap , x<br />&nbsp; STA $2007<br />&nbsp; &nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; INX<br />&nbsp; <br />&nbsp; INC Timer1+5<br />&nbsp; <br />&nbsp; INC Timer1+6<br />&nbsp; <br />&nbsp; LDA Timer1+5<br />&nbsp; CMP #$20<br />&nbsp; BEQ Fin<br />&nbsp; <br />&nbsp; <br />&nbsp; JMP LP2<br />&nbsp; <br />Fin:<br /><br /><br />&nbsp; LDA #%00000100&nbsp; &nbsp; &nbsp; &nbsp; ; set to increment +32 mode<br />&nbsp; STA $2000<br />&nbsp; <br />&nbsp; RTS<br />&nbsp;<br />&nbsp; &nbsp; <br /><br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br /><br /><br />&nbsp; <br />&nbsp; <br />&nbsp;<br />;;;;;;;;;;;;;;&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; .bank 1<br />&nbsp; .org $E000<br />palette:<br />&nbsp; .db $02,$11,$01,$0F,$02, $04,$36,$37,$02,$39,$3A,$3B,$02,$16,$05,$0f<br />&nbsp; .db $02,$16,$20,$38,$01,$0F,$07,$37,$02,$1C,$15,$14,$02,$0F,$07,$37<br />&nbsp; <br />palette3:<br />&nbsp; .db $02,$11,$01,$0F,$02, $04,$36,$37,$02,$39,$3A,$3B,$02,$16,$05,$0f<br />&nbsp; .db $02,$16,$20,$38,$01,$0F,$07,$37,$02,$1C,$15,$14,$02,$0F,$07,$37<br />&nbsp; <br />Playersprites:<br />&nbsp; &nbsp;; Player<br />&nbsp; &nbsp;;vert tile attr horiz<br />&nbsp; .db $80, $00, $1C, $80&nbsp; &nbsp;;sprite 0<br />&nbsp; .db $88, $02, $1C, $80&nbsp; &nbsp;;sprite 2<br />&nbsp; .db $88, $03, $00, $88&nbsp; &nbsp;;sprite 3<br />&nbsp; .db $88, $03, $00, $88&nbsp; &nbsp;;sprite 3<br />&nbsp; .db $88, $03, $00, $88&nbsp; &nbsp;;sprite 3<br />&nbsp; .db $8F, $04, $00, $80&nbsp; &nbsp;;sprite 3<br />&nbsp; <br />&nbsp; <br />;Bullets<br />Bullets:<br />&nbsp; .db $8F, $1F, $04, $88&nbsp; <br />&nbsp; .db $8F, $1F, $04, $88&nbsp; <br />&nbsp; .db $8F, $1F, $04, $88&nbsp; <br />&nbsp; .db $8F, $FF, $04, $88&nbsp; <br />&nbsp; <br /><br />Esprites:<br />&nbsp; .db $10, $2F, $04, $88&nbsp; <br />&nbsp; .db $FF, $2F, $04, $FF&nbsp; <br />&nbsp; .db $8F, $1F, $04, $88&nbsp; <br />&nbsp; .db $8F, $FF, $04, $88&nbsp; <br />&nbsp; <br />&nbsp; ;sprite 3<br />&nbsp; <br />columnData:<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; .incbin &quot;KitsuneTaleslevel.bin&quot;<br />&nbsp; <br />&nbsp; <br />&nbsp; <br />columnDatay:<br />&nbsp; .incbin &quot;KitsuneTaleslevel2.bin&quot;<br /><br />attribData:<br />&nbsp; .incbin &quot;KitsuneTalesattrib.bin&quot;<br />&nbsp; <br />attribDatay:<br />&nbsp; .incbin &quot;KitsuneTalesattrib2.bin&quot;<br />&nbsp; <br />&nbsp; <br /><br />&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; .org $FFFA&nbsp; &nbsp; &nbsp;;first of the three vectors starts here<br />&nbsp; .dw NMI&nbsp; &nbsp; &nbsp; &nbsp; ;when an NMI happens (once per frame if enabled) the <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;processor will jump to the label NMI:<br />&nbsp; .dw RESET&nbsp; &nbsp; &nbsp; ;when the processor first turns on or is reset, it will jump<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;to the label RESET:<br />&nbsp; .dw 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;external interrupt IRQ is not used in this tutorial<br />&nbsp; <br />&nbsp; <br />;;;;;;;;;;;;;;&nbsp; <br />&nbsp; <br />&nbsp; <br />&nbsp; .bank 2<br />&nbsp; .org $0000<br />&nbsp; .incbin &quot;KitsuneTalesShiroAkai.chr&quot;<br />&nbsp; ;;;;;;;;;;;;;;;;;;;;<br />&nbsp; .bank 3<br />&nbsp; .org $A000<br />&nbsp; .incbin &quot;Kitsunetales.chr&quot;<br />&nbsp; <br />&nbsp;;;;;;;;;;;;;;;;;;;;<br />&nbsp;<br />&nbsp; .bank 4<br />&nbsp; .org $E000<br />&nbsp; </div><br />What this is doing so far is that you ave a character running around with 5 8x8 sprites attached to it.<br />You can jump, the pallete stack $3F11 should change constantly, The nametables $20 and $28 should be both filled with a screen worth of info if a full level is loaded ala SMB3, Finally, paletteswap is the palette swapping variable.<br />GAME : Kitsune Tales

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Fri Jul 21, 2017 2:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I see you moved out some of the logic from the beginning of the NMI, not everything though, the INC Scroll and the NTSwapCheck stuff are also logic and should be moved down after graphic updates. But now you have much more vblank time, do you still have the same problem?<br /><br />I saw some other weird things. You clear RAM (at &quot;clrmem&quot;) except page 3 that you fill with $FE:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; ;...<br />&nbsp; LDA #$FE<br />&nbsp; STA $0300, x<br />&nbsp; ;...<br /></div><br />You probably meant to fill page 2 with $FE to avoid stray sprites at boot since you are using that page as your OAM buffer for OAM-DMA.<br /><br />And you only read bit 0 of $4016/$4017 in your controller reading routine so expansion port controllers doesn't work. You should read bit 1 as well unless it's a 4-player game.<br /><br />Also I see you are doing the All-in-NMI approach. That's fine (Super Mario Bros is doing it that way) but it has its limits, and having logic in the main loop (the loop at &quot;Forever&quot; in your code) makes things more clear I think.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Fri Jul 21, 2017 3:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />1. Yes, But listening to you des make a difference and that's nice. Wait I moved more logic around and It made a difference.<br />2. I Don't want the All nmi approach. I want some of the rendering to go Outside Like text, boss AI and other stuff. I heard that It boggles down speed if your not careful.<br />3. It's a one player game. However, If I get to demaking smash bros., I'll need that info<br />4. I found an article on stacks pha and pla. I just need to figure out where my buffer's going to go.<br />5. that was on the nerdy nights tutorial.<br />6. The scroll is only affected when it loads a section of the attibutes and the back ground.<br />7. I feel like I went too far off talking about stacks and what not. Should I continue?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>dougeff</b> [ Fri Jul 21, 2017 5:11 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If you are still having glitches, you're doing too much at once. One quick fix, would be to do the attribute table writes a frame early. It would look something like this...<br /><br />NewAttribCheck:<br />  LDA scroll<br />  CLC  ;!<br />  ADC #1. ;!<br />  AND #%00011111            ; check for multiple of 32<br />  BNE NewAttribCheckDone    ; if low 5 bits = 0, time to write new attribute bytes<br />  jsr DrawNewAttributes<br /><br />It may need more than just this, to make sure you write to the correct Nametable.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Sat Jul 22, 2017 4:45 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">IMAGICA wrote:</div><div class="quotecontent">2. I Don't want the All nmi approach. I want some of the rendering to go Outside Like text, boss AI and other stuff. I heard that It boggles down speed if your not careful.</div><br />Then just move out all your logic from the NMI and put it in your forever loop. Only keep the graphic updates (OAM, VRAM, $2000, $2001 and $2005 writes) in the NMI.<br /><br /><div class="quotetitle">IMAGICA wrote:</div><div class="quotecontent">3. It's a one player game. However, If I get to demaking smash bros., I'll need that info</div><br />You misunderstand me. If it's a one player game, you need to read both bit 0 and bit 1 of $4016 to your controller 1 data so that people can use both standard controllers and Famicom expansion port controllers. Nerdy Nights doesn't teach this but it's good practice to do it. Else people might not be able to use their arcade sticks and other controllers with your game.<br /><br /><div class="quotetitle">IMAGICA wrote:</div><div class="quotecontent">4. I found an article on stacks pha and pla. I just need to figure out where my buffer's going to go.</div><br />Your buffers goes into RAM wherever there is space. You are already buffering OAM and scroll in RAM. I like to keep my OAM buffer on RAM page 2 ($0200~$02FF), BG and palette buffers in page 3, and scroll and $2000/$2001 buffers in the zero page. The BG buffer can't be too big (there's not enough vblank time to draw the whole nametable), so you could also keep BG and palette buffers at the beginning of page 1. The stack starts in the other end of page 1 so unless you use a lot of stack there's no risk they will collide.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>IMAGICA</b> [ Mon Jul 24, 2017 8:30 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />dougeff : Sorry, writing that slows dow the game. I need to learn buffering first<br />Pokun: What's bit one and how do you get it?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Mon Jul 24, 2017 9:34 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Pallete affects scroll value</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Bits in a binary number are traditionally numbered by their place value from right to left.<br /><br /><ul><li>%00000001: Ones place, 1 = 2^0, bit 0</li><li>%00000010: Twos place, 2 = 2^1, bit 1</li><li>%00000100: Fours place, 4 = 2^2, bit 2</li><li>%00001000: Eights place, 8 = 2^3, bit 3</li><li>%00010000: Sixteens place, 16 = 2^4, bit 4</li><li>%00100000: Thirty-twos place, 32 = 2^5, bit 5</li><li>%01000000: Sixty-fours place, 64 = 2^6, bit 6</li><li>%10000000: One-hundred-twenty-eights place, 128 = 2^7, bit 7</li></ul>

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>7</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>