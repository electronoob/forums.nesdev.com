<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - How hard is it to write an emulator ?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">How hard is it to write an emulator ?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10785">http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10785</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>2</strong> of <strong>4</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sat Dec 14, 2013 12:06 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If people didn't insist on doing the resampling themselves, sound would be significantly easier. I don't get the insistence on doing it themselves. It's an artifact of how PCs do sound. Why not insist on doing the whole hardware sound driver yourself? Same for graphics, why be content just handing the OS a nice pixel map and letting it figure out how to get it on screen? There's plenty to sound emulation when you are content with outputting the waveform at the system's MHz clock rate.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Dec 14, 2013 12:16 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">If people didn't insist on doing the resampling themselves, sound would be significantly easier. I don't get the insistence on doing it themselves. It's an artifact of how PCs do sound.</div><br />Emulator authors feel they have to do their own resampling because (either now or in the past) PC audio output APIs and PC video recording APIs haven't done so well with a 1.8 MHz sample rate.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Sat Dec 14, 2013 12:25 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />@Bregalad: No problem, I don't think you're stupid in the least.  Sometimes people just like to write/code things for fun; personal challenges, things like that -- I'm always supportive of such things.  I'm just &quot;sensitive&quot; over the number of NES emulators that are getting made, because I feel if all that energy was directed in a more organised/effective manner, we'd probably have perfect NES emulators for every OS/platform by now.<br /><br />As for me complaining less, stop saying things in the world suck, and diminish my amount of swearing: acknowledged.  :shock:

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Sat Dec 14, 2013 12:40 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">@ArsonIzer : Your viewpoint is very ineresting. You wanted to do an emulator without knowing anything about a CPU, that's a great achievement I'd have to say.</div><br /><br />I see that as a compliment, thanks <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> It was quite a hell to be honest. I did start out by reading books/web pages about the inner workings of processors while I was going to college and back home (2 x 1.5 hours of travel time a day, most of it spent in buses/trains). I sometimes blatantly ignored people I travel with because I was immersed in the information so much. This is also why I disagree with koitsu's notion of &quot;don't start writing an emu&quot;. I've wanted to write one for years, whether it's for the experience or just to see how I can build something from scratch. It's just so satisfying for me to have built up all this experience from nothing, and even though I suck at it, I believe that the &quot;HURRAH I MADE SOMETHING COOL AND IT WORKS!!!!!!&quot; - experience alone is already a reason to start writing your own emulator (if you're into that).<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">So this means if you emulate a perfectly documented system, it'll be extremely easy to emulate it ??</div><br /><br />I highly doubt this. Despite the NES probably being (one of) the most well-documented console in existence (correct me if I'm wrong), people are still questioning things left and right because it's sometimes hard to understand stuff that seems very simple. Hardware is supposed to be complex, and no amount of documentation is able to make up for people's intellectual/learning limitations. Sure, having the knowledge will make it easier, but no one will read through a super-well-written PS1 document and say &quot;oh, this is going to be a piece of cake!&quot;, at least I don't think anyone has ever done so.<br /><br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Are they just huge char arrays in your code ? Or is there something I'm missing ?</div><br /><br />In their most basic forms, they're often an array of some sort of primitive type, yes.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">How do you simulate a processor read that goes decoded to different peripherals ?</div><br /><br />You'll have read/write methods in each component which will basically look at which address is written to, and what's supposed to be done with the data. Basically in overly simplistic and crappy pseudocode:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">class CPU {<br /><br />unsigned byte ram&#91;0x800&#93;; //The 2KB CPU memory<br /><br />void write(int addr, int val) { <br />if(addr &gt;= 0 &amp;&amp; addr &lt;= 0x1FFF) {<br />ram&#91;addr &amp; 0x7FF&#93; = val; //Write to RAM while keeping mirroring in mind<br />} else if(addr &gt;= 0x2000 &amp;&amp; addr &lt;= 0x3FFF) {<br />ppu.write_to_register(addr &amp; 7, val); //Write to correct register no.<br />} else {<br />mapper.write_to_cart(val); //I know, no controller, apu, dma, or w/e, but this is just an example!!!!<br />}<br />}<br /><br />unsigned byte read(int addr) { <br />//Blablabla<br />}<br /></div><br /><br />The ppu, apu and mapper also have read and write methods which do similar stuff to this. I know it looks crappy and weird, but there's only a limited amount of what I can explain in such a way.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Is the screen emulated pixel by pixel or do you use openGL or some kind of hardware acceleration ?</div><br /><br />Whatever method/library of rendering on the actual PC screen is used depends entirely on the emulator author, although I guess a lot of people use OpenGL, SDL or something similar.<br /><br />In case of finding out which pixel you need to render on a particular X and Y position, that massively depends on the system.  In the NES PPU's case, you'll just want to fetch the necessary pixel color by doing all the NT/AT/BMP fetches, put it in a buffer, and whenever a frame is finished, you push the buffer to the actual screen (this is where you'll need some kind of OpenGL or SDL library, so that the user can see the actual frame) and let it render all the pixels. At least, that's what I do. Here's what I mean:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">class PPU { <br /><br />int cycle_no;<br /><br />void tick() { //perform one PPU cycle<br />do_some_fetches();<br />find_out_which_pixel_needs_to_be_drawn();<br />render_pixel(pixel_no); //Calculate pixel color and put it in a buffer<br /><br />if(cycle_no == frame_end_cycle_no) push_buffer_to_screen(); <br /><br />}<br />}<br /></div><br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">How is the synchronisation between the various parts (CPU, GPU, APU) done ?</div><br /><br />Simply by letting the CPU cycle once, and then the PPU three times, and then the APU X times (have no experience with the APU, sorry). Something along these lines: <br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">class CPU { <br /><br />void execInstr() { <br />opcode = cpu_mem.read(program_counter); //reading from memory takes 1 CPU cycle<br />cycle_ppu(3); //ppu ticks 3 times for every 1 cpu cycle<br />cycle_apu(x); //apu ticks x times for every 1 cpu cycle<br /><br />switch(opcode) { <br />case 0x69: //hehehe<br />adc(addr_mode_immediate());<br />break;<br />}<br /><br />}<br /><br />void adc(int addr) { //add with carry<br />int data_to_add = cpu_memory.read(addr); //Takes 1 cpu cycle<br />cycle_ppu(3);<br />cycle_apu(x);<br />A+= data_to_add; //Do the add<br />check_flags(A); //Check for carry, sign, zero and overflow<br />}<br /><br />}<br /></div><br /><br />Of course the above is stupid, inefficient, simplistic, and also cycle-accurate.<br /><br />I really can't offer more than that. I could write an article about it, but then again, there's the entire nesdev site, so that would be pointless. I don't think I could explain any better in the fraction of a time it took me to write this, compared to the months I've spent studying it from documents.<br /><br />PS: I know you were talking about systems in general, but this is the basic premise of all systems, except that the NES is one of the simplest examples I could give. All emulation-worthy systems have at least a core, some graphics and some sound, and the NES is a great example.<br /><br />PPS: Wow, this is some TL;DR. Even I don't want to re-read this to spell-check etc ._.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>MottZilla</b> [ Sat Dec 14, 2013 12:43 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Also, although all those answers are interesting, none of them really answers what I wanted to know. I'm sorry for being so annoying. I was more asking myself how is components like RAM, ROM and graphics are emulated.<br />Are they just huge char arrays in your code ? Or is there something I'm missing ?<br />How do you simulate a processor read that goes decoded to different peripherals ?<br />Is the screen emulated pixel by pixel or do you use openGL or some kind of hardware acceleration ?<br />How is the synchronisation between the various parts (CPU, GPU, APU) done ?<br />That's more of the stuff I was interested in knowing.<br /><br />Again I am not talking about the NES, but about systems in general (including systems which have nothing in common with a gaming console). Sorry for not being clear about it.</div><br /><br />Writing an emulator and how hard it is definitely depends on who is writing it and their available resources. Your past experience and skills can make it really hard or much easier. My first NES emulator was fairly tough getting started. But that was because the concept of emulation was pretty new to me. I had the previous programming skills from making platform and other games on PC so I had no challenges from that. I didn't need to learn how to handle input or draw graphics or play sounds. No problems loading files, etc. I wrote additional NES emulators, atleast 2 more, and started a Gameboy emulator. All of them progressed much faster since I was more familiar with the concept.<br /><br />RAM and ROM are are storage so you can just declare a big array or have a pointer and malloc() the needed memory for it. For a system like the NES, when the bus is accessed by the CPU you'll probably have a function which decodes the address to know how to get the correct memory. For the NES it's a good idea to have a fairly flexible memory mapping system for the address range $6000-$FFFF. So to be clear you might have a function that takes an address and then that function figures out which device (RAM, ROM, Registers) needs to respond. The function will eventually return from one of the loaded memory arrays or registers. <br /><br />Graphics emulation I'm unclear what is confusing there. It's the same sort of puzzle where you are trying to get the end result that behaves right. With NES emulation you can emulate the PPU in different ways that are less accurate than the cycle by cycle / step-by-step exact way. We have very detailed PPU operation information now. On another system as you are interested, you may not have as detailed information. So you just go based on what you know about the system. <br /><br />Your emulator depending on the system, like NES or SNES, probably would have a screen buffer that is just 256x240 (or so) pixels that gets written as the screen is rendered by your PPU functions. Once the whole frame is drawn you would actually put that on the screen for the user. There would be no hardware acceleration. On GBA there may be as you can use the GBA's hardware to simulate the NES or SNES graphics hardware as they have similar functions.<br /><br />Sync between components is again up to how you program it. Since in a real machine many components run in parallel you need to make sure that if any two components interact that they are emulated so they behave as though they have been running in parallel. On the NES you could emulate 1 CPU cycle and then 3 PPU cycles. This would keep things fairly in sync. However you can get away with alot less for different games. So other platforms emulated may also have games that can behave with alot less accuracy. <br /><br />Hopefully all this helps to describe some of the answers you were looking for.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sat Dec 14, 2013 1:37 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Oh I see, in fact emulating memory (whether it's ROM and RAM) sounds totally easy, and for memory mapped I/O you just need to provide a fair trade of read/write functions right ?<br />I'd never throught it'd be that simple.<br /><br />As for calling a clock() function for the CPU and PPU it sounds like it'd do accurate emulation, but extremely slow right ? Also the 3 - 1 ratio only works for NTSC NES. On other systems, there is multiple unrelated oscillators for the SPC and CPU and there is not a clear clock ratio between them.<br /><br />I'd think this would be a very good candidate for parallel execution of a program - one thread simulates the CPU while another thread simulates the GPU, and yet another thread simulates the APU. The problem is that this would only lead to inaccurate emulation - whenever one of those uses I/O you'd have to resynchronize with the other threads somehow and you could potentially loose as much efficiency as you gained from the split if you're not careful. I wonder if any emulators does this. I also know that many of the emulators were developed before the main steam desktop CPUs became parallel, so I'd understand if nobody used this idea.<br /><br />In the end, the optimal solution would be : Run CPU, GPU and APU in parallel until one of those requires I/O. When this happens you freeze and transmit the # of cycles you emulated, and at this point switch to &quot;slow but accurate&quot; emulation of interleaved CPU/GPU/APU cycles.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If people didn't insist on doing the resampling themselves, sound would be significantly easier.</div><br />I guess this is about PSG-style audio where the &quot;sampling frequency&quot; is in the hundreds of kiloherz / megaherz range right ? Can the system resample easily from such high freqs to lower freqs ?<br />At least you helped me a lot for my resampler in BRR tools, thank you very much.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sat Dec 14, 2013 1:44 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">As for calling a clock() function for the CPU and PPU it sounds like it'd do accurate emulation, but extremely slow right ?</div><br />Computers are extremely fast. It's always been relative, anyway; computers have had a given amount of power and as a programmer you don't shy from using it where it will simplify code. Trying to optimize these things without preparation leads to fast-but-incorrect code that's difficult to fix.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Dec 14, 2013 1:46 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Bregalad: Threading won't lose efficiency if the activity shunted off to another thread is one that doesn't need much of a resync, such as audio resampling, palette lookup, color math, or TV artifact emulation. Even tile decoding could be done in another thread so long as the platform lacks hardware collision detection (like NES sprite 0). Timestamping writes rather than mutating state becomes key when getting threads to synchronize efficiently.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sat Dec 14, 2013 2:44 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; The next part of the problem is there's too many goddamn UI toolkits.<br /><br />I solved that <!-- m --><a class="postlink" href="http://xkcd.com/927/">http://xkcd.com/927/</a><!-- m --> style. I wrote a toolkit that wraps other toolkits. So now one nice, clean API can generate native Win32, GTK+, Qt and Cocoa applications. And targeting a new API in the future would only take a week or so. It does force you to target the least common denominator, though. A feature not available on one or more platforms means a feature that can't be available to the wrapper API, so you get a really barebones UI. Still, more than enough to design a decent UI. Real downside is I've spent 70% of the past two years writing the UI wrapper now :P<br /><br />&gt; If people didn't insist on doing the resampling themselves, sound would be significantly easier. I don't get the insistence on doing it themselves.<br /><br />The reason I enjoy programming is to learn how to do things.<br /><br />In my mind, a programmer is a creator who learns how things work and creates tailored, lean, efficient implementations, where the journey is the reward. A coder is someone who glues libraries together, and is only focused on the end result.<br /><br />This spectrum is of course infinitely wide. You can go to the extreme of a guy wrapping aluminum foil around a glass jar full of saltwater to make his own capacitors -- to ultimately build an entire hardware replica; all the way to a guy forking a pre-made emulator frontend, and simply paying for-hire coders to make little tweaks he requests.<br /><br />In the realm of non-absurdity, you get a smaller spectrum. People like me that want to write all of the code, sans the core libc++ functions and real hardware drivers. Others are okay with using libraries for all ancillary stuff like image scaling and audio resampling. Others are okay with gluing pre-made CPU/APU cores together, and adding a bit of video rendering. And finally, you have people taking fully pre-made emulators and creating things like multi-emulators from them.<br /><br />I spent an extra 2-3 days cloning a mini-Deflate algorithm, so that I can decompress ZIP and PNG files in 8-10KB. You could say it's a stupid waste of time since I could have just used the 400kb zlib. But why then isn't it stupid to write your own CPU core when you could just use Musashi 68K or Starscream or MZ80 or m6502? I ended up making a better SNES CPU core than anyone before me. Maybe once I learn audio processing, I might come up with a novel technique that improves upon blip_buffer. Very unlikely, but it is possible.<br /><br />...<br /><br />Audio emulation is a lot more than resampling, too. The non-linear mixing was a real challenge even with Ryphecha's help. I have no idea if I got all of the weird shadow registers correct for the individual channels, and I have zero test ROMs I can run to find out.<br /><br />&gt; I'm just &quot;sensitive&quot; over the number of NES emulators that are getting made, because I feel if all that energy was directed in a more organised/effective manner, we'd probably have perfect NES emulators for every OS/platform by now.<br /><br />The vast majority of emulator authors contribute nothing to advance core emulation (UI experience, sure.)<br /><br />If you're reimplementing documentation, at best you might guess a way to fix a bug in known games, but unless you have your own hardware testing rig and are verifying your behaviors are 100% correct, all you're doing is potentially leading people down the wrong path.<br /><br />Most likely all you're doing is bugging the people who are doing real work when you get stuck (like my GB forum threads.) But on the bright side, that creates absolutely stellar documentation. Compare NES docs to DMG docs. For the NES, you get step-by-step fetches for the PPU. For the DMG, you get pandocs, last updated in 1998. There's less detail in all of pandocs than on loopy_t/v by itself.<br /><br />In an ideal world yeah, we'd all work together. But we too quickly disagree on details, so it's never going to work.<br /><br />I decided to make an NES emulator because I wanted to experiment with the mapper and file format issues. I prefer to split the PRG and CHR ROMs, and then describe the board in an extensible markup. And longer-term, I am working on a micro DSL to implement the actual board emulation from an external file. This file would either be interpreted or converted to bytecode, but never hard-compiled and platform-dependent like DLLs are. The ultimate goal would be allowing to express bootleg mappers without having your emulation core have to support them.<br /><br />I doubt a single emulator author on this forum thinks the above is a good idea. So how would I work with a large group of developers here? Pretty much everything I did with the SNES was extensively derided, yet I've shown that it works really well. And now <em>most</em> SNES emulators are cycle-based, and are starting to do coprocessor LLE. Making ones own emulator is a way to try out their own ideas, unimpeded.<br /><br />There are also, of course, a lot of vanity / just-for-fun projects. Get Mario running, then release it and abandon it. That is just a drain on everyone else. The people who explained stuff to them, the people testing and reporting bugs, the people trying to choose an emulator to run and having one more useless emulator in the list, etc.<br /><br />It's really hard to tell who will end up serious, too. FHorse's first release reeked of a vanity emulator, yet he's topping the list of test ROMs passed now.<br /><br />So, who knows. I agree with your advice in general, but I'd tweak it a bit: please don't write an NES emulator unless you know you are really serious and intend to contribute something significant to the resources you will undoubtedly consume in the process.<br /><br />Of course, nobody's going to listen. They'll do whatever the hell they want, because they can.<br /><br />&gt; Also the 3 - 1 ratio only works for NTSC NES. On other systems, there is multiple unrelated oscillators for the SPC and CPU and there is not a clear clock ratio between them.<br /><br />The best way to synchronize two processors of the same clock ratio is to have an int64_t clock = 0; variable. When one processor adds clocks, increment the value. If it's &gt;= 0, switch to the other processor if you are doing an operation that might effect it. The other processor will decrement by number of clocks executed. If the clock drops below 0, then switch again if doing something that processor might see.<br /><br />When you get different frequencies: processor A adds B.frequency * clocks, and processor B subtracts A.frequency * clocks.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Dec 14, 2013 3:13 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">There are also, of course, a lot of vanity / just-for-fun projects. Get Mario running, then release it and abandon it.</div><br />Would official emulators intended to allow ports of a publisher's own game to a new platform, such as acNES and Virtual Console, fall into this category?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It's really hard to tell who will end up serious, too. FHorse's first release reeked of a vanity emulator, yet he's topping the list of test ROMs passed now.</div><br />That appears to lead to a heuristic: if test ROMs are mentioned, it's less likely vanity.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">please don't write an NES emulator unless you know you are really serious and intend to contribute something significant</div><br />Is making an emulator for a platform that doesn't already have an emulator &quot;something significant&quot;? I can think of a few popular platforms whose application approval policies ban copylefted emulators like higan, Nintendulator, and FCEUX. In order to port an existing emulator, one would have to either pay royalties or find one that's permissively licensed. Would it be &quot;significant&quot; to make an emulator as a platform for experimenting with input methods, such as trying to find a practical way to run a platformer on a touch-screen device?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sat Dec 14, 2013 4:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; Would official emulators intended to allow ports of a publisher's own game to a new platform, such as acNES and Virtual Console, fall into this category?<br /><br />Personally, no. The former is porting your own game, the latter is earning income.<br /><br />But I'm sure everyone has their own opinions on what constitutes vanity. Such that anyone making an NES emulator will be convinced their project is a good idea.<br /><br />&gt; That appears to lead to a heuristic: if test ROMs are mentioned, it's less likely vanity.<br /><br />Maybe. I still have my reservations that passing test ROMs has become its own reward. If you pass all test ROMs but can't play Mario Bros, you probably have your priorities backward.<br /><br />&gt; Is making an emulator for a platform that doesn't already have an emulator &quot;something significant&quot;?<br /><br />Generally, no. Easy to port an existing emulator.<br /><br />To something specific, like an NES emulator on the GBA, sure.<br /><br />Since I control the full license of my software, I can always do an appstore port, or possibly allow someone to release such a binary with an exemption. Pretty sad the way things are going with these app stores, though. Apple won't even allow fast Javascript engines because they flat out disallow self-modifying code and JIT compilation. The mass popularity of computing is slowly ruining it for us geeks.<br /><br />&gt; Would it be &quot;significant&quot; to make an emulator as a platform for experimenting with input methods, such as trying to find a practical way to run a platformer on a touch-screen device?<br /><br />Is counter-significant a term? Touch-only screens are the worst possible thing to happen to games, in my opinion.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Dec 14, 2013 5:07 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">Touch-only screens are the worst possible thing to happen to games, in my opinion.</div><br />Is it even worse than not being able to play games at all when a developer can't find a suitable publisher? With the sales failure of Sony's Xperia Play, the only popular handheld devices that ship with gamepads are PlayStation Vita and Nintendo 3DS, and Sony's PlayStation division and Nintendo have historically had far higher developer entry barriers than even Apple. (<em>Bob's Game</em> anyone?) Touch control in indie games is a workaround for entry barriers like these. The other option is external Bluetooth controllers, but I don't think a lot of smartphone and tablet owners are willing to buy a $39.99 controller just to play a $0.99 game.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Sat Dec 14, 2013 5:28 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">Is counter-significant a term? Touch-only screens are the worst possible thing to happen to games, in my opinion.</div><br /><br />I can agree with that. I used to enjoy playing RPG games on my old J2ME-enabled keypad phone with slightly-better-than-SNES-graphics MUCH more than any HD whatever type iPad game. I can't believe that touchscreen devices are seen as a viable gaming platform these days. I want to port my emu to Android one day, but really, I wish I could have ported it to something like the Nokia N95. Now that was a great smartphone, even though I barely ever got my hands on it <img src="./images/smilies/icon_sad.gif" alt=":(" title="Sad" /><br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">Is it even worse than not being able to play games at all when a developer can't find a suitable publisher? With the failure of Sony's Xperia Play, the only popular handheld devices that ship with gamepads are PlayStation Vita and Nintendo 3DS, and Sony's PlayStation division and Nintendo have historically had far higher developer entry barriers than even Apple. (Bob's Game anyone?) Touch control in indie games is a workaround for entry barriers like these. The other option is external Bluetooth controllers, but I don't think a lot of smartphone and tablet owners are willing to buy a $39.99 controller just to play a $0.99 game.</div><br /><br />You're right, but I don't understand why the world is obsessed with touchscreen-only devices whatsoever though. I find them annoying to use too often. Also, I own a PSP (the old kind, not the Vita), and yeah, when I wanted anything but games on my PSP, I had to get it hacked and void my warranty, just to install an emulator or a VNC client. The thing is, there's no profit for these big console/handheld manufacturers to release an SDK to the public, because there's no profit in anything but quality games, and I guess they just don't want to put the time and money into supporting the small hobby-programmer.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Sat Dec 14, 2013 5:55 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent">You're right, but I don't understand why the world is obsessed with touchscreen-only devices whatsoever though.<br /></div>I think there's one real reason:<br />The worst case of Founder effect I've ever seen, at least on par with the original PC (if not worse).<br />Because of the size of the Play and App store library, all of which assume a touch screen, and maybe a small number of buttons (if android).<br /><br />There are other factors, but they pale in comparison.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Dec 14, 2013 7:00 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent">I don't understand why the world is obsessed with touchscreen-only devices whatsoever though.</div><br />If you're already carrying your phone or music player with you, you can game on that instead of having to carry both a phone and a dedicated gaming device.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>2</strong> of <strong>4</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>