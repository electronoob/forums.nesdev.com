<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=3&amp;t=514" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2005-08-23T14:16:21-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=3&amp;t=514</id>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2005-08-23T14:16:21-07:00</updated>
<published>2005-08-23T14:16:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=4004#p4004</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=4004#p4004"/>
<title type="html"><![CDATA[timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=4004#p4004"><![CDATA[
I started a <a href="http://nesdev.com/bbs/viewtopic.php?p=4002" class="postlink">new thread for reading directly without calling the emulated read function</a>. Both questions are answered there.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Tue Aug 23, 2005 2:16 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Disch]]></name></author>
<updated>2005-08-23T09:51:34-07:00</updated>
<published>2005-08-23T09:51:34-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3996#p3996</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3996#p3996"/>
<title type="html"><![CDATA[timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3996#p3996"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />In my CPU core I even avoid the usual memory access function for opcode reads, instead going directly through the memory mapping table without any function calls.<br /></div><br /><br />How does that work for games like Zelda which move code to cartridge RAM and jump to it?  or does your emu not support that?<br /><br />edit:<br />Or do you mean you do like an if/else range check for opcode reads?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=33">Disch</a> — Tue Aug 23, 2005 9:51 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2005-08-22T22:10:21-07:00</updated>
<published>2005-08-22T22:10:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3990#p3990</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3990#p3990"/>
<title type="html"><![CDATA[timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3990#p3990"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />And hopefully you optimize zero-page and stack accesses to avoid function calls, since those can never cause any side-effects (as far as I know).<br /></div><br />Is the CPU address bus visible on the cart edge during internal RAM accesses?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Aug 22, 2005 10:10 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2005-08-22T20:28:06-07:00</updated>
<published>2005-08-22T20:28:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3989#p3989</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3989#p3989"/>
<title type="html"><![CDATA[timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3989#p3989"><![CDATA[
<div class="quotetitle">Fx3 wrote:</div><div class="quotecontent"><br />Is the PPU/APU clocked before or after an instruction?<br /></div><br /><br />Good question. The APU is likely clocked at the same time as the CPU (well, technically the CPU has a two-phase clock). This brings up the question, if the CPU performs a read on a given clock, does it get data generated by the APU on that clock, or from the previous clock? Answering this probably requires hooking a scope up to the NES bus.<br /><br />Fortunately what really matters is the behavior you get by running code, which can be determined by running test code and observing the results. Thus it becomes irrelevant as to when the units are clocked. What one needs to know (both for programming the NES and writing an emulator) is, if this read occurs at such-and-such time relative to a previous write (or NMI etc.), what value do I get?<br /><br />Regarding instruction timing, can't you just use a "regular" CPU core and pass a timestamp adjustment along with memory reads/writes? So for STA $xxxx, instead of WRITE( addr, a ) you do WRITE( addr, a, 3 ) since the write is on the fourth clock.<br /><br />I doubt that it really matters to be precise with regard to opcode reads, since it's unlikely anything is going to try to execute from I/O space. In my CPU core I even avoid the usual memory access function for opcode reads, instead going directly through the memory mapping table without any function calls. And hopefully you optimize zero-page and stack accesses to avoid function calls, since those can never cause any side-effects (as far as I know).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Mon Aug 22, 2005 8:28 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Quietust]]></name></author>
<updated>2005-08-22T15:48:11-07:00</updated>
<published>2005-08-22T15:48:11-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3986#p3986</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3986#p3986"/>
<title type="html"><![CDATA[Re: timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3986#p3986"><![CDATA[
<div class="quotetitle">Fx3 wrote:</div><div class="quotecontent"><br />I gave a look in other emus and (except for Nintendulator?), they use a cycle table<br /></div><br /><br />That's because Nintendulator already uses the "high precision timing" method you just implemented.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7">Quietust</a> — Mon Aug 22, 2005 3:48 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Zepper]]></name></author>
<updated>2005-08-22T15:39:16-07:00</updated>
<published>2005-08-22T15:39:16-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3985#p3985</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3985#p3985"/>
<title type="html"><![CDATA[timing 2 ^_^;;]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=514&amp;p=3985#p3985"><![CDATA[
Because of APU test issues, I rebuild my CPU core to handle cycles in a lower level - it means:<br /><br />* By taking STA $HHLL, it does 1 clock cycle to read the opcode, 2 cycles to fetch the address HHLL, <strong>instead</strong> of clocking 4 cycles at end of STA. That's an example.<br /><br />It caused the timing to be better for a few games/demos, but very bad for others (mapper #7). Battletoads&amp;Double Dragon does not hang when a PCM sound is played. While it was playing nicely, it stopped on level 5 beginning. &gt;_&lt;. I suspect I would have to rewrite my PPU core too.<br /><br />Detail (NTSC only): for each CPU cycle, the PPU does 3 clock cycles, APU does 1 clock cycle. I gave a look in other emus and (except for Nintendulator?), they use a cycle table. Is the PPU/APU clocked <em>before</em> or <em>after</em> an instruction? Any help?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=39">Zepper</a> — Mon Aug 22, 2005 3:39 pm</p><hr />
]]></content>
</entry>
</feed>