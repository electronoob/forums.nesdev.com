<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - SPC7110 Reverse Engineering Project</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">SPC7110 Reverse Engineering Project</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=12&amp;t=4106">http://forums.nesdev.com/viewtopic.php?f=12&amp;t=4106</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>20</strong> of <strong>21</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Wed Jul 16, 2008 4:26 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">Exactly. I'm not only suggesting it. It is clearly described in IBM's documents.<br />The representation for 1 is 0xaaaaaaaaa... If they use 0x5a instead 0x 0x55 (as an aproximation to 0x55555555...) is because they applied a probability estimation technique over real data based on Markov chain to adjust those values.</div>
<br />Sorry, I really didn't know.
<br />Thanks for taking the time to explain.
<br />;---------------------
<br />
<br />
<br />Well I'm giving up on the data for tonight...
<br />I really am stumped here.  The fifth pixel has all reference pixels as 00.  The second pixel had this same exact reference data, and while an lps occurred in that pixel, the .invert of the context was not changed.  Yet the order of predicted values changes heavily for these pixels.
<br />
<br />Even if we let it update the order when the .invert of the context was not changed, it moves the last obtained pixel value for this context DOWN in probability to be <em>the least likely of all values in the table</em>.  Not only that, at this point in decompression that pixel value is actually the most frequent value of all.
<br />
<br />What is going on?
<br />Not only does it not makes sense at the moment, it seems to be doing the exact opposite of what it should if it wants to do any compression.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Wed Jul 16, 2008 3:07 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'm starting to see the light...
<br />
<br />The reference pixels are clearly related to the selected ordering for the 4 pixel values. I have found some remarkable regularities (indeed, for one of the 10 contexts i think i'm able to predict the content of one of the positions of the ordering), but most refer to only one context and need further study. (I'm very tired now, so i could easily have made errors).
<br />
<br />However, to proof the fact that the reference pixels are essential here, i will comment which is probably the most significative fact i have found:
<br />
<br />for the 6 (3*2) contexts corresponding to the cases where 2 of the reference pixels are equal and the third one is distinct, those two values are ALWAYS selected by the same first symbol. I mean, or they are selected with MPS/MPS and MPS/LPS or they are selected with LPS/MPS and LPS/LPS. I have checked this for all the file.
<br />
<br />As said, i have found some other "second order" regularities but, as they refer to specific contexts and i should check them more exhaustively, i will just stop here today. I'm exhausted.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Thu Jul 17, 2008 3:39 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I took another look at the patent, and it seems i had missed the discussion about the "color rank". It says the rearrangement of the color order is "flexible through the learning of the ocurrence probability of each color". In the embodiment it describe, it's simlply putting the last generated pixel in the top of the rank and shifting the other values 1 unit.
<br />
<br />Of course, that is not what we have here, but maybe that is what is done instead of with the last pixel with the reference pixels (i'm guessing in some cases those values could be put at top of the rank and in others at bottom). Furthermore, i have suddenly make sense of why they aren't using the pixel to the left as reference pixel: by using the second one, they can know two contexts in advance so, while a pixel is being calculated/outputted, the color rank for the next one is probably being generated... Hardware parallelization, that is the explanation for that.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Thu Jul 17, 2008 5:01 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah, I need to go back and read the patent again myself.  I keep meaning to, but it was so boring the first time through and their repeated generic phrases were confusing me about whether I missed something or they were just saying "junk" to make the patent have wider coverage.
<br />
<br />Okay, some more data:
<br />Here's what the input file looks like
<br />00 00 00 00 
<br />7F FF FF FF 
<br />80 00 00 00 
<br />FF FF FF FF 
<br />00 00 00 00 
<br />7F FF FF FF 
<br />80 00 00 00 
<br />FF FF FF FF 
<br />
<br />Here's the output:
<br /><!-- m --><a class="postlink" href="http://neviksti.com/SPC7110/output1_0F0F.dat2">http://neviksti.com/SPC7110/output1_0F0F.dat2</a><!-- m -->
<br />
<br />My first impression is that it looks like the table of "likely pixel values" doesn't rearrange unless an LPS is received when .invert of the context can change.
<br />
<br />I still think the 5th pixel in output1_7030_an1.dat2 is a very very important clue.  The reference pixels are exactly the same as for the second pixel, and while no .invert change occured on that pixel, the pixel order still changed for the 5th pixel.
<br />
<br />So it appears that the "pixel likelyhood order" is shared between contexts.  Further more, it is shared between different "reference pixel" data.  The details of this second "sharing" is making it very difficult to figure out how it evolves.  We need a more appropriate set of test data for this.  I'll try to put something together.
<br />
<br />
<br />Oh, and to try to convince myself beyond a doubt that the "pixel likelyhood order" is not based on the current state, but on the history of all the data, I tried the following:
<br />make a table which stores the "pixel likelyhood order" for each case of (previous pixel data, previous 2nd pixel data, previous 8th pixel data, previous 9th pixel data, .invert for first symbol context and .invert bit the two possible contexts of the second symbol, and which "Bell number" the reference pixel data gave us)
<br />Even with all that, it easily found many (_many_) cases where all those things were the same for a given pixel yet the "pixel likelyhood order" is different.  I am pretty darn convinced now that the history matters.
<br />
<br />EDIT: In case I forgot to mention this earlier, if you are making a test case, because I need to see the transitions of _both_ pixel bits while stepping though the prob values, if the probability for the first symbol ever reaches 1, the program will screw up.  This of course hasn't been a problem yet, and since we don't care about the probability values now anyway, just remember to not have long sequences of repeated pixel values.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Thu Jul 17, 2008 5:41 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">previous pixel data, previous 2nd pixel data, previous 8th pixel data, previous 9th pixel data</div>
<br />
<br />Why haven't you included the 7th pixel? From the point of view of the drawings, it has the same importance than the 9th.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Thu Jul 17, 2008 4:14 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">previous pixel data, previous 2nd pixel data, previous 8th pixel data, previous 9th pixel data</div><br /><br />Why haven't you included the 7th pixel? From the point of view of the drawings, it has the same importance than the 9th.</div>
<br />I tried that now, and same thing.
<br />Actually, I was a bit quick to judge since there were so many "mismatches".  On closer inspection, this works fine for the a!=b!=c!=a case.
<br />
<br />So all four entries in the "pixel likelyhood order" table are predictable for that case.  As you mentioned, two entries in that table are always predictable for the "two reference pixels are the same" case.  The other entries require some kind of history data.
<br />
<br />I keep "seeing" patterns.  Maybe I'm close, but it's probably a sign I'm just too tired to think straight.  I'll give it a bit more today and get some rest.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Thu Jul 17, 2008 4:45 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Okay, I can follow the "pixel likelyhood order" evolution now.  So everything for mode 1 should be done.  I'll write up a test decompressor now.  The idea turns out to be fairly simple (but kind of hard to describe precisely, so it will be best to just read the code).  Due to this simplicity I have a feeling we can just guess mode 2 on the first try after this.
<br />
<br />One thing at a time though.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Thu Jul 17, 2008 4:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />OK. I *believe* i have figured it out. Please take into account i'm even more tired than yesterday, and i haven't had time to test exhaustively this, but it seems to work for all the data i have tried (though, as i say, i haven't driven any automatic validation, and i bet i'm not in the best conditions to do this today...)
<br />
<br />But, if i'm right, it works this way.
<br />
<br />It's storing internally a rank ordering, which start with {00,01,10,11}
<br />
<br />Then, for every pixel (independently of the context), you take the three reference bits (B9,B8 &amp; B2) and do the following:
<br />
<br />- In that rank, take B9 and put it in the first position, shifting the other values if needed.
<br />-Then, take B8 and put it in the first position, shifting the other values if needed.
<br />-Finally, take B2 and put it in the first position, shifting the other values if needed.
<br />
<br />The result is the new rank order you are going to use to output the current pixel. But the point is that the index to use in that table is not given by the MPS-LPS symbols, but for the "output" of the decoders (i mean, the symbols after XORing them with the "invert" thing).
<br />
<br />And, if i haven't missed anything... that's all.
<br />
<br />Random comments: 
<br />1) At this point, seeing how type 0 and type 1 seems to work, i'm guessing that the context manager of the chip hasn't access, indeed, to the individual MPS/LPS symbols, but probably only to the XORing with the "invert" values (as that is to be considered the "output" of the decoder as an independent part of the hardware).
<br />
<br />2) In case you don't see why it's reasonable to use the output of the decoder instead of the MPS-LPS symbols (after all, as the rank is supposed to be ordered in most probable to less probable order, isn't it obvious that the MPS/MPS to LPS/LPS range should be used as index? Well, not.): What they are doing is to use a predictor to take adventage of the structure of the plain data. So, if you are going to compress data with a structure like you are expecting in your prediction model (in our case, 8*8 tiles with 2 bit depth), the prediction model will convert the original probability distribution into a distribution with a "natural" ordering (in our case, after using the prediction model, you expect that the most frequent data is 00, then 01, then 10, etc). So, as you have now data whose frequency is ordered following the natural order, you can use a encoder to code it and, when decoding that same data, the result outputted by the decoder will be ordered in a "natural" way going from higher probabilities to lower ones. That's why it's reasonable to use that output from the decoder as the index to the table. <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" /> Well, i expect not to confuse you more. <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />
<br />
<br />If i have made any errors, i will check it tomorrow. Now i'm unable to think with clarity.
<br />
<br />EDITED: i have seen your new post now. Nice.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Thu Jul 17, 2008 7:07 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">It's storing internally a rank ordering, which start with {00,01,10,11}<br /><br />Then, for every pixel (independently of the context), you take the three reference bits (B9,B8 &amp; B2) and do the following:<br /><br />- In that rank, take B9 and put it in the first position, shifting the other values if needed.<br />-Then, take B8 and put it in the first position, shifting the other values if needed.<br />-Finally, take B2 and put it in the first position, shifting the other values if needed.<br /><br />The result is the new rank order you are going to use to output the current pixel. But the point is that the index to use in that table is not given by the MPS-LPS symbols, but for the "output" of the decoders (i mean, the symbols after XORing them with the "invert" thing).<br /><br />And, if i haven't missed anything... that's all.</div>
<br />I had a more complicated method, and at first thought that you found a way to simplify it all down (gah, I really need sleep too... but we're so close). However I see now that they are distinct (originally my code was organized quite different and made comparison a bit difficult, I like your layout better).  Anyway...
<br />
<br />Consider for example the a!=b!=c!=a reference pixels context.  With your suggestion above, this would completely rearrange the pixel ordering... that doesn't really make sense since that table should be roughly the order of most frequent pixel values.  In fact, since that context is completely fixed by the reference pixels, it should have no effect on the "global" pixel likelyhood order at all.
<br />
<br />What I came up with is this:
<br />
<br />- shift the 2nd previous pixel value to the "most likely" part of the table 
<br />
<br />- now, take a temporary copy of that table:
<br />do the same shifts you mentioned above, but only in this temporary table
<br />
<br />
<br />This makes it so each pixel value only affects the "global" pixel likelyhood order exactly once.
<br />
<br />
<br />Here's some code.  My cludge method for handling pixel values -&gt; bitplane values will definitely need to be made better for mode 2.  I'll try to write something up for that next.
<br /><!-- m --><a class="postlink" href="http://neviksti.com/SPC7110/DecompTest1.c">http://neviksti.com/SPC7110/DecompTest1.c</a><!-- m -->
<br />It passes everything except the underdumps (which are plentiful, so it could probably use more testing).
<br />
<br />EDIT: I'm just going to throw together a test for mode2.  In case it works and I need to share the code, what is the "standard" way to specify 64bit integers in C?  long long doesn't seem to work with the compiler I have here, but __int64 does.
<br />
<br />EDIT(2): Oh screw it.  I'll just use two 32bit integers.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>caitsith2</b> [ Thu Jul 17, 2008 7:46 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I will run the tests on all of the Mode 1 portion of the RAW gfx packs now.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>caitsith2</b> [ Thu Jul 17, 2008 8:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Testing complete Mode 1 decompression is BIT PERFECT on all cases of SPL4 and MDH, on 100% of the overdumped gfx data.
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">// feoez.cpp : Defines the entry point for the console application.<br />//<br /><br />#include &quot;stdafx.h&quot;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />typedef unsigned char uint8;<br /><br />uint8 SeenEvolution&#91;53&#93;&#91;2&#93;=<br />&#123;<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;,<br />&nbsp; &nbsp;&#123;0,0&#125;<br />&#125;;<br /><br />uint8 EvolutionTable&#91;53&#93;&#91;4&#93;=<br />&#123;<br />&nbsp; &nbsp;//prob, nextlps, nextmps, toggle invert<br />&nbsp; &nbsp;&#123;0x5a,&nbsp; 1,&nbsp; 1,1&#125;, //0&nbsp; l,m <br />&nbsp; &nbsp;&#123;0x25,&nbsp; 6,&nbsp; 2,0&#125;, //1&nbsp; l,m <br />&nbsp; &nbsp;&#123;0x11,&nbsp; 8,&nbsp; 3,0&#125;, //2&nbsp; l,m <br />&nbsp; &nbsp;&#123;0x08, 10,&nbsp; 4,0&#125;, //3&nbsp; &nbsp;,m <br />&nbsp; &nbsp;&#123;0x03, 12,&nbsp; 5,0&#125;, //4&nbsp; &nbsp;,m <br />&nbsp; &nbsp;&#123;0x01, 15,&nbsp; 5,0&#125;, //5&nbsp; &nbsp;,m <br /><br />&nbsp; &nbsp;&#123;0x5a,&nbsp; 7,&nbsp; 7,1&#125;, //6&nbsp; l, <br />&nbsp; &nbsp;&#123;0x3f, 19,&nbsp; 8,0&#125;, //7&nbsp; l,m <br />&nbsp; &nbsp;&#123;0x2c, 21,&nbsp; 9,0&#125;, //8&nbsp; l,m <br />&nbsp; &nbsp;&#123;0x20, 22, 10,0&#125;, //9&nbsp; &nbsp;,m <br />&nbsp; &nbsp;&#123;0x17, 23, 11,0&#125;, //10&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x11, 25, 12,0&#125;, //11&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x0c, 26, 13,0&#125;, //12&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x09, 28, 14,0&#125;, //13&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x07, 29, 15,0&#125;, //14&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x05, 31, 16,0&#125;, //15&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x04, 32, 17,0&#125;, //16&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x03, 34, 18,0&#125;, //17&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x02, 35, 5,0&#125;,&nbsp; //18&nbsp; ,m <br /><br />&nbsp; &nbsp;&#123;0x5a, 20, 20,1&#125;, //19 l,m <br />&nbsp; &nbsp;&#123;0x48, 39, 21,0&#125;, //20 l,m <br />&nbsp; &nbsp;&#123;0x3a, 40, 22,0&#125;, //21 l,m <br />&nbsp; &nbsp;&#123;0x2e, 42, 23,0&#125;, //22 l,m <br />&nbsp; &nbsp;&#123;0x26, 44, 24,0&#125;, //23 l,m <br />&nbsp; &nbsp;&#123;0x1f, 45, 25,0&#125;, //24 l,m <br />&nbsp; &nbsp;&#123;0x19, 46, 26,0&#125;, //25 l,m <br />&nbsp; &nbsp;&#123;0x15, 25, 27,0&#125;, //26 l,m <br />&nbsp; &nbsp;&#123;0x11, 26, 28,0&#125;, //27 l,m <br />&nbsp; &nbsp;&#123;0x0e, 26, 29,0&#125;, //28 l,m <br />&nbsp; &nbsp;&#123;0x0b, 27, 30,0&#125;, //29&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x09, 28, 31,0&#125;, //30&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x08, 29, 32,0&#125;, //31 l,m <br />&nbsp; &nbsp;&#123;0x07, 30, 33,0&#125;, //32 l,m <br />&nbsp; &nbsp;&#123;0x05, 31, 34,0&#125;, //33 l,m&nbsp; &lt;--- changed lps <br />&nbsp; &nbsp;&#123;0x04, 33, 35,0&#125;, //34&nbsp; ,m ... this is NOT skipped <br />&nbsp; &nbsp;&#123;0x04, 33, 36,0&#125;, //35&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x03, 34, 37,0&#125;, //36&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x02, 35, 38,0&#125;, //37&nbsp; ,m ... this is NOT skipped <br />&nbsp; &nbsp;&#123;0x02, 36,&nbsp; 5,0&#125;, //38&nbsp; ,m <br /><br />&nbsp; &nbsp;&#123;0x58, 39, 40,1&#125;, //39 l,m <br />&nbsp; &nbsp;&#123;0x4d, 47, 41,0&#125;, //40 l,m <br />&nbsp; &nbsp;&#123;0x43, 48, 42,0&#125;, //41&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x3b, 49, 43,0&#125;, //42&nbsp; ,m <br />&nbsp; &nbsp;&#123;0x34, 50, 44,0&#125;, //43 l,m <br />&nbsp; &nbsp;&#123;0x2e, 51, 45,0&#125;, //44 l,m <br />&nbsp; &nbsp;&#123;0x29, 44, 46,0&#125;, //45 l,m <br />&nbsp; &nbsp;&#123;0x25, 45, 24,0&#125;, //46&nbsp; ,m <br /><br />&nbsp; &nbsp;&#123;0x56, 47, 48,1&#125;, //47 l,m <br />&nbsp; &nbsp;&#123;0x4f, 47, 49,0&#125;, //48 l,m <br />&nbsp; &nbsp;&#123;0x47, 48, 50,0&#125;, //49 l,m <br />&nbsp; &nbsp;&#123;0x41, 49, 51,0&#125;, //50 l,m <br />&nbsp; &nbsp;&#123;0x3c, 50, 52,0&#125;, //51 l,m <br />&nbsp; &nbsp;&#123;0x37, 51, 43,0&#125;&nbsp; //52&nbsp; ,m <br />&#125;;<br /><br />#define PROB&#40;x&#41; EvolutionTable&#91;Contexts&#91;x&#93;.index&#93;&#91;0&#93;<br />#define NEXT_LPS&#40;x&#41; EvolutionTable&#91;Contexts&#91;x&#93;.index&#93;&#91;1&#93;<br />#define NEXT_MPS&#40;x&#41; EvolutionTable&#91;Contexts&#91;x&#93;.index&#93;&#91;2&#93;<br />#define TOGGLE_INVERT&#40;x&#41; EvolutionTable&#91;Contexts&#91;x&#93;.index&#93;&#91;3&#93;<br /><br />typedef struct &#123;<br />&nbsp; &nbsp;uint8 index;<br />&nbsp; &nbsp;uint8 invert;<br />&#125; context_state;<br /><br />#define NUM_CONTEXTS 30<br />context_state Contexts&#91;NUM_CONTEXTS&#93;;<br /><br />#define BIT&#40;x,y&#41; &#40;&#40;x&gt;&gt;y&#41;&amp;1&#41;<br /><br />void DecompressMode0&#40;uint8 *datain, uint8 *dataout, int len&#41;<br />&#123;<br />&nbsp; &nbsp;uint8 top,val;<br />&nbsp; &nbsp;uint8 con,mps,prob;<br />&nbsp; &nbsp;uint8 flag_lps,shift,mask;<br /><br />&nbsp; &nbsp;int out=0;<br />&nbsp; &nbsp;int inverts=0;<br />&nbsp; &nbsp;int lps=0;<br /><br />&nbsp; &nbsp;unsigned char in;<br />&nbsp; &nbsp;int in_count;<br /><br />&nbsp; &nbsp;int i,bit;<br /><br />&nbsp; &nbsp;//setup <br />&nbsp; &nbsp;top=0xFF;<br /><br />&nbsp; &nbsp;val=*datain;<br />&nbsp; &nbsp;datain++;<br /><br />&nbsp; &nbsp;in=*datain;<br />&nbsp; &nbsp;datain++;<br />&nbsp; &nbsp;in_count=8;<br /><br />&nbsp; &nbsp;//reset context states<br />&nbsp; &nbsp;for&#40;i=0;i&lt;NUM_CONTEXTS;i++&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;i&#93;.index=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;i&#93;.invert=0;<br />&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;for&#40;i=0;i&lt;len;i++&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i==-1800&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;int k;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;\nEvolution table:\n&quot;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;k=0;k&lt;53;k++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;&nbsp; %d,%d //%d\n&quot;,SeenEvolution&#91;k&#93;&#91;0&#93;,SeenEvolution&#91;k&#93;&#91;1&#93;,k&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;for&#40;bit=0;bit&lt;8;bit++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get context<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;mask = &#40;1&lt;&lt;&#40;bit&amp;3&#41;&#41; - 1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con = mask + &#40;&#40;inverts&amp;mask&#41;^&#40;lps&amp;mask&#41;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;bit&gt;3&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con+=15;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get PROB and MPS<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;prob = PROB&#40;con&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;mps&nbsp; = &#40;BIT&#40;out,15&#41; ^ Contexts&#91;con&#93;.invert&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i&gt;=15 &amp;&amp; i&lt;=18 &amp;&amp; 0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;byte %d bit %d: val=%.2X top=%.2X prob=%.2X mps=%d&nbsp; &nbsp;con=%d state=%d\n&quot;,<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;i,bit,val,top,prob,mps,con,Contexts&#91;con&#93;.index&#41;; <br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get bit<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;val &lt;= top-prob&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//mps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = top - prob;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;out = &#40;out &lt;&lt; 1&#41; + mps;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//lps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = val - &#40;top - &#40;prob - 1&#41;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = prob - 1; <br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;out = &#40;out &lt;&lt; 1&#41; + 1-mps;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// renormalize<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;while&#40;top&lt;0x7F&#41; // NOTE: not 0x80, it's a strange border case <br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift++;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = &#40;top&lt;&lt;1&#41;+1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = &#40;val&lt;&lt;1&#41;+&#40;in&gt;&gt;7&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in = &#40;in&lt;&lt;1&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;--in_count==0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in=*datain;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;datain++;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in_count=8;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update processing info<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lps = &#40;lps&lt;&lt;1&#41; + flag_lps;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inverts&nbsp; = &#40;inverts&lt;&lt;1&#41; + Contexts&#91;con&#93;.invert;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update context state<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps &amp; TOGGLE_INVERT&#40;con&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.invert ^= 1;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SeenEvolution&#91;Contexts&#91;con&#93;.index&#93;&#91;0&#93;=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_LPS&#40;con&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if&#40;shift&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SeenEvolution&#91;Contexts&#91;con&#93;.index&#93;&#91;1&#93;=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_MPS&#40;con&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;//save byte<br />&nbsp; &nbsp;&nbsp; &nbsp;*dataout = &#40;out &amp; 0xFF&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;dataout++;<br />&nbsp; &nbsp;&#125;<br />&#125;<br /><br />int DecompressMode1&#40;uint8 *datain, uint8 *dataout, int len&#41;<br />&#123;<br />&nbsp; &nbsp;int pixelorder&#91;4&#93;=&#123;0,1,2,3&#125;;<br />&nbsp; &nbsp;int realorder&#91;4&#93;;<br />&nbsp; &nbsp;int a,b,c;<br />&nbsp; &nbsp;int m,n;<br /><br />&nbsp; &nbsp;uint8 top,val;<br />&nbsp; &nbsp;uint8 con,prob;<br />&nbsp; &nbsp;uint8 flag_lps,shift;<br /><br />&nbsp; &nbsp;int out=0;<br />&nbsp; &nbsp;int inverts=0;<br />&nbsp; &nbsp;int lps=0;<br /><br />&nbsp; &nbsp;unsigned char in;<br />&nbsp; &nbsp;int in_count;<br />&nbsp; &nbsp;int in_len=0;<br /><br />&nbsp; &nbsp;int i,j,pixel;<br /><br />&nbsp; &nbsp;//setup <br />&nbsp; &nbsp;top=0xFF;<br /><br />&nbsp; &nbsp;val=datain&#91;in_len++&#93;;<br /><br />&nbsp; &nbsp;in=datain&#91;in_len++&#93;;<br />&nbsp; &nbsp;in_count=8;<br /><br />&nbsp; &nbsp;//reset context states<br />&nbsp; &nbsp;for&#40;i=0;i&lt;NUM_CONTEXTS;i++&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;i&#93;.index=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;i&#93;.invert=0;<br />&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;for&#40;i=0;i&lt;len;i+=2&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i!=0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//turn pixel data into bitplanes<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//and save as output<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;*dataout = &#40;BIT&#40;out,15&#41;&lt;&lt;7&#41; + &#40;BIT&#40;out,13&#41;&lt;&lt;6&#41; + &#40;BIT&#40;out,11&#41;&lt;&lt;5&#41; + &#40;BIT&#40;out,9&#41;&lt;&lt;4&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;+ &#40;BIT&#40;out,7&#41;&lt;&lt;3&#41; + &#40;BIT&#40;out,5&#41;&lt;&lt;2&#41; + &#40;BIT&#40;out,3&#41;&lt;&lt;1&#41; + BIT&#40;out,1&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;dataout++;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;*dataout = &#40;BIT&#40;out,14&#41;&lt;&lt;7&#41; + &#40;BIT&#40;out,12&#41;&lt;&lt;6&#41; + &#40;BIT&#40;out,10&#41;&lt;&lt;5&#41; + &#40;BIT&#40;out,8&#41;&lt;&lt;4&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;+ &#40;BIT&#40;out,6&#41;&lt;&lt;3&#41; + &#40;BIT&#40;out,4&#41;&lt;&lt;2&#41; + &#40;BIT&#40;out,2&#41;&lt;&lt;1&#41; + BIT&#40;out,0&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;dataout++;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;for&#40;pixel=0;pixel&lt;8;pixel++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get first symbol context<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;a = &#40;&#40;out &gt;&gt; &#40;1*2&#41;&#41; &amp; 0x3&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;b = &#40;&#40;out &gt;&gt; &#40;7*2&#41;&#41; &amp; 0x3&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;c = &#40;&#40;out &gt;&gt; &#40;8*2&#41;&#41; &amp; 0x3&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;a==b &amp;&amp; b==c&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;a==b &amp;&amp; b!=c&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;a!=b &amp;&amp; b==c&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con=2;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;a==c &amp;&amp; b!=c&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con=3;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con=4;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update pixel order<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;m=0;m&lt;4;m++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;pixelorder&#91;m&#93;==a&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;n=m;n&gt;0;n--&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=pixelorder&#91;n-1&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;pixelorder&#91;n-1&#93;=pixelorder&#91;n&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;pixelorder&#91;n&#93;=j;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get PROB<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;prob = PROB&#40;con&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get symbol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;val &lt;= top-prob&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//mps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = top - prob;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//lps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = val - &#40;top - &#40;prob - 1&#41;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = prob - 1; <br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// renormalize<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;while&#40;top&lt;0x7F&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift++;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = &#40;top&lt;&lt;1&#41;+1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = &#40;val&lt;&lt;1&#41;+&#40;in&gt;&gt;7&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in = &#40;in&lt;&lt;1&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;--in_count==0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in=datain&#91;in_len++&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in_count=8;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update processing info<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lps = &#40;lps&lt;&lt;1&#41; + flag_lps;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inverts&nbsp; = &#40;inverts&lt;&lt;1&#41; + Contexts&#91;con&#93;.invert;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update context state<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps &amp; TOGGLE_INVERT&#40;con&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.invert ^= 1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_LPS&#40;con&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if&#40;shift&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_MPS&#40;con&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get context of second symbol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;con = 5 + con*2 + &#40;&#40;lps^inverts&#41;&amp;1&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get PROB<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;prob = PROB&#40;con&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get symbol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;val &lt;= top-prob&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//mps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = top - prob;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//lps<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = val - &#40;top - &#40;prob - 1&#41;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = prob - 1; <br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flag_lps=1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// renormalize<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;while&#40;top&lt;0x7F&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;shift++;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;top = &#40;top&lt;&lt;1&#41;+1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;val = &#40;val&lt;&lt;1&#41;+&#40;in&gt;&gt;7&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in = &#40;in&lt;&lt;1&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;--in_count==0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in=datain&#91;in_len++&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;in_count=8;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//calculate the real pixel order<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;m=0;m&lt;4;m++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;m&#93;=pixelorder&#91;m&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//shift refence pixel c value to top<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;m=0;m&lt;4;m++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;realorder&#91;m&#93;==c&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;n=m;n&gt;0;n--&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=realorder&#91;n-1&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n-1&#93;=realorder&#91;n&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n&#93;=j;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//shift refence pixel b value to top<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;m=0;m&lt;4;m++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;realorder&#91;m&#93;==b&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;n=m;n&gt;0;n--&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=realorder&#91;n-1&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n-1&#93;=realorder&#91;n&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n&#93;=j;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//shift refence pixel a value to top<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;m=0;m&lt;4;m++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;realorder&#91;m&#93;==a&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;n=m;n&gt;0;n--&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=realorder&#91;n-1&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n-1&#93;=realorder&#91;n&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;realorder&#91;n&#93;=j;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update processing info<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lps = &#40;lps&lt;&lt;1&#41; + flag_lps;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inverts&nbsp; = &#40;inverts&lt;&lt;1&#41; + Contexts&#91;con&#93;.invert;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//update context state<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps &amp; TOGGLE_INVERT&#40;con&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.invert ^= 1;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;flag_lps&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_LPS&#40;con&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if&#40;shift&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Contexts&#91;con&#93;.index = NEXT_MPS&#40;con&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//get pixel<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;b=realorder&#91;&#40;lps^inverts&#41;&amp;3&#93;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;out = &#40;out&lt;&lt;2&#41; + b;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;//turn pixel data into bitplanes<br />&nbsp; &nbsp;//and save as output.. BUT don't save second byte unless asked to<br />&nbsp; &nbsp;*dataout = &#40;BIT&#40;out,15&#41;&lt;&lt;7&#41; + &#40;BIT&#40;out,13&#41;&lt;&lt;6&#41; + &#40;BIT&#40;out,11&#41;&lt;&lt;5&#41; + &#40;BIT&#40;out,9&#41;&lt;&lt;4&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;+ &#40;BIT&#40;out,7&#41;&lt;&lt;3&#41; + &#40;BIT&#40;out,5&#41;&lt;&lt;2&#41; + &#40;BIT&#40;out,3&#41;&lt;&lt;1&#41; + BIT&#40;out,1&#41;;<br />&nbsp; &nbsp;dataout++;<br />&nbsp; &nbsp;if&#40;&#40;len&amp;1&#41;==0&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;*dataout = &#40;BIT&#40;out,14&#41;&lt;&lt;7&#41; + &#40;BIT&#40;out,12&#41;&lt;&lt;6&#41; + &#40;BIT&#40;out,10&#41;&lt;&lt;5&#41; + &#40;BIT&#40;out,8&#41;&lt;&lt;4&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;+ &#40;BIT&#40;out,6&#41;&lt;&lt;3&#41; + &#40;BIT&#40;out,4&#41;&lt;&lt;2&#41; + &#40;BIT&#40;out,2&#41;&lt;&lt;1&#41; + BIT&#40;out,0&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;dataout++;<br />&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;if&#40;in_count==8&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;in_len--;<br />&nbsp; &nbsp;//printf&#40;&quot;Used %d bytes of input.\n&quot;,in_len&#41;;<br />&nbsp; &nbsp;return in_len;<br />&#125;<br /><br /><br /><br />// I'm lazy, so here's static allocation<br />//plenty of room for all the files we'll be looking at<br />uint8 datain&#91;0x10000&#93;;<br />uint8 dataout&#91;0x10000&#93;;<br />uint8 realout&#91;0x10000&#93;;<br /><br />uint8 datarom&#91;0x400000&#93;;<br /><br />int htoi&#40;char *str&#41;<br />&#123;<br />&nbsp; &nbsp;int i=0,j=0;<br />&nbsp; &nbsp;while&#40;str&#91;i&#93;!=0&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;j&lt;&lt;=4;<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;str&#91;i&#93;&gt;='0'&#41;&amp;&amp;&#40;str&#91;i&#93;&lt;='9'&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j+=str&#91;i&#93;-'0';<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;str&#91;i&#93;&gt;='A'&#41;&amp;&amp;&#40;str&#91;i&#93;&lt;='F'&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j+=str&#91;i&#93;-'A'+10;<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;str&#91;i&#93;&gt;='a'&#41;&amp;&amp;&#40;str&#91;i&#93;&lt;='f'&#41;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j+=str&#91;i&#93;-'a'+10;<br />&nbsp; &nbsp;&nbsp; &nbsp;i++;<br />&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;return j;<br />&#125;<br /><br /><br />int main&#40;int argc, char* argv&#91;&#93;&#41;<br />&#123;<br />&nbsp; &nbsp;FILE *fp;<br />&nbsp; &nbsp;char filename&#91;260&#93;;<br />&nbsp; &nbsp;int i,j,k,l=0,m=0,len,count;<br /><br />&nbsp; &nbsp;//for&#40;i=0;i&lt;0x10000;i++&#41;<br />&nbsp; &nbsp;//&nbsp; &nbsp;datain&#91;i&#93;=0xFF;<br />&nbsp; &nbsp;//datain&#91;0x2000&#93;=0x7F;<br />&nbsp; &nbsp;//DecompressMode0&#40;datain,dataout,0x10000&#41;;<br /><br />&nbsp; &nbsp;<br />&nbsp; &nbsp;sprintf&#40;filename,&quot;%s&quot;,argv&#91;2&#93;&#41;;<br />&nbsp; &nbsp;fp=fopen&#40;filename,&quot;rb&quot;&#41;;<br />&nbsp; &nbsp;if&#40;fp==NULL&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;ERROR: Can't open file &#91;%s&#93; for reading.\n&quot;,filename&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;return 1;<br />&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;fread&#40;datarom,1,0x400000,fp&#41;;<br />&nbsp; &nbsp;fclose&#40;fp&#41;;<br />&nbsp; &nbsp;fp=NULL;<br /><br />&nbsp; &nbsp;sprintf&#40;filename,&quot;%s.bin&quot;,argv&#91;1&#93;&#41;;<br />&nbsp; &nbsp;fp=fopen&#40;filename,&quot;rb&quot;&#41;;<br />&nbsp; &nbsp;if&#40;fp==NULL&#41;<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;ERROR: Can't open file &#91;%s&#93; for reading.\n&quot;,filename&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;return 1;<br />&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;fseek&#40;fp,0,SEEK_END&#41;;<br />&nbsp; &nbsp;len=ftell&#40;fp&#41;;<br />&nbsp; &nbsp;fseek&#40;fp,0,SEEK_SET&#41;;<br />&nbsp; &nbsp;printf&#40;&quot;File &#91;%s&#93; opened\n&quot;,filename&#41;;<br />&nbsp; &nbsp;printf&#40;&quot;%d entries in Table\n&quot;,len / 0x8000&#41;;<br />&nbsp; &nbsp;len = 0x8000;&nbsp; &nbsp;//All Raw GFX pack decompressions are 0x8000 bytes in size.<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;k=0;<br /><br />&nbsp; &nbsp;i=0;<br />&nbsp; &nbsp;while&#40;filename&#91;i++&#93;!='/'&#41;;&nbsp; &nbsp;//Extract Table Address from bin file name.<br />&nbsp; &nbsp;filename&#91;i+6&#93;=0;<br />&nbsp; &nbsp;j=htoi&#40;&amp;filename&#91;i&#93;&#41;;<br />&nbsp; &nbsp;sprintf&#40;filename,&quot;%s.bin&quot;,argv&#91;1&#93;&#41;;<br /><br />&nbsp; &nbsp;while&#40;fread&#40;realout,1,0x8000,fp&#41;==0x8000&#41;&nbsp; &nbsp;//For each full readout,&nbsp; decompress the data, and compare.<br />&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;Table %.6X-%.2X-%d read --- &quot;,j,k,datarom&#91;j+&#40;k*4&#41;&#93;&amp;3&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;datarom&#91;j+&#40;k*4&#41;&#93;&amp;2&#41;==2&#41;&nbsp; &nbsp;//Decompression type 2 not supported, Type 3 is invalid.<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;Skipped\n&quot;,datarom&#91;j+&#40;k*4&#41;&#93;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;k++;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;continue;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;l=datarom&#91;j+&#40;k*4&#41;+1&#93;&lt;&lt;16;<br />&nbsp; &nbsp;&nbsp; &nbsp;l+=datarom&#91;j+&#40;k*4&#41;+2&#93;&lt;&lt;8;<br />&nbsp; &nbsp;&nbsp; &nbsp;l+=datarom&#91;j+&#40;k*4&#41;+3&#93;;&nbsp; &nbsp;&nbsp; &nbsp;//Get pointer to compressed data.<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;datarom&#91;j+&#40;k*4&#41;&#93;&amp;3&#41;==0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DecompressMode0&#40;&amp;datarom&#91;l&#93;,dataout,len&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;&#40;datarom&#91;j+&#40;k*4&#41;&#93;&amp;3&#41;==1&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DecompressMode1&#40;&amp;datarom&#91;l&#93;,dataout,len&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;//else if &#40;&#40;datarom&#91;j+&#40;k*4&#41;&#93;&amp;3&#41;==2&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;//&nbsp; &nbsp;DecompressMode2&#40;&amp;datarom&#91;l&#93;,dataout,len&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;//compare<br />&nbsp; &nbsp;&nbsp; &nbsp;for&#40;i=0;i&lt;len;i++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;dataout&#91;i&#93;!=realout&#91;i&#93;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i==len&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;Success! No mismatches.\n&quot;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;****FAIL**** mismatch on byte %d - &quot;,i&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;int j=i;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;;i&lt;len;i++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;realout&#91;j&#93;!=realout&#91;i&#93;&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i==len&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;Real Decompressor crashed\n&quot;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;Error in either decompressor or Raw Data\n&quot;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/*<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;int j;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;****FAIL**** mismatch on byte %d\n&quot;,i&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=i-3;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;j&lt;0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;j=0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;;j&lt;=i;j++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;byte %d: decomp&#91;%.2X&#93;-&gt;real&#91;%.2X&#93;\n&quot;,j,dataout&#91;j&#93;,realout&#91;j&#93;&#41;;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;0&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;\nEvolution table:\n&quot;&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;i=0;i&lt;53;i++&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf&#40;&quot;&nbsp; %d,%d //%d\n&quot;,SeenEvolution&#91;i&#93;&#91;0&#93;,SeenEvolution&#91;i&#93;&#91;1&#93;,i&#41;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;*/<br />&nbsp; &nbsp;&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;&nbsp; &nbsp;k++;<br />&nbsp; &nbsp;&#125;<br />&nbsp; &nbsp;fclose&#40;fp&#41;;<br /><br />&nbsp; &nbsp;<br /><br /><br />&nbsp; &nbsp;return 0;<br />&#125;<br /><br /></div>
<br />
<br />Now just waiting for Mode 2 to be figured out, so that it can be dropped into the above code, and completely tested.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Thu Jul 17, 2008 11:19 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />First guess attempts at mode 2 have failed.
<br />I modified the snes code for the prob calculator to work with mode 2.  It is much slower now.  It hasn't finished running an input file yet, but I've looked at preliminary results and it appears that the first symbol for the pixel is always the same context.  And the next symbol appears to only have two contexts.
<br />
<br />The next symbol appears to have at least eight contexts? What?  I'll have to wait for the prob calculator to finish running to see this better.
<br />
<br />I'm way too tired to think straight at the moment.  So that's enough for now.  Hopefully the prob calculator will successfully finish running while I sleep.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Thu Jul 17, 2008 11:31 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">This makes it so each pixel value only affects the "global" pixel likelyhood order exactly once. </div>
<br />
<br />Well, as i said i did'nt run automatic checks, so it's easy i missed that. <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Thu Jul 17, 2008 11:36 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">first symbol for the pixel is always the same context. And the next symbol appears to only have two contexts.<br /><br />The next symbol appears to have at least eight contexts? What?</div>
<br />
<br />If this worked like mode1, you would see 5+10+20+40=75 contexts. But the patent describe how it "degenerate" the possible 75 contexts to only 31.
<br />Basicly, as you have 75=5*15, what it does is to "collapse" 11 of the 15 "states" to not take into account the SX signal, so you finally got 5*4+11=31 contexts. If i didn't failed to follow it, you should see 1 context for bitplane #0, 2 contexts for bitplane #1, 8 contexts for bitplane #2 (3+5*1) and 20 for bitplane #3 (5+5*3).
<br />
<br />So all makes perfect sense. <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" />
<br />
<br />EDITED: Of course, i meant 8 for bitplane #2. Text corrected.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Fri Jul 18, 2008 2:24 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">In case it works and I need to share the code, what is the "standard" way to specify 64bit integers in C? long long doesn't seem to work with the compiler I have here, but __int64 does.</div><br /><br />You're using Visual C++ 6.0? Why? &gt;_&lt;<br /><br />Neither C99 nor C++98 specify either __int64 or long long, but all modern compilers support the latter. It's likely long long will be in C++0X. Of course, char/short/int/long/long long do not guarantee size.<br /><br />I'd suggest including &lt;stdint.h&gt;, and using uint64_t. Visual C++ lacks the header, but you can get a drop-in version here: <!-- m --><a class="postlink" href="http://msinttypes.googlecode.com/svn/trunk/stdint.h">http://msinttypes.googlecode.com/svn/trunk/stdint.h</a><!-- m --><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Testing complete Mode 1 decompression is BIT PERFECT on all cases of SPL4 and MDH, on 100% of the overdumped gfx data.</div>
<br />
<br />Hoorah!! neviksti, you are a hero! :D
<br />So close, so close ...

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>20</strong> of <strong>21</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>