<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=8761" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2012-03-28T00:29:39-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=8761</id>
<entry>
<author><name><![CDATA[Bisqwit]]></name></author>
<updated>2012-03-28T00:29:39-07:00</updated>
<published>2012-03-28T00:29:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8761&amp;p=91902#p91902</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8761&amp;p=91902#p91902"/>
<title type="html"><![CDATA[16-bit software delay routine]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8761&amp;p=91902#p91902"><![CDATA[
This routine delays a run-time specified number of cycles, plus a fixed constant number of cycles (33). The constant number includes the number of cycles the JSR+RTS takes.<br />Pass the number of cycles to delay in A:X with X having the low 8 bits and A having the high 8 bits of the number of cycles to delay.<br />Requires no absolute jumps / relocations. Preserves X,Y. Does require page-aligning so none of the JSRs cross page boundary. Written for CA65.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Delays A:X clocks+overhead<br />; Time: 256*A+X+33 clocks &#40;including JSR&#41;<br />; Clobbers A. Preserves X,Y.<br />delay_256a_x_33_clocks:<br />        cmp #1                  ; +2; 2 cycles overhead<br />        bcs @do256              ; +2; 4 cycles overhead<br />        ; 0-255 cycles remain, overhead = 4<br />        txa                     ; +2; 6<br />        ;;;;;;;;;;;;;;;;<br />        ; 15 + JSR + RTS overhead for the code below. JSR=6, RTS=6. Total: 27. 6+27=33<br />        ;          ;    Cycles        Accumulator     Carry flag<br />        ;          ; 0  1  2  3  4       &#40;hex&#41;        0 1 2 3 4 <br />        sec        ; 0  0  0  0  0   00 01 02 03 04   1 1 1 1 1 <br />:       sbc #5     ; 2  2  2  2  2   FB FC FD FE FF   0 0 0 0 0<br />        bcs :-     ; 4  4  4  4  4   FB FC FD FE FF   0 0 0 0 0<br />        lsr a      ; 6  6  6  6  6   7D 7E 7E 7F 7F   1 0 1 0 1<br />        bcc :+     ; 8  8  8  8  8   7D 7E 7E 7F 7F   1 0 1 0 1<br />:       sbc #$7E   ;10 11 10 11 10   FF FF 00 00 01   0 0 1 1 1<br />        bcc :+     ;12 13 12 13 12   FF FF 00 00 01   0 0 1 1 1<br />        beq :+     ;      14 15 14         00 00 01       1 1 1<br />        bne :+     ;            16               01           1<br />:       rts        ;15 16 17 18 19   This loop from http://6502org.wikidot.com/software-delay<br />@do256: ; do 256 cycles.        ; 5 cycles done so far. C is set from CMP<br />        sbc #1                  ; 2 cycles<br />        pha                     ; 3 cycles<br />         lda #&#40;34*2-1&#41;          ; 2 cycles<br />         ;                      ;12 cycles done so far<br />:        sec                    ; 2 cycles  &#40;sec is only needed<br />         sbc #2                 ; 2 cycles   to make loop 7 cycles&#41;<br />         bcs :-                 ; 3 cycles for taken branch<br />         ;                      ; -1 cycles for untaken branch<br />         ;12 + 34*7 - 1 = 249 done so far, 7 missing<br />        pla                        ; 4 cycles<br />        bcc delay_256a_x_33_clocks ; 3 cycles ; C is unset from SBC</div><br />I could not find such a routine online nor in Blargg's library, so I wrote my own. The sub-256 cycle part is copied from 6502org wiki. Blargg's library has one, but entering it would require a jump, so this ends up having a smaller total overhead.<br /><br />Here is a version that has the semantics for A and X reversed. X contains the high-order 8 bits, A contains the lower 8 bits. X is zeroed, Y is preserved. It reuses the sub-256 cycle delay routine from Blargg's library (which can be entered separately). The overhead is 30 cycles.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Delays X:A clocks+overhead<br />; Time: 256*X+A+30 clocks &#40;including JSR&#41;<br />; Clobbers A,X. Preserves Y.<br />delay_256x_a_30_clocks:<br />        cpx #0                  ; +2<br />        beq delay_a_25_clocks   ; +3  &#40;25+5 = 30 cycles overhead&#41;<br />@do256: ; do 256 cycles. 4 cycles so far. Loop is 1+2+4+4+2+2 = 15 bytes.<br />        pha             ; +3<br />         lda #&#40;256-42&#41;  ; +2<br />         ;              ; 9 cycles done so far. Carry is set from CPX<br />:        adc #1         ; +2<br />         bne :-         ; +3 for taken branch<br />                        ; -1 for untaken branch<br />:        adc #&#40;256/6&#41;   ; 2 cycles<br />         bcc :-         ; +3 for taken branch<br />                        ; -1 for untaken branch<br />         ; 9 + 42*5-1 + 6*5-1 = 247 done so far; 9 missing<br />        pla             ; +4<br />        dex             ; +2<br />        bcs delay_256x_a_30_clocks ; +3. Carry is set from ADC<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />; Delays A clocks + overhead<br />; Preserved: X, Y<br />; Time: A+25 clocks &#40;including JSR&#41;<br />:       sbc #7          ; carry set by CMP<br />delay_a_25_clocks:<br />        cmp #7<br />        bcs :-          ; do multiples of 7<br />        lsr a           ; bit 0<br />        bcs :+<br />:                       ; A=clocks/2, either 0,1,2,3<br />        beq @zero       ; 0: 5<br />        lsr a<br />        beq :+          ; 1: 7<br />        bcc :+          ; 2: 9<br />@zero:  bne :+          ; 3: 11<br />:       rts             ; &#40;thanks to dclxvi for the algorithm&#41;</div><br /><br />If relocations are not a problem, then the routines can be replaced with these, respectively:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;;;;;;;;;;;;;;;;;;;;;;;;<br />; Delays A:X clocks+overhead<br />; Clobbers A. Preserves X,Y. Has relocations.<br />; Time: 256*A+X+31 clocks &#40;including JSR&#41;<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />:       ; do 256 cycles.        ; 5 cycles done so far. Loop is 2+1+ 2+3+ 1 = 9 bytes.<br />        sbc #1                  ; 2 cycles - Carry was set from cmp<br />        pha                     ; 3 cycles<br />         lda #&#40;256-25-10-2-4&#41;   ; +2<br />         jsr delay_a_25_clocks<br />        pla                     ; 4 cycles<br />delay_256a_x_31_clocks:<br />        cmp #1                  ; +2; 2 cycles overhead<br />        bcs :-                  ; +2; 4 cycles overhead<br />        ; 0-255 cycles remain, overhead = 4<br />        txa                     ; +2; 6; +27 = 33<br />        ; 15 + JSR + RTS overhead for the code below. JSR=6, RTS=6. 15+12=27<br />        ;          ;    Cycles        Accumulator     Carry flag<br />        ;          ; 0  1  2  3  4       &#40;hex&#41;        0 1 2 3 4 <br />        sec        ; 0  0  0  0  0   00 01 02 03 04   1 1 1 1 1 <br />:       sbc #5     ; 2  2  2  2  2   FB FC FD FE FF   0 0 0 0 0<br />        bcs :-     ; 4  4  4  4  4   FB FC FD FE FF   0 0 0 0 0<br />        lsr a      ; 6  6  6  6  6   7D 7E 7E 7F 7F   1 0 1 0 1<br />        bcc :+     ; 8  8  8  8  8   7D 7E 7E 7F 7F   1 0 1 0 1<br />:       sbc #$7E   ;10 11 10 11 10   FF FF 00 00 01   0 0 1 1 1<br />        bcc :+     ;12 13 12 13 12   FF FF 00 00 01   0 0 1 1 1<br />        beq :+     ;      14 15 14         00 00 01       1 1 1<br />        bne :+     ;            16               01           1<br />:       rts        ;15 16 17 18 19   &#40;thanks to dclxvi for the algorithm&#41;<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />; Delays X:A clocks+overhead<br />; Clobbers A,X. Preserves Y. Has relocations.<br />; Time: 256*X+A+30 clocks &#40;including JSR&#41;<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />delay_256x_a_30_clocks:<br />        cpx #0                  ; +2<br />        beq delay_a_25_clocks   ; +3  &#40;25+5 = 30 cycles overhead&#41;<br />        ; do 256 cycles.        ;  4 cycles so far. Loop is 1+1+ 2+3+ 1+3 = 11 bytes.<br />        dex                     ;  2 cycles<br />        pha                     ;  3 cycles<br />         lda #&#40;256-25-9-2-7&#41;    ; +2<br />         jsr delay_a_25_clocks<br />        pla                        ; 4<br />        jmp delay_256x_a_30_clocks ; 3.<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />; Delays A clocks + overhead<br />; Preserved: X, Y<br />; Time: A+25 clocks &#40;including JSR&#41;<br />;;;;;;;;;;;;;;;;;;;;;;;;<br />:       sbc #7          ; carry set by CMP<br />delay_a_25_clocks:<br />        cmp #7<br />        bcs :-          ; do multiples of 7<br />        ;               ; Cycles          Accumulator            Carry           Zero<br />        lsr a           ; 0 0 0 0 0 0 0   00 01 02 03 04 05 06   0 0 0 0 0 0 0   ? ? ? ? ? ? ? <br />        bcs :+          ; 2 2 2 2 2 2 2   00 00 01 01 02 02 03   0 1 0 1 0 1 0   1 1 0 0 0 0 0 <br />:       beq @zero       ; 4 5 4 5 4 5 4   00 00 01 01 02 02 03   0 1 0 1 0 1 0   1 1 0 0 0 0 0<br />        lsr a           ; : : 6 7 6 7 6   :: :: 01 01 02 02 03   : : 0 1 0 1 0   : : 0 0 0 0 0 <br />        beq :+          ; : : 8 9 8 9 8   :: :: 00 00 01 01 01   : : 1 1 0 0 1   : : 1 1 0 0 0 <br />        bcc :+          ; : : : : A B A   :: :: :: :: 01 01 01   : : : : 0 0 1   : : : : 0 0 0<br />@zero:  bne :+          ; 7 8 : : : : C   00 01 :: :: :: :: 01   0 1 : : : : 1   1 1 : : : : 0<br />:       rts             ; 9 A B C D E F   &#40;thanks to dclxvi for the algorithm&#41;</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5043">Bisqwit</a> — Wed Mar 28, 2012 12:29 am</p><hr />
]]></content>
</entry>
</feed>