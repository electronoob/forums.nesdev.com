<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=10&amp;t=1222" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2009-04-10T00:24:36-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=10&amp;t=1222</id>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2009-04-10T00:24:36-07:00</updated>
<published>2009-04-10T00:24:36-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=45445#p45445</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=45445#p45445"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=45445#p45445"><![CDATA[
I just revised my Bin to Dec routines, and I thought I'd post them up if anyone is interested:<br /><br /><!-- m --><a class="postlink" href="http://www.freewebs.com/the_bott/BinToDec.asm">http://www.freewebs.com/the_bott/BinToDec.asm</a><!-- m --><br /><br />The major con to this is that it compiles to 1000 (exactly) bytes, but it's the same speed every time, no matter what the number is:<br /><br />8 bits: 118 cycles<br />16 bits: 263 cycles<br />24 bits: 475 cycles<br /><br />I like those speeds quite a bit, but it's true it's quite space-hogging (it's not a big deal for me though).<br /><br />One could take out the 24 bit routine (and the tables it uses) to cut it all down to roughly 700 bytes (maybe less), or one could even cut the 8 bit routine out if it didn't seem worthwhile.<br /><br />For anyone who hasn't been following the thread since 3 years ago, my method revolves around the fact that a value like $3A5D is the equivalent to $3000 + $A00 + $50 + $D. It uses tables of pre-calculated hex to decimal values for each hex digit place. So one of the tables contains the pre-converted decimal value for $0000, $1000, $2000, $3000, ... $E000, and $F000, while another contains the values for $000, $100, $200, $300 ... $E00, and $F00, etc. It simulates pen-and-paper decimal addition using the data from these tables, and returns each decimal digit in a ZP variable. It uses 11 bytes of zero page, also. So all you have to do is put the hex values in Hex0, Hex1, and Hex2 (just the first for 8 bits, the first 2 for 16, and all for 24 bit conversion), and it returns the values in DecOnes, DecTens, DecHundreds, DecThousands, DecTenThousands, DecHundredThousands, DecMillions, and DecTenMillions (obviously depending on the bit width of the hex value).<br /><br />Just thought I'd post for anyone who's interested.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Fri Apr 10, 2009 12:24 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Sivak]]></name></author>
<updated>2009-02-13T19:47:16-07:00</updated>
<published>2009-02-13T19:47:16-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43303#p43303</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43303#p43303"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43303#p43303"><![CDATA[
I was mainly interested in using this to display a kind of coordinate thing up top in my game.  I used the one for 2 digits and it works fine for me, so thanks.  No more hex output!<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3374">Sivak</a> — Fri Feb 13, 2009 7:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Disch]]></name></author>
<updated>2009-02-13T18:44:14-07:00</updated>
<published>2009-02-13T18:44:14-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43302#p43302</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43302#p43302"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43302#p43302"><![CDATA[
Sweetness.  Thanks blargg<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=33">Disch</a> — Fri Feb 13, 2009 6:44 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2009-02-13T18:24:27-07:00</updated>
<published>2009-02-13T18:24:27-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43301#p43301</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43301#p43301"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43301#p43301"><![CDATA[
For any old links of mine, try replacing "www.io.com/~greens" with "h1.ripway.com/blargg". So this one becomes <!-- m --><a class="postlink" href="http://h1.ripway.com/blargg/temp/to_decimal_asm.zip">http://h1.ripway.com/blargg/temp/to_decimal_asm.zip</a><!-- m --><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Fri Feb 13, 2009 6:24 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Disch]]></name></author>
<updated>2009-02-13T16:44:15-07:00</updated>
<published>2009-02-13T16:44:15-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43296#p43296</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43296#p43296"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=43296#p43296"><![CDATA[
** BUMP **<br /><br />Was looking for this lib, but the links are all dead.  Specifically I'm looking for the one previously at this link:<br /><br /><!-- m --><a class="postlink" href="it's now http://h1.ripway.com/blargg/temp/to_decimal_asm.zip">it's now http://h1.ripway.com/blargg/temp/to_decimal_asm.zip</a><!-- m --><br /><br />which was the 2nd link in blargg's post here:<br /><br /><!-- m --><a class="postlink" href="http://nesdev.com/bbs/viewtopic.php?p=17351#17351">http://nesdev.com/bbs/viewtopi ... 7351#17351</a><!-- m --><br /><br /><br />If someone has this, could they re-link it somewhere?  Or if it exists somewhere else, could someone give a link?<br /><br />Thanks!<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=33">Disch</a> — Fri Feb 13, 2009 4:44 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Quietust]]></name></author>
<updated>2006-09-17T00:48:02-07:00</updated>
<published>2006-09-17T00:48:02-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17593#p17593</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17593#p17593"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17593#p17593"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit?<br /></div><br />The ten thousand values subtracted are 70000, 40000, 20000, and 10000. In the 24-bit case, once it's eliminated 70000, the number could still be 69999 ($01116F). If it jumped to the 16-bit code immediately, the still non-zero most significant byte would be ignored, making the value look like 4463. Of course I had the benefit of the validator, so I could just adjust the overlap until it worked, then figure out why. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div><br /><br />Oh yeah, forgot about that. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br />To be fair, I never would have actually seen the 256-299 case, since my score and timer all go by multiples of 50; as for the 65536-69999 case, I just wasn't patient enough to try large enough values.<br />Come to think of it, it would probably be worth it to just divide the score and bonus timer by 10 internally and just pad them with an extra 0.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7">Quietust</a> — Sun Sep 17, 2006 12:48 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-09-17T00:14:10-07:00</updated>
<published>2006-09-17T00:14:10-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17590#p17590</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17590#p17590"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17590#p17590"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit?<br /></div><br />The ten thousand values subtracted are 70000, 40000, 20000, and 10000. In the 24-bit case, once it's eliminated 70000, the number could still be 69999 ($01116F). If it jumped to the 16-bit code immediately, the still non-zero most significant byte would be ignored, making the value look like 4463. Of course I had the benefit of the validator, so I could just adjust the overlap until it worked, then figure out why. :)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />When I ran it on the 24-bit number 0, it took only 581 cycles to complete,<br /></div><br />In the most recent posted code I list the worst-case values so you can easily invoke it when testing them in a program. I tested your changes and they broke the 24-bit and 16-bit routines for the reason described above. I went ahead spent a while (ugh, 3 hours now that I check) optimizing the routine more.<br /><br />I was able to eliminate the entry for 200 from the table and have the 16-bit case do an optimized check for this at the end, simply seeing if the high byte is non-zero, in which case it subtracts 200 without any further checks. If the high byte is zero, then it uses the normal hex2bcd_8bit code.<br /><br />I found another optimizatin using the 7/4/2/1 group: if the 7 test passes, then the 4 test can be skipped. I incorporated this into the ends of the 16-bit and 24-bit match loops, having them skip the last entry if the next-to-last entry matched.<br /><br />I was able to reduce the vtable size further by changing the millions to the 1/2/4/7 pattern, allowing the 16-bit and 24-bit routines to use the same vtable from the beginning. I had to fix a bug in the HEXBYTE macros: rather than subtract 1 from the low byte, I needed to subtract 1 from val in all of them.<br /><br />I rearranged the match handlers to fall through to the loop, and for the non-match loop case to fall through to the next smaller handler (i.e. 24 falls into 16, 16 falls into 8), eliminating more branches.<br /><br />Finally, I added short-circuiting that immediately jumps to the 16- and 8- bit handlers once the upper bits of the value become zero. This is just two branches that can be removed if desired, as they slightly increase the worst-case performance.<br /><br />I removed the init routine from the source since it was cluttering it up. I also wasn't able to use the local symbol names as my ca65 gave a diagnostic (same for using :+, which sucks), and I don't feel like checking for a new version, getting it to compile, and seeing if these are fixed.<br /><br /><a href="it's now http://h1.ripway.com/blargg/temp/hex2bcd5.asm" class="postlink">hex2bcd5.asm</a><br /><br />Best case is for value 0. Worst case values listed.<br />hex2bcd_24bit Best: 106, Average: 760, Worst: 962 (n=16768641)<br />hex2bcd_16bit Best:  77, Average: 357, Worst: 439 (n=34640)<br />hex2bcd_8bit  Best:  55, Average:  67, Worst:  78 (n=240)<br />252 bytes<br /><br />If the two lines marked "optimization only" are removed: (note improved worst-case)<br />hex2bcd_24bit Best: 589, Average: 788, Worst: 924 (n=15964654)<br />hex2bcd_16bit Best: 278, Average: 361, Worst: 421 (n=34640)<br />248 bytes<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Sep 17, 2006 12:14 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Quietust]]></name></author>
<updated>2006-09-16T19:19:52-07:00</updated>
<published>2006-09-16T19:19:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17585#p17585</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17585#p17585"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17585#p17585"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />Quietust's table-based version passed the exhaustive test. I then optimized it to run about twice as fast and fit in one 256-byte page. Here is the original source and three progressively optimized versions, with comments at the top about all the changes:<br /><br /><a href="it's now http://h1.ripway.com/blargg/temp/hex2bcd_opt.zip" class="postlink">hex2bcd_opt.zip</a><br /></div><br /><br />Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit? Is there something gained by not handling it straight within the 16-bit case? And why do you not do the same thing when going from 16-bit to 8-bit (you end up doing the 200 case twice)?<br /><br />For reference, the following code appears to work properly and is only 233 bytes long. When I ran it on the 24-bit number 0, it took only 581 cycles to complete, though I don't know if larger numbers were made slower in the process.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">hex2bcd_output:   .res 8<br />hex2bcd_input:   .res 3<br /><br /><br /><br />.proc   hex2bcd_init<br />   LDY #7<br />:   STA hex2bcd_output,Y<br />   DEY<br />   BPL :-   <br />   RTS<br />.endproc<br /><br />.scope hex2bcd<br />conv_24bit:<br />   LDY #9<br />   CLC<br />loop1:   LDA hex2bcd_input+0<br />   SBC b0table+9,Y<br />   LDA hex2bcd_input+1<br />   SBC b1table+9,Y<br />   TAX<br />   LDA hex2bcd_input+2<br />   SBC b2table,Y<br />   BCS good1<br />   DEY<br />   BPL loop1<br />   BMI conv_16bit<br />   <br />good1:   STA hex2bcd_input+2<br />   STX hex2bcd_input+1<br />   <br />   LDX otable+9,Y<br />   LDA hex2bcd_output,X<br />   ADC vtable,Y<br />   STA hex2bcd_output,X<br />   <br />   LDA hex2bcd_input+0<br />   SBC b0table+9,Y<br />   STA hex2bcd_input+0<br />   CLC<br />   DEY<br />   BPL loop1<br /><br />conv_16bit:<br />   LDY #8<br />   CLC<br />loop2:   LDA hex2bcd_input+0<br />   SBC b0table,Y<br />   TAX<br />   LDA hex2bcd_input+1<br />   SBC b1table,Y<br />   BCS good2<br />   DEY<br />   BPL loop2<br />   BMI conv_8bit<br />   <br />good2:   STX hex2bcd_input+0<br />   STA hex2bcd_input+1<br />   LDX otable,Y<br />   LDA hex2bcd_output,X<br />   ADC vtable+3,Y<br />   STA hex2bcd_output,X<br />   DEY<br />   BPL loop2<br /><br />conv_8bit:<br />   LDA hex2bcd_input+0<br />   CMP #200<br />   BCC :+<br />   SBC #200<br />   INC hex2bcd_output+5<br />   INC hex2bcd_output+5<br />:   CMP #100<br />   BCC :+<br />   SBC #100<br />   INC hex2bcd_output+5<br />:   LDX #0<br />   CMP #60<br />   BCC :+<br />   SBC #60<br />   LDX #6<br />:   CMP #30<br />   BCC :+<br />   SBC #30<br />   INX<br />   INX<br />   INX<br />:   CMP #20<br />   BCC :+<br />   SBC #20<br />   INX<br />   INX<br />:   CMP #10<br />   BCC :+<br />   SBC #10<br />   INX<br />   CLC<br />:   ADC hex2bcd_output+7<br />   STA hex2bcd_output+7<br />   TXA<br />   ADC hex2bcd_output+6<br />   STA hex2bcd_output+6<br />   RTS<br /><br />vtable:   .byte 6,0,1,2,5,0,1,2,5,0,1,3<br />otable:   .byte 5,5,4,4,4,4,3,3,3,3,2,2,2,2,1,1,1,1,0<br /><br />.define    HEX_BYTE2&#40;val&#41; .LOBYTE&#40;.HIWORD&#40;val&#41;&#41;<br />.define    HEX_BYTE1&#40;val&#41; .HIBYTE&#40;.LOWORD&#40;val&#41;&#41;<br />.define    HEX_BYTE0&#40;val&#41; &#40;.LOBYTE&#40;.LOWORD&#40;val&#41;&#41;-1&#41;<br /><br />b0table:<br />.byte                                         HEX_BYTE0&#40;     300&#41;,HEX_BYTE0&#40;     600&#41;<br />.byte HEX_BYTE0&#40;    1000&#41;,HEX_BYTE0&#40;    2000&#41;,HEX_BYTE0&#40;    3000&#41;,HEX_BYTE0&#40;    6000&#41;<br />.byte HEX_BYTE0&#40;   10000&#41;,HEX_BYTE0&#40;   20000&#41;,HEX_BYTE0&#40;   40000&#41;,HEX_BYTE0&#40;   70000&#41;<br />.byte HEX_BYTE0&#40;  100000&#41;,HEX_BYTE0&#40;  200000&#41;,HEX_BYTE0&#40;  300000&#41;,HEX_BYTE0&#40;  600000&#41;<br />.byte HEX_BYTE0&#40; 1000000&#41;,HEX_BYTE0&#40; 2000000&#41;,HEX_BYTE0&#40; 3000000&#41;,HEX_BYTE0&#40; 6000000&#41;<br />.byte HEX_BYTE0&#40;10000000&#41;<br /><br />b1table:<br />.byte                                         HEX_BYTE1&#40;     300&#41;,HEX_BYTE1&#40;     600&#41;<br />.byte HEX_BYTE1&#40;    1000&#41;,HEX_BYTE1&#40;    2000&#41;,HEX_BYTE1&#40;    3000&#41;,HEX_BYTE1&#40;    6000&#41;<br />.byte HEX_BYTE1&#40;   10000&#41;,HEX_BYTE1&#40;   20000&#41;,HEX_BYTE1&#40;   40000&#41;,HEX_BYTE1&#40;   70000&#41;<br />.byte HEX_BYTE1&#40;  100000&#41;,HEX_BYTE1&#40;  200000&#41;,HEX_BYTE1&#40;  300000&#41;,HEX_BYTE1&#40;  600000&#41;<br />.byte HEX_BYTE1&#40; 1000000&#41;,HEX_BYTE1&#40; 2000000&#41;,HEX_BYTE1&#40; 3000000&#41;,HEX_BYTE1&#40; 6000000&#41;<br />.byte HEX_BYTE1&#40;10000000&#41;<br /><br />b2table:<br />.byte                                                             HEX_BYTE2&#40;   70000&#41;<br />.byte HEX_BYTE2&#40;  100000&#41;,HEX_BYTE2&#40;  200000&#41;,HEX_BYTE2&#40;  300000&#41;,HEX_BYTE2&#40;  600000&#41;<br />.byte HEX_BYTE2&#40; 1000000&#41;,HEX_BYTE2&#40; 2000000&#41;,HEX_BYTE2&#40; 3000000&#41;,HEX_BYTE2&#40; 6000000&#41;<br />.byte HEX_BYTE2&#40;10000000&#41;<br />.endscope<br /><br />hex2bcd_24bit = hex2bcd::conv_24bit<br />hex2bcd_16bit = hex2bcd::conv_16bit<br />hex2bcd_8bit = hex2bcd::conv_8bit<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7">Quietust</a> — Sat Sep 16, 2006 7:19 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-09-16T15:25:01-07:00</updated>
<published>2006-09-16T15:25:01-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17571#p17571</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17571#p17571"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17571#p17571"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />That didn't work in your code since the subtraction of the low byte is bypassed when the high byte is greater than the comparison value. Below, when X &gt; 23, it jumps to gt60000. In your code, the SBC would only have been done in place of the CMP #112, if X = 23.<br /></div><br />Whoops!  That's what happens when I write code at three in the morning and never test it.<br /><br /><div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />I delved deeper into this in some ways. I first noted that only 3 out of 10 digits end in a 1, therefore 70% of the time the last comparison will not match, so the code can be optimized for the loop ending with a non-match. Also, supporting multiple entry points, I used the digits 7, 4, 2, 1 for the ten thousands place (in both versions), allowing the 16-bit case to check digits 4, 2, 1, and the 24-bit case to check for digits 7, 4, 2, 1. This allowed the 24-bit code to jump to the 16-bit code after checking for 7. The 7, 4, 2, 1 set is almost as good as 6, 3, 2, 1, and doesn't ever use more than two for a given digit.<br /></div><br />That is very clever.  I can see how 24-bit support might be useful, e.g. for experience points in an RPG.  Having entry points for known number of digits is a great idea too.  Note that if you aren't sure how large the number is but its usually small, you could do one short-circuit test at the start of the routine (e.g. if the high byte is zero, jump over a bunch of code).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Sat Sep 16, 2006 3:25 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-09-16T13:10:48-07:00</updated>
<published>2006-09-16T13:10:48-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17562#p17562</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17562#p17562"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17562#p17562"><![CDATA[
<div class="quotetitle">mozz wrote:</div><div class="quotecontent"><br />the algorithm I proposed works on a similar idea to binary search (see wikipedia article). For each digit, it essentially does a binary search for the value of the digit. With 10 possible values for the digit, you need to do at most ceil(log2(10)) == 4 tests to figure out which one it is.<br /></div><br /><br />I actually started out by trying to implement a binary search, but it was quite unwieldy.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Once you know what the value of the digit is, you have to subtract that number from N anyways so that you can get on with figuring out the next digit. So rather than handle the "high" case and the "low" case differently for each comparison, I keep things simple by just subtracting as I go! That effectively makes both cases the same.<br /></div><br />That didn't work in your code since the subtraction of the low byte is bypassed when the high byte is greater than the comparison value. Below, when X &gt; 23, it jumps to gt60000. In your code, the SBC would only have been done in place of the CMP #112, if X = 23. Also the way I coded it, I didn't keep re-loading the lowest byte, so even if I found a way to use the SBC in place of a comparison, I'd have to undo the subtract if the number was found lower than the digit value.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    cpx #23<br />    bcc lt6000<br />    bne gt6000<br />    cmp #112<br />    bcc lt6000<br />gt6000:<br />    sbc #112<br />    tay<br />    txa<br />    sbc #23<br />    tax<br />    tya</div><br />On the other hand, Quietust's hex2bcd (and my further optimizations of it) do as you describe: subtract the digit value from a temporary copy of the value, and if the result isn't negative, writes this new value back. I enjoyed the simplicity of this when working with hex2bcd.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />since we only have 10 possible digits that the result might be, 6,3,2,1 are slightly faster when the digit happens to be a 7 (because 6+1 = 7, where the other case is 4+2+1 = 7)<br /></div><br />I delved deeper into this in some ways. I first noted that only 3 out of 10 digits end in a 1, therefore 70% of the time the last comparison will not match, so the code can be optimized for the loop ending with a non-match. Also, supporting multiple entry points, I used the digits 7, 4, 2, 1 for the ten thousands place (in both versions), allowing the 16-bit case to check digits 4, 2, 1, and the 24-bit case to check for digits 7, 4, 2, 1. This allowed the 24-bit code to jump to the 16-bit code after checking for 7. The 7, 4, 2, 1 set is almost as good as 6, 3, 2, 1, and doesn't ever use more than two for a given digit.<br /><br />The code still needs to be documented a bit better and perhaps hex2bcd have the multiple entry points moved to another file (or added as macros as I did to hex2bcd_small), since they bloat it a bit.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Sep 16, 2006 1:10 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-09-16T10:50:56-07:00</updated>
<published>2006-09-16T10:50:56-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17549#p17549</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17549#p17549"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17549#p17549"><![CDATA[
See?  Get a few smart people interested in solving a problem, and look what happens!<br /><br />Blargg and Quietust, thank you for following through on this.  Now everybody who actually writes their own NES games can benefit.  This is exactly what I hoped would happen.<br /><br />Edit:  @Bregalad and Celius:  the algorithm I proposed works on a similar idea to <a href="http://en.wikipedia.org/wiki/Binary_search" class="postlink">binary search (see wikipedia article)</a>.<br />For each digit, it essentially does a binary search for the value of the digit.  With 10 possible values for the digit, you need to do at most ceil(log2(10)) == 4 tests to figure out which one it is.<br /><br />One subtle part is this:  Once you know what the value of the digit is, you have to subtract that number from N anyways so that you can get on with figuring out the next digit.  So rather than handle the "high" case and the "low" case differently for each comparison, I keep things simple by just subtracting as I go!  That effectively makes both cases the same.<br /><br />So if you have 4 digits worth of number to figure out, and you start out comparing the number to 6000, then either it's less than 6000 and we do nothing (the low case), or its &gt;= 6000 (the high case) in which case we subtract that 6000 right away and add 6 to temporary where we store the value of the digit we will output.  Because of the subtraction, the remaining part of the number is now less than 4000, whether we subtracted 6000 from it or not, which makes it simple to do the next step (comparing it to 3000).<br /><br />The other subtle part, which Disch elaborated on earlier, is how I chose the 4 points to compare the digit to such that at most two of the comparisons will succeed.  3 comparisons is unfortunately not enough in some cases (that could only distinguish 2^3 == 8 different values).  If we had 16 possible digits to look for, we would need the four points to be 8,4,2,1 but since we only have 10 possible digits that the result might be, 6,3,2,1 are slightly faster when the digit happens to be a 7 (because 6+1 = 7, where the other case is 4+2+1 = 7)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Sat Sep 16, 2006 10:50 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-09-13T12:47:38-07:00</updated>
<published>2006-09-13T12:47:38-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17351#p17351</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17351#p17351"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17351#p17351"><![CDATA[
Quietust's table-based version passed the exhaustive test. I then optimized it to run about twice as fast and fit in one 256-byte page. Here is the original source and three progressively optimized versions, with comments at the top about all the changes:<br /><br /><a href="it's now http://h1.ripway.com/blargg/temp/hex2bcd_opt.zip" class="postlink">hex2bcd_opt.zip</a><br /><br />This code could also have multiple entry points added for the desired number of output digits. Maybe I'll do that tomorrow.<br /><br /><strong>UPDATE</strong> ... or today.<br /><br />I think I've pretty much beat this to death here. I added entry points for arbitrary numbers of digits, and an intermediate optimized version with just the 24-bit code, if size is your biggest concern (it comes in at 192 bytes). The other fast code from yesterday is also included.<br /><br /><a href="it's now http://h1.ripway.com/blargg/temp/to_decimal_asm.zip" class="postlink">to_decimal_asm.zip</a><br /><br />Summary so far:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">xa_to_decimal.asm:<br />yxa_to_8_digits: Best: 186, Average: 344, Worst: 475<br />yxa_to_7_digits: Best: 170, Average: 322, Worst: 440<br />yxa_to_6_digits: Best: 139, Average: 254, Worst: 348<br />yxa_to_5_digits: Best: 104, Average: 179, Worst: 236<br /> xa_to_5_digits: Best:  99, Average: 170, Worst: 231<br /> xa_to_4_digits: Best:  79, Average: 128, Worst: 173<br /> xa_to_3_digits: Best:  54, Average:  75, Worst:  94<br />  a_to_3_digits: Best:  43, Average:  52, Worst:  60<br />  a_to_2_digits: Best:  28, Average:  34, Worst:  40<br />610 bytes &#40;279 if you leave out 6-8 digit support&#41;<br /><br />hex2bcd.asm<br />hex2bcd_24bit_8dig Best: 600, Average: 815, Worst: 940<br />hex2bcd_24bit_7dig Best: 572, Average: 777, Worst: 877<br />hex2bcd_24bit_6dig Best: 452, Average: 608, Worst: 687<br />hex2bcd_24bit_5dig Best: 332, Average: 439, Worst: 497<br />hex2bcd_16bit_5dig Best: 288, Average: 383, Worst: 441<br />hex2bcd_16bit_4dig Best: 222, Average: 289, Worst: 329<br />hex2bcd_16bit_3dig Best: 130, Average: 165, Worst: 191<br /> hex2bcd_8bit_3dig Best:  55, Average:  67, Worst:  78<br /> hex2bcd_8bit_2dig Best:  48, Average:  55, Worst:  60 <br />277 bytes<br /><br />hex2bcd_small.asm<br />hex2bcd_24bit_8dig: Best: 768, Average: 1073, Worst: 1226<br />hex2bcd_24bit_7dig: Best: 741, Average: 1036, Worst: 1164<br />hex2bcd_24bit_6dig: Best: 621, Average:  867, Worst:  974<br />hex2bcd_24bit_5dig: Best: 501, Average:  698, Worst:  784<br />hex2bcd_16bit_5dig: Best: 471, Average:  661, Worst:  754<br />hex2bcd_16bit_4dig: Best: 381, Average:  529, Worst:  594<br />hex2bcd_16bit_3dig: Best: 261, Average:  360, Worst:  404<br /> hex2bcd_8bit_3dig: Best: 201, Average:  270, Worst:  309<br /> hex2bcd_8bit_2dig: Best: 141, Average:  191, Worst:  214<br />192 bytes</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Wed Sep 13, 2006 12:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Memblers]]></name></author>
<updated>2006-09-13T09:04:59-07:00</updated>
<published>2006-09-13T09:04:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17327#p17327</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17327#p17327"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17327#p17327"><![CDATA[
<div class="quotetitle">Bregalad wrote:</div><div class="quotecontent"><br />Well, both aren't so much different, but I just found the first one look more professional. Total subjective behaviour, though.<br /></div><br /><br />I'd say it's a good opportunity for writing a macro for calling the routine, you can have it look as professional as you want while still being the fastest and smallest method (and only take up one line of source, which is great if you do it a lot, less chance for typos also).<br /><br />Why does your 2nd example do LDA number+2 / TAY btw?  Just do LDY number+2.  <img src="http://forums.nesdev.com/images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br /><br />Nice work everyone, and thanks.  Maybe some day I'll have a program now that displays actual decimal numbers from hex (I can think of plenty of uses, XMODEM transfer status for one).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=10">Memblers</a> — Wed Sep 13, 2006 9:04 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2006-09-13T08:35:16-07:00</updated>
<published>2006-09-13T08:35:16-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17324#p17324</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17324#p17324"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17324#p17324"><![CDATA[
Oh, I did follow nothing ! Are you guys still doing the method who substract constant numbers and compares them in order to find the main digit (unsure I understand this perfectly).<br />Using A, X and Y register as the input number isn't optimal in my opinion.<br />The best way is to have only a pointer in z-page that points where the actual binary number in memory to be converted is, and to call the routine to a different label in function of the number of digit you want.<br />Just compare the two folowing piece of code :<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda #&lt;Number<br />sta PointerL<br />lda #&gt;Number<br />sta PointerH<br />jsr ConvertBinNmr<br /></div><br />or<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda Number+2<br />tay<br />lda Number+1<br />tax<br />lda Number<br />jsr ConvertBinNmr</div><br />Well, both aren't so much different, but I just found the first one look more professional. Total subjective behaviour, though.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Wed Sep 13, 2006 8:35 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Quietust]]></name></author>
<updated>2006-09-13T07:23:49-07:00</updated>
<published>2006-09-13T07:23:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17314#p17314</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17314#p17314"/>
<title type="html"><![CDATA[Hex to Decimal suggestion]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1222&amp;p=17314#p17314"><![CDATA[
I liked the method you used, but didn't like the high code size (613 bytes) and the forcing of using all of the available registers to hold the values (which can get messy and confusing at times), so I threw together a looped routine that worked on the same principle but took up less space. Code size came up at 280 bytes, and while it is significantly slower than your version, it's still way faster than the one I posted earlier. It currently doesn't support multiple entry points for variable output digits, but that's easy enough to add by just replacing the initial LDY in each routine with a different value corresponding to the proper offsets in the data tables.<br /><br />This one assembles with CA65:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">.define   HEX_BYTE2&#40;val&#41; .LOBYTE&#40;.HIWORD&#40;val&#41;&#41;<br />.define   HEX_BYTE1&#40;val&#41; .HIBYTE&#40;.LOWORD&#40;val&#41;&#41;<br />.define   HEX_BYTE0&#40;val&#41; .LOBYTE&#40;.LOWORD&#40;val&#41;&#41;<br /><br />hex2bcd_output:   .res 8<br />hex2bcd_input:   .res 3<br /><br />.proc   hex2bcd_init<br />   LDY #7<br />:   STA hex2bcd_output,Y<br />   DEY<br />   BPL :-   <br />   RTS<br />.endproc<br /><br />.proc   hex2bcd_24bit<br />   LDY #0<br />loop:   LDA hex2bcd_otable,Y<br />   BMI done<br />   TAX<br />   SEC<br />   LDA hex2bcd_input+0<br />   SBC hex2bcd_b0table,Y<br />   PHA<br />   LDA hex2bcd_input+1<br />   SBC hex2bcd_b1table,Y<br />   PHA<br />   LDA hex2bcd_input+2<br />   SBC hex2bcd_b2table,Y<br />   BCS okay<br />   PLA<br />   PLA<br />   BCC end<br />okay:   STA hex2bcd_input+2<br />   PLA<br />   STA hex2bcd_input+1<br />   PLA<br />   STA hex2bcd_input+0<br /><br />   LDA hex2bcd_output,X<br />   CLC<br />   ADC hex2bcd_vtable,Y<br />   STA hex2bcd_output,X<br />end:   INY<br />   BNE loop<br /><br />done:   LDA hex2bcd_input+0<br />   CLC<br />   ADC hex2bcd_output+7<br />   STA hex2bcd_output+7<br />   RTS<br />.endproc<br /><br />.proc   hex2bcd_16bit<br />   LDY #9<br />loop:   LDA hex2bcd_otable,Y<br />   BMI done<br />   TAX<br />   SEC<br />   LDA hex2bcd_input+0<br />   SBC hex2bcd_b0table,Y<br />   PHA<br />   LDA hex2bcd_input+1<br />   SBC hex2bcd_b1table,Y<br />   BCS okay<br />   PLA<br />   BCC end<br />okay:   STA hex2bcd_input+1<br />   PLA<br />   STA hex2bcd_input+0<br /><br />   LDA hex2bcd_output,X<br />   CLC<br />   ADC hex2bcd_vtable,Y<br />   STA hex2bcd_output,X<br />end:   INY<br />   BNE loop<br /><br />done:   LDA hex2bcd_input+0<br />   CLC<br />   ADC hex2bcd_output+7<br />   STA hex2bcd_output+7<br />   RTS<br />.endproc<br /><br />.proc   hex2bcd_8bit<br />   LDY #19<br />loop:   LDA hex2bcd_otable,Y<br />   BMI done<br />   TAX<br />   SEC<br />   LDA hex2bcd_input+0<br />   SBC hex2bcd_b0table,Y<br />   BCC end<br />okay:   STA hex2bcd_input+0<br /><br />   LDA hex2bcd_output,X<br />   CLC<br />   ADC hex2bcd_vtable,Y<br />   STA hex2bcd_output,X<br />end:   INY<br />   BNE loop<br /><br />done:   LDA hex2bcd_input+0<br />   CLC<br />   ADC hex2bcd_output+7<br />   STA hex2bcd_output+7<br />   RTS<br />.endproc<br /><br />hex2bcd_b2table:<br />.byte                                                             HEX_BYTE2&#40;10000000&#41;<br />.byte HEX_BYTE2&#40; 6000000&#41;,HEX_BYTE2&#40; 3000000&#41;,HEX_BYTE2&#40; 2000000&#41;,HEX_BYTE2&#40; 1000000&#41;<br />.byte HEX_BYTE2&#40;  600000&#41;,HEX_BYTE2&#40;  300000&#41;,HEX_BYTE2&#40;  200000&#41;,HEX_BYTE2&#40;  100000&#41;<br />.byte HEX_BYTE2&#40;   60000&#41;,HEX_BYTE2&#40;   30000&#41;,HEX_BYTE2&#40;   20000&#41;,HEX_BYTE2&#40;   10000&#41;<br />.byte HEX_BYTE2&#40;    6000&#41;,HEX_BYTE2&#40;    3000&#41;,HEX_BYTE2&#40;    2000&#41;,HEX_BYTE2&#40;    1000&#41;<br />.byte HEX_BYTE2&#40;     600&#41;,HEX_BYTE2&#40;     300&#41;,HEX_BYTE2&#40;     200&#41;,HEX_BYTE2&#40;     100&#41;<br />.byte HEX_BYTE2&#40;      60&#41;,HEX_BYTE2&#40;      30&#41;,HEX_BYTE2&#40;      20&#41;,HEX_BYTE2&#40;      10&#41;<br /><br />hex2bcd_b1table:<br />.byte                                                             HEX_BYTE1&#40;10000000&#41;<br />.byte HEX_BYTE1&#40; 6000000&#41;,HEX_BYTE1&#40; 3000000&#41;,HEX_BYTE1&#40; 2000000&#41;,HEX_BYTE1&#40; 1000000&#41;<br />.byte HEX_BYTE1&#40;  600000&#41;,HEX_BYTE1&#40;  300000&#41;,HEX_BYTE1&#40;  200000&#41;,HEX_BYTE1&#40;  100000&#41;<br />.byte HEX_BYTE1&#40;   60000&#41;,HEX_BYTE1&#40;   30000&#41;,HEX_BYTE1&#40;   20000&#41;,HEX_BYTE1&#40;   10000&#41;<br />.byte HEX_BYTE1&#40;    6000&#41;,HEX_BYTE1&#40;    3000&#41;,HEX_BYTE1&#40;    2000&#41;,HEX_BYTE1&#40;    1000&#41;<br />.byte HEX_BYTE1&#40;     600&#41;,HEX_BYTE1&#40;     300&#41;,HEX_BYTE1&#40;     200&#41;,HEX_BYTE1&#40;     100&#41;<br />.byte HEX_BYTE1&#40;      60&#41;,HEX_BYTE1&#40;      30&#41;,HEX_BYTE1&#40;      20&#41;,HEX_BYTE1&#40;      10&#41;<br /><br />hex2bcd_b0table:<br />.byte                                                             HEX_BYTE0&#40;10000000&#41;<br />.byte HEX_BYTE0&#40; 6000000&#41;,HEX_BYTE0&#40; 3000000&#41;,HEX_BYTE0&#40; 2000000&#41;,HEX_BYTE0&#40; 1000000&#41;<br />.byte HEX_BYTE0&#40;  600000&#41;,HEX_BYTE0&#40;  300000&#41;,HEX_BYTE0&#40;  200000&#41;,HEX_BYTE0&#40;  100000&#41;<br />.byte HEX_BYTE0&#40;   60000&#41;,HEX_BYTE0&#40;   30000&#41;,HEX_BYTE0&#40;   20000&#41;,HEX_BYTE0&#40;   10000&#41;<br />.byte HEX_BYTE0&#40;    6000&#41;,HEX_BYTE0&#40;    3000&#41;,HEX_BYTE0&#40;    2000&#41;,HEX_BYTE0&#40;    1000&#41;<br />.byte HEX_BYTE0&#40;     600&#41;,HEX_BYTE0&#40;     300&#41;,HEX_BYTE0&#40;     200&#41;,HEX_BYTE0&#40;     100&#41;<br />.byte HEX_BYTE0&#40;      60&#41;,HEX_BYTE0&#40;      30&#41;,HEX_BYTE0&#40;      20&#41;,HEX_BYTE0&#40;      10&#41;<br /><br />hex2bcd_otable:<br />   .byte 0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,$FF<br />hex2bcd_vtable:<br />   .byte 1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1<br /></div><br /><br />How hard do you think it would be to update your test program to test and profile these functions? When I timed the 24-bit version I got around 1500 cycles for a 5-digit number, but then I noticed that b2table was crossing a page boundary.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7">Quietust</a> — Wed Sep 13, 2006 7:23 am</p><hr />
]]></content>
</entry>
</feed>