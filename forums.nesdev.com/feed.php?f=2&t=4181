<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=4181" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2008-06-22T07:07:42-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=4181</id>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2008-06-22T07:07:42-07:00</updated>
<published>2008-06-22T07:07:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34385#p34385</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34385#p34385"/>
<title type="html"><![CDATA[My first assembly program :D]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34385#p34385"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Is directives unique to each assemblers?<br /></div><br />Yes they are completely unique to each assemblers, but some have similarities. Typically, .db is used on almost every assembler to define bytes (but some have .dcb or .dsb). You should read each assembler's docuumentation to know more. If you're going to write something complex you should read the doccumentation of every assembler and try them to see which is the one with most features, which is a never-ending debate.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Sun Jun 22, 2008 7:07 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Jarhmander]]></name></author>
<updated>2008-06-21T22:11:39-07:00</updated>
<published>2008-06-21T22:11:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34383#p34383</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34383#p34383"/>
<title type="html"><![CDATA[My first assembly program :D]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=4181&amp;p=34383#p34383"><![CDATA[
I'm proud to show here my first assembly program <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> <br /><br />I tried to find informations about NES PPU in the forums (because well I don't fully understand it) and then I found this simulator in a thread I don't remember. The online simulator can be found here : <a href="http://www.6502asm.com" class="postlink">http://www.6502asm.com</a> <br /><br />Press '0' to '9' to print digits to the screen.<br />Press 'f' to change the font color, 'b' to change the background color.<br />Press 'c' to clear the screen.<br /><br />In fact, it's only printing small 4x6 bitmaps 1-bit depth color. when pressing 'b' or 'f' it simply inc the color entry for the conresponding bit value in the bitmap, where '0' is for background and '1' is for the font. <br /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;  $8000= back color<br />;  $8001= font color<br />;  $8002= column <br />;  $8003= row<br /> <br /> <br />lda #$0<br />sta $8000   ;back=0 &#40;black&#41;<br /><br />lda #$1<br />sta $8001   ;font=1 &#40;white&#41;<br /><br />lda #0<br />sta $8002   ;column=0<br />lda #0<br />sta $8003   ;row=0<br /><br /><br />main:<br /><br />    jsr GetKey<br /><br />is_b:<br />    cmp #$62    ;key is 'b'?<br />    bne is_c<br />        inc $8000    ;inc color back<br />    jmp main<br />is_c:<br />    cmp #$63    ;key is 'c'?<br />    bne is_f<br />        jsr ClrScr   ;Clear screen<br />    jmp main<br />is_f:<br />    cmp #$66    ;key is 'f'?<br />    bne call_Putch<br />        inc $8001    ;inc color font<br />    jmp main<br />call_Putch:<br />    jsr PutCh<br />    jmp main<br /> <br /><br /> <br /><br />;-------------------------------------------<br /><br />GetKey:<br /><br />    lda #0       ;reset key read<br />    sta $ff<br /><br />while_not_kbhit:<br /><br />    lda $ff      ;read key<br />    beq while_not_kbhit<br /><br />                 ;loop if NULL<br /><br />    rts          ;leave key read in A<br /><br />;-------------------------------------------<br /><br />ClrScr:<br />    lda #2<br />    sta $11    ;HI address of screen begin<br />    lda #0<br />    sta $10    ;LO address<br />    tay<br />Next_Pts:<br />    sta &#40;$10&#41;,y<br />    inc $10    ;increment LO address<br />    bne Next_Pts<br />    inc $11    ;increment HI address<br />    lda $11<br />    cmp #6     ;if HI address==6<br />    beq exit_ClrScr  ;exit<br /><br />               <br />    tya     ; same as lda #0<br />    jmp Next_Pts<br /><br />exit_ClrScr:<br />    rts <br />;-------------------------------------------<br />PutCh:<br /><br />;  $10  = screen write<br />;  $12  = chr read index<br />;  $13  = temp mem for display<br />;  $14  = down counter for shift reg<br /><br />    sec<br />    sbc #$30       ;subtract by '0'<br /><br />    bmi Error_Exit ; if negative, <br />                   ; the ASCII value<br />                   ;is less than '0',<br />                   ; so it isn't a <br />                   ;number<br /><br />    cmp #10<br />    bmi OK_Continue<br /><br />                   ;this time, if the <br />                   ;value in accumula-<br />                   ;tor is less than<br />                   ;10, it's a number<br /><br />Error_Exit:<br /><br />    jmp exit <br /><br />OK_Continue:<br /><br />    sta $12        <br />    ldy #2    <br /><br />Multiply_chr:      ;this loop multiplies<br />                   ;by three the number.<br />                   ;this is for calcula-<br />                   ;ting the offset from<br /><br />        adc $12    ;the first bitmap.<br />        dey<br />        bne Multiply_chr<br />    sta $12<br />;<br />; Calculate the memory offset of the first pt<br />; <br /><br />    lda $8002       ;load X coord<br />    jmp while_greater_than_8<br /><br /> <br /><br />; while&#40;col&gt;=8&#41;<br />;&#123;<br />;    col-=8;<br />;    row++;<br />;&#125;<br />Subtract:<br />        sec<br />        sbc #8<br />        inc $8003   <br />while_greater_than_8:<br />        cmp #8<br />        bpl Subtract<br /><br />    sta $8002<br />    asl         ;multiply by four <br />    asl <br />    sta $10     ;the 3 LSB of address<br />                ;are now calculated<br />    lda #0<br />    sta $11     ;clear the HI address<br />                ;this is important because<br />                ;later a value will be ROL'ed<br />                ;in.<br />    lda $8003<br />    cmp #5      ;if row is greater than 4, <br />    bmi Continue;row will be set to 0<br />        lda #0<br />        sta $8003<br />Continue:<br />    clc<br />    ldy #5<br />multiply_1:     ;this loop multiplies by 6<br />                ;the row's value<br />        adc $8003<br />        dey<br />        bne multiply_1<br />    ldy #5<br />multiply_2:     ;this loop multiplies by 32 the<br />                ;previous value calculated in<br />                ;the accumulator.<br /><br />                ;since the screen is 32x32,<br />                ;and the bitmap 6 pts height,<br />                ;row*6*32 will give the <br />                ;correct memory offset for<br />                ;a vertical position.<br />        asl<br />        rol $011  ;since rol zeropage is buggy,<br />                  ;I use absolute mode instead<br />        dey<br />        bne multiply_2 <br />    ora $10<br />    sta $10<br /><br />    lda $11<br />    clc<br />    adc #2      ;add 2 to HI address so it <br />                ;effectively access screen<br />    sta $11<br /><br />;<br />; Display the bitmap<br />;   <br /><br />    ldx $12       ;x holds offset from<br />                  ;CHR_0<br />    inc $12       ;and $12 then holds the<br />                  ;offset of the next<br />                  ;caracter<br />    inc $12<br />    inc $12<br />    ldy #0<br /><br />loop_fetch_byte:<br />    lda #8<br />    sta $14       ;this memory location<br />                  ;holds the remaining<br />                  ;bit to shift<br />    lda CHR_0,x   ;load a byte of<br />                  ;bitmap <br /><br />loop_byte_scan:<br /><br />    asl <br />    sta $13       ;save accumulator for<br />                  ;later use<br />    bcs FontPoint ; if Carry=1, Font<br />                  ;else Background<br />    lda $8000     ;Load background <br />                  ;color<br />    jmp Next_Point<br /><br />FontPoint:<br />    lda $8001     ;Load Font color<br /><br />Next_Point:<br />    sta &#40;$10&#41;,y   ;store color to <br />                  ;pixel <br />    iny<br />    cpy #4      <br />    bne cccontinue<br />                  ;if y==4<br />    ldy #0        ;reset y<br />    lda $10<br />    clc<br />    adc #$20      ;and add 32 to<br />                  ;LO address, thus<br />                  ;moving down       <br />    sta $10<br />    bcc cccontinue<br />    inc $11       ;if crossing page<br />                  ;boundary ;&#41;<br /><br />cccontinue:<br />    dec $14       ;dec the bit counter<br />                  ;for shifter <br />    bne load_0x13<br />                  ;if the shifter is<br />                  ;empty              <br />    inx           ;increment offset<br />    cpx $12       ;finished?<br />    beq done      ;yes quit<br /><br />    jmp loop_fetch_byte<br /><br />load_0x13:<br />    lda $13       ;reload value to<br />                  ;shift    <br />    jmp loop_byte_scan   <br /><br />done: <br />    inc $8002     ;increment column<br /><br />exit:<br />    rts    <br /><br />;-------------------------------------------<br /> <br /><br />;characters from '0' to '9', bitmaps 1-bit 4x6 <br /><br />CHR_0:<br />     dcb $02,$55,$52<br />CHR_1:<br />     dcb $02,$62,$27<br />CHR_2:<br />     dcb $06,$13,$47<br />CHR_3:<br />     dcb $06,$12,$16<br />CHR_4:<br />     dcb $05,$57,$11<br />CHR_5:<br />     dcb $07,$47,$16<br />CHR_6:<br />     dcb $03,$47,$57<br />CHR_7:<br />     dcb $07,$12,$44<br />CHR_8:<br />     dcb $07,$57,$57<br />CHR_9:<br />     dcb $07,$57,$16</div><br /><br />Speaking of which, I proved that I know very well 6502 assembly language, but I still don't know assembler directives (like doing macros, naming memory location, etc). Is directives unique to each assemblers?<br />What are they? Maybe just put some links to read about. Thanks and thank for reading...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=336">Jarhmander</a> — Sat Jun 21, 2008 10:11 pm</p><hr />
]]></content>
</entry>
</feed>