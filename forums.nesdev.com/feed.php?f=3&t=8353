<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=3&amp;t=8353" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2011-11-28T00:17:49-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=3&amp;t=8353</id>
<entry>
<author><name><![CDATA[Overload]]></name></author>
<updated>2011-11-28T00:17:49-07:00</updated>
<published>2011-11-28T00:17:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86862#p86862</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86862#p86862"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86862#p86862"><![CDATA[
<div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><br />even though nestest.nes passes on my (indirect),Y code, i want to verify i'm not making a mistake here that the tests didn't catch. should this also be wrapped like (indirect,X)?<br /><br />i wrap when calculating the zero-page address of the indirection table, but not when i add Y at the end.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indy&#40;&#41; &#123; // &#40;indirect&#41;,Y<br />    uint16_t eahelp, eahelp2;<br />    eahelp = &#40;uint16_t&#41;read6502&#40;pc++&#41;;<br />    eahelp2 = &#40;eahelp &amp; 0xFF00&#41; | &#40;&#40;eahelp + 1&#41; &amp; 0x00FF&#41;; //zero-page wraparound<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp2&#41; &lt;&lt; 8&#41;;<br />    ea += &#40;uint16_t&#41;y;<br />&#125;<br /></div><br /></div><br /><br />That code looks correct. You don't need to transfer the upper bits from eahelp to eahelp2. <br /><br />The code below is how i would do it. This way you know that bytes read are in cycle order.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indy&#40;&#41; &#123; // &#40;indirect&#41;,Y<br />    uint8_t zp = read6502&#40;pc++&#41;;<br />    ea = &#40;unit16_t&#41; read6502&#40;&#40;unit16_t&#41; zp++&#41;;<br />    ea |= &#40;uint16_t&#41; read6502&#40;&#40;uint16_t&#41; zp&#41; &lt;&lt; 8;<br />    ea += &#40;uint16_t&#41; y;<br />&#125; <br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4882">Overload</a> — Mon Nov 28, 2011 12:17 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-24T18:34:39-07:00</updated>
<published>2011-11-24T18:34:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86774#p86774</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86774#p86774"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86774#p86774"><![CDATA[
<div class="quotetitle">Overload wrote:</div><div class="quotecontent"><br /><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent">i'm actually already doing it exactly as described in that.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indx&#40;&#41; &#123; // &#40;indirect,X&#41;<br />    uint16_t eahelp;<br />    eahelp = &#40;uint16_t&#41;&#40;&#40;&#40;uint16_t&#41;read6502&#40;pc++&#41; + &#40;uint16_t&#41;x&#41; &amp; 0xFF&#41;; //zero-page wraparound for table pointer<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp+1&#41; &lt;&lt; 8&#41;;<br />&#125;<br /></div><br /></div><br /><br />I'm pretty sure that you are not wrapping the address correctly when you pull the indirect address from the bus. eahelp should be 8 bits. <br /><br />try<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    ea = &#40;uint16_t&#41;read6502&#40;&#40;uint8_t&#41;&#40;eahelp&#41;&#41; | &#40;&#40;uint16_t&#41;read6502&#40;&#40;uint8_t&#41;&#40;eahelp+1&#41;&#41; &lt;&lt; 8&#41;; <br /></div></div><br /><br />well i'll be damned, that did work - thanks. i don't understand why it required an 8-bit cast though if i was AND-masking it by 0xFF. shouldn't that accomplish the same end result?<br /><br />EDIT: DERP nevermind, i was looking at the wrong part when i said that. thanks for the help. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />i was under the mistaken assumption that i only had to restrict the first address which points to the indirection table in the zero-page. i didn't realize i had to also wrap the final address.<br /><br /><br />even though nestest.nes passes on my (indirect),Y code, i want to verify i'm not making a mistake here that the tests didn't catch. should this also be wrapped like (indirect,X)?<br /><br />i wrap when calculating the zero-page address of the indirection table, but not when i add Y at the end.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indy&#40;&#41; &#123; // &#40;indirect&#41;,Y<br />    uint16_t eahelp, eahelp2;<br />    eahelp = &#40;uint16_t&#41;read6502&#40;pc++&#41;;<br />    eahelp2 = &#40;eahelp &amp; 0xFF00&#41; | &#40;&#40;eahelp + 1&#41; &amp; 0x00FF&#41;; //zero-page wraparound<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp2&#41; &lt;&lt; 8&#41;;<br />    ea += &#40;uint16_t&#41;y;<br />&#125;<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Thu Nov 24, 2011 6:34 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Overload]]></name></author>
<updated>2011-11-24T18:11:24-07:00</updated>
<published>2011-11-24T18:11:24-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86773#p86773</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86773#p86773"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86773#p86773"><![CDATA[
<div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><br />i'm actually already doing it exactly as described in that.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indx&#40;&#41; &#123; // &#40;indirect,X&#41;<br />    uint16_t eahelp;<br />    eahelp = &#40;uint16_t&#41;&#40;&#40;&#40;uint16_t&#41;read6502&#40;pc++&#41; + &#40;uint16_t&#41;x&#41; &amp; 0xFF&#41;; //zero-page wraparound for table pointer<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp+1&#41; &lt;&lt; 8&#41;;<br />&#125;<br /></div><br /></div><br /><br />I'm pretty sure that you are not wrapping the address correctly when you pull the indirect address from the bus. eahelp should be 8 bits. <br /><br />try<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    ea = &#40;uint16_t&#41;read6502&#40;&#40;uint8_t&#41;&#40;eahelp&#41;&#41; | &#40;&#40;uint16_t&#41;read6502&#40;&#40;uint8_t&#41;&#40;eahelp+1&#41;&#41; &lt;&lt; 8&#41;; <br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4882">Overload</a> — Thu Nov 24, 2011 6:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-24T16:27:54-07:00</updated>
<published>2011-11-24T16:27:54-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86769#p86769</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86769#p86769"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86769#p86769"><![CDATA[
well, this is interesting. STA (ind,X) passes blargg's test ROM, but nestest.nes says it doesn't work right. now i'm even more confused.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Thu Nov 24, 2011 4:27 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-24T15:58:26-07:00</updated>
<published>2011-11-24T15:58:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86764#p86764</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86764#p86764"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86764#p86764"><![CDATA[
just what i needed, Dwedit. thanks! could you just clarify what you mean by the jmp (xxxx) doesn't work right if it crosses pages though? what happens in that situation?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Thu Nov 24, 2011 3:58 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Dwedit]]></name></author>
<updated>2011-11-24T15:42:39-07:00</updated>
<published>2011-11-24T15:42:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86763#p86763</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86763#p86763"/>
<title type="html"><![CDATA[Re: 6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86763#p86763"><![CDATA[
<div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><br />my other question was simply about adding clock ticks when page boundaries are crossed. what are the cases where i would add a cycle to the total? is it just when indirect addressing mode calculations read data across a boundary, or is it also when the PC register increments past a boundary?<br /></div><br /><br />These instructions:<br />ADC<br />AND<br />CMP<br />EOR<br />LDA<br />ORA<br />SBC<br />When run in ABS,X ABS,Y or (IND),Y mode, give a one cycle penalty if it crosses a page after adding the offset.<br />STA does NOT have the penalty, it takes one cycle longer anyway.  It's kind of like it already has the penalty built in to the instruction itself.<br /><br />LDX abs,Y  and LDY abs,X  also have the penalty.<br /><br />For branches, if you crossed a page (Your destination is on a different page than the address following the branch instruction's second byte), there's a one cycle penalty.<br /><br />For jmp (xxxx), if it crosses a page, it simply doesn't work right.<br /><br />For zeropage instructions, they can only affect zeropage addresses.<br />For OP (xx),Y, it can only fetch its two bytes from the zeropage.  OP ($FF),Y will fetch the address bytes from FF and 00, then add Y.<br />For OP zpg,X instructions, it will not use any address above FF, it will wrap after that point.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=53">Dwedit</a> — Thu Nov 24, 2011 3:42 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-24T15:37:07-07:00</updated>
<published>2011-11-24T15:37:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86762#p86762</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86762#p86762"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86762#p86762"><![CDATA[
i'm actually already doing it exactly as described in that.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void indx&#40;&#41; &#123; // &#40;indirect,X&#41;<br />    uint16_t eahelp;<br />    eahelp = &#40;uint16_t&#41;&#40;&#40;&#40;uint16_t&#41;read6502&#40;pc++&#41; + &#40;uint16_t&#41;x&#41; &amp; 0xFF&#41;; //zero-page wraparound for table pointer<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp+1&#41; &lt;&lt; 8&#41;;<br />&#125;<br /></div><br /><br />that's why i'm scratching my head here. from everything i've read, that looks fine. and if you look at my STA code, it simply does <strong>putvalue(a)</strong><br /><br />where putvalue is this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void putvalue&#40;uint16_t saveval&#41; &#123;<br />    if &#40;addrtable&#91;opcode&#93; == acc&#41; a = &#40;uint8_t&#41;&#40;saveval &amp; 0x00FF&#41;;<br />        else write6502&#40;ea, &#40;saveval &amp; 0x00FF&#41;&#41;;<br />&#125;</div><br /><br />if the addressing mode is accumulator, it puts the value into the accumuilator (as you might expect) otherwise into the location specified by the effective address.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Thu Nov 24, 2011 3:37 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[MottZilla]]></name></author>
<updated>2011-11-24T15:10:51-07:00</updated>
<published>2011-11-24T15:10:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86760#p86760</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86760#p86760"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86760#p86760"><![CDATA[
I didn't study your whole code but clearly you must have an error in your Indirect X addressing mode code. <br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">9&#41; Pre-indexed indirect<br />  In this mode a zer0-page address is added to the contents of the X-register<br />  to give the address of the bytes holding the address of the operand. The<br />  indirection is indicated by parenthesis in assembly language.<br />  eg.  LDA &#40;$3E, X&#41;<br />       $A1 $3E<br />  Assume the following -        byte      value<br />                                X-reg.    $05<br />                                $0043     $15<br />                                $0044     $24<br />                                $2415     $6E<br /><br />  Then the instruction is executed by:<br />  &#40;i&#41;   adding $3E and $05 = $0043<br />  &#40;ii&#41;  getting address contained in bytes $0043, $0044 = $2415<br />  &#40;iii&#41; loading contents of $2415 - i.e. $6E - into accumulator<br /><br />  Note a&#41; When adding the 1-byte address and the X-register, wrap around<br />          addition is used - i.e. the sum is always a zero-page address.<br />          eg. FF + 2 = 0001 not 0101 as you might expect.<br />          DON'T FORGET THIS WHEN EMULATING THIS MODE.<br />       b&#41; Only the X register is used in this mode.<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=1726">MottZilla</a> — Thu Nov 24, 2011 3:10 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-23T23:15:41-07:00</updated>
<published>2011-11-23T23:15:41-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86740#p86740</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86740#p86740"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86740#p86740"><![CDATA[
ok, so yeah here's where i'm at...<br /><br /><img src="http://rubbermallet.org/moarnes-nestest3.png" alt="Image" /> <img src="http://rubbermallet.org/moarnes-nestest4.png" alt="Image" /><br /><br />(Indirect,X) test error: "059h - STA didn't store the data where it was supposed to"<br /><br />i don't understand why there's a problem here. i am just going to paste all of the CPU emu code so you can see everything in context. it's very easy to read i think.<br /><br />all of the functions for the various opcodes are in alphabetical order. functions to calculate effective addresses for the different addressing modes are near the top. opcodes start after it.<br /><br /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/* Fake6502 CPU emulator core v1.0 *******************<br /> * &#40;c&#41;2011 Mike Chambers &#40;miker00lz@gmail.com&#41;       *<br /> *****************************************************<br /> * v1.0 - First release &#40;Nov. 24, 2011&#41;              *<br /> *****************************************************<br /> * Usage:                                            *<br /> *                                                   *<br /> * Fake6502 requires you to provide two external     *<br /> * functions:                                        *<br /> *                                                   *<br /> * uint8_t read6502&#40;uint16_t address&#41;                *<br /> * void write6502&#40;uint16_t address, uint8_t value&#41;   *<br /> *                                                   *<br /> * You may optionally pass Fake6502 the pointer to a *<br /> * function which you want to be called after every  *<br /> * emulated instruction. This function should be a   *<br /> * void with no parameters expected to be passed to  *<br /> * it. This can be very useful. For example, in a    *<br /> * NES emulator, you check the number of clock ticks *<br /> * that have passed so you can know when to handle   *<br /> * APU events.                                       *<br /> *                                                   *<br /> * To pass Fake6502 this pointer, use the            *<br /> * hookexternal&#40;void *funcptr&#41; function provided.    *<br /> *                                                   *<br /> * To disable the hook later, pass NULL to it.       *<br /> *****************************************************<br /> * Useful functions in this emulator:                *<br /> *                                                   *<br /> * void reset6502&#40;&#41;                                  *<br /> *   - Call this once before you begin execution.    *<br /> *                                                   *<br /> * void exec6502&#40;uint32_t tickcount&#41;                 *<br /> *   - Execute 6502 code up to the next specified    *<br /> *     count of clock ticks.                         *<br /> *                                                   *<br /> * void irq6502&#40;&#41;                                    *<br /> *   - Trigger a hardware IRQ in the 6502 core.      *<br /> *                                                   *<br /> * void nmi6502&#40;&#41;                                    *<br /> *   - Trigger an NMI in the 6502 core.              *<br /> *                                                   *<br /> * void hookexternal&#40;void *funcptr&#41;                  *<br /> *   - Pass a pointer to a void function taking no   *<br /> *     parameters. This will cause Fake6502 to call  *<br /> *     that function once after each emulated        *<br /> *     instruction.                                  *<br /> *                                                   *<br /> *****************************************************<br /> * Useful variables in this emulator:                *<br /> *                                                   *<br /> * uint32_t clockticks6502                           *<br /> *   - A running total of the emulated cycle count.  *<br /> *                                                   *<br /> * uint32_t instructions                             *<br /> *   - A running total of the total emulated         *<br /> *     instruction count. This is not related to     *<br /> *     clock cycle timing.                           *<br /> *                                                   *<br /> *****************************************************/<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;stdint.h&gt;<br /><br />//6502 defines<br />#define UNDOCUMENTED //when this is defined, undocumented opcodes are handled.<br />                     //otherwise, they're simply treated as NOPs.<br /><br />#define NES_CPU      //when this is defined, the binary-coded decimal &#40;BCD&#41;<br />                     //status flag is not honored by ADC and SBC. the 2A03<br />                     //CPU in the Nintendo Entertainment System does not<br />                     //support BCD operation.<br /><br />#define FLAG_CARRY     0x01<br />#define FLAG_ZERO      0x02<br />#define FLAG_INTERRUPT 0x04<br />#define FLAG_DECIMAL   0x08<br />#define FLAG_BREAK     0x10<br />#define FLAG_CONSTANT  0x20<br />#define FLAG_OVERFLOW  0x40<br />#define FLAG_SIGN      0x80<br /><br />#define BASE_STACK     0x100<br /><br />//flag modifier macros<br />#define setcarry&#40;&#41; status |= FLAG_CARRY<br />#define clearcarry&#40;&#41; status &amp;= &#40;~FLAG_CARRY&#41;<br />#define setzero&#40;&#41; status |= FLAG_ZERO<br />#define clearzero&#40;&#41; status &amp;= &#40;~FLAG_ZERO&#41;<br />#define setinterrupt&#40;&#41; status |= FLAG_INTERRUPT<br />#define clearinterrupt&#40;&#41; status &amp;= &#40;~FLAG_INTERRUPT&#41;<br />#define setdecimal&#40;&#41; status |= FLAG_DECIMAL<br />#define cleardecimal&#40;&#41; status &amp;= &#40;~FLAG_DECIMAL&#41;<br />#define setbreak&#40;&#41; status |= FLAG_BREAK<br />#define clearbreak&#40;&#41; status &amp;= &#40;~FLAG_BREAK&#41;<br />#define setoverflow&#40;&#41; status |= FLAG_OVERFLOW<br />#define clearoverflow&#40;&#41; status &amp;= &#40;~FLAG_OVERFLOW&#41;<br />#define setsign&#40;&#41; status |= FLAG_SIGN<br />#define clearsign&#40;&#41; status &amp;= &#40;~FLAG_SIGN&#41;<br /><br /><br />//6502 CPU registers<br />uint16_t pc;<br />uint8_t sp, a, x, y, status;<br /><br /><br />//helper variables<br />uint32_t instructions = 0; //keep track of total instructions executed<br />uint32_t clockticks6502 = 0, clockgoal6502 = 0;<br />uint16_t oldpc, ea, reladdr, value, result;<br />uint8_t opcode, oldstatus;<br /><br />//externally supplied functions<br />extern uint8_t read6502&#40;uint16_t address&#41;;<br />extern void write6502&#40;uint16_t address, uint8_t value&#41;;<br /><br />//a few general functions used by various other functions<br />void push16&#40;uint16_t pushval&#41; &#123;<br />    write6502&#40;BASE_STACK + sp, &#40;pushval &gt;&gt; 8&#41; &amp; 0xFF&#41;;<br />    write6502&#40;BASE_STACK + &#40;&#40;sp - 1&#41; &amp; 0xFF&#41;, pushval &amp; 0xFF&#41;;<br />    sp -= 2;<br />&#125;<br /><br />void push8&#40;uint8_t pushval&#41; &#123;<br />    write6502&#40;BASE_STACK + sp--, pushval&#41;;<br />&#125;<br /><br />uint16_t pull16&#40;&#41; &#123;<br />    uint16_t temp16;<br />    temp16 = read6502&#40;BASE_STACK + &#40;&#40;sp + 1&#41; &amp; 0xFF&#41;&#41; | &#40;&#40;uint16_t&#41;read6502&#40;BASE_STACK + &#40;&#40;sp + 2&#41; &amp; 0xFF&#41;&#41; &lt;&lt; 8&#41;;<br />    sp += 2;<br />    return&#40;temp16&#41;;<br />&#125;<br /><br />uint8_t pull8&#40;&#41; &#123;<br />    return &#40;read6502&#40;BASE_STACK + ++sp&#41;&#41;;<br />&#125;<br /><br />void reset6502&#40;&#41; &#123;<br />    pc = &#40;uint16_t&#41;read6502&#40;0xFFFC&#41; | &#40;&#40;uint16_t&#41;read6502&#40;0xFFFD&#41; &lt;&lt; 8&#41;;<br />    a = 0;<br />    x = 0;<br />    y = 0;<br />    sp = 0xFD;<br />    status |= FLAG_CONSTANT;<br />&#125;<br /><br /><br />//addressing mode functions, calculates effective addresses<br />static void imp&#40;&#41; &#123; //implied<br />&#125;<br /><br />static void acc&#40;&#41; &#123; //accumulator<br />&#125;<br /><br />static void imm&#40;&#41; &#123; //immediate<br />    ea = pc++;<br />&#125;<br /><br />static void zp&#40;&#41; &#123; //zero-page<br />    ea = &#40;uint16_t&#41;read6502&#40;&#40;uint16_t&#41;pc++&#41;;<br />&#125;<br /><br />static void zpx&#40;&#41; &#123; //zero-page,X<br />    ea = &#40;&#40;uint16_t&#41;read6502&#40;&#40;uint16_t&#41;pc++&#41; + &#40;uint16_t&#41;x&#41; &amp; 0xFF; //zero-page wraparound<br />&#125;<br /><br />static void zpy&#40;&#41; &#123; //zero-page,Y<br />    ea = &#40;&#40;uint16_t&#41;read6502&#40;&#40;uint16_t&#41;pc++&#41; + &#40;uint16_t&#41;y&#41; &amp; 0xFF; //zero-page wraparound<br />&#125;<br /><br />static void rel&#40;&#41; &#123; //relative for branch ops &#40;8-bit immediate value, sign-extended&#41;<br />    reladdr = &#40;uint16_t&#41;read6502&#40;pc++&#41;;<br />    if &#40;reladdr &amp; 0x80&#41; reladdr |= 0xFF00;<br />&#125;<br /><br />static void abso&#40;&#41; &#123; //absolute<br />    ea = &#40;uint16_t&#41;read6502&#40;pc&#41; | &#40;&#40;uint16_t&#41;read6502&#40;pc+1&#41; &lt;&lt; 8&#41;;<br />    pc += 2;<br />&#125;<br /><br />static void absx&#40;&#41; &#123; //absolute,X<br />    ea = &#40;&#40;uint16_t&#41;read6502&#40;pc&#41; | &#40;&#40;uint16_t&#41;read6502&#40;pc+1&#41; &lt;&lt; 8&#41;&#41; + &#40;uint16_t&#41;x;<br />    pc += 2;<br />&#125;<br /><br />static void absy&#40;&#41; &#123; //absolute,Y<br />    ea = &#40;&#40;uint16_t&#41;read6502&#40;pc&#41; | &#40;&#40;uint16_t&#41;read6502&#40;pc+1&#41; &lt;&lt; 8&#41;&#41; + &#40;uint16_t&#41;y;<br />    pc += 2;<br />&#125;<br /><br />static void ind&#40;&#41; &#123; //indirect<br />    uint16_t eahelp, eahelp2;<br />    eahelp = &#40;uint16_t&#41;read6502&#40;pc&#41; | &#40;uint16_t&#41;&#40;&#40;uint16_t&#41;read6502&#40;pc+1&#41; &lt;&lt; 8&#41;;<br />    eahelp2 = &#40;eahelp &amp; 0xFF00&#41; | &#40;&#40;eahelp + 1&#41; &amp; 0x00FF&#41;; //replicate 6502 page-boundary wraparound bug<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp2&#41; &lt;&lt; 8&#41;;<br />    pc += 2;<br />&#125;<br /><br />static void indx&#40;&#41; &#123; // &#40;indirect,X&#41;<br />    uint16_t eahelp;<br />    eahelp = &#40;uint16_t&#41;&#40;&#40;&#40;uint16_t&#41;read6502&#40;pc++&#41; + &#40;uint16_t&#41;x&#41; &amp; 0xFF&#41;; //zero-page wraparound for table pointer<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp+1&#41; &lt;&lt; 8&#41;;<br />&#125;<br /><br />static void indy&#40;&#41; &#123; // &#40;indirect&#41;,Y<br />    uint16_t eahelp, eahelp2;<br />    eahelp = &#40;uint16_t&#41;read6502&#40;pc++&#41;;<br />    eahelp2 = &#40;eahelp &amp; 0xFF00&#41; | &#40;&#40;eahelp + 1&#41; &amp; 0x00FF&#41;; //zero-page wraparound<br />    ea = &#40;uint16_t&#41;read6502&#40;eahelp&#41; | &#40;&#40;uint16_t&#41;read6502&#40;eahelp2&#41; &lt;&lt; 8&#41;;<br />    ea += &#40;uint16_t&#41;y;<br />&#125;<br /><br />static void &#40;*addrtable&#91;256&#93;&#41;&#40;&#41;;<br />static uint16_t getvalue&#40;&#41; &#123;<br />    if &#40;addrtable&#91;opcode&#93; == acc&#41; return&#40;&#40;uint16_t&#41;a&#41;;<br />        else return&#40;&#40;uint16_t&#41;read6502&#40;ea&#41;&#41;;<br />&#125;<br /><br />static uint16_t getvalue16&#40;&#41; &#123;<br />    return&#40;&#40;uint16_t&#41;read6502&#40;ea&#41; | &#40;&#40;uint16_t&#41;read6502&#40;ea+1&#41; &lt;&lt; 8&#41;&#41;;<br />&#125;<br /><br />static void putvalue&#40;uint16_t saveval&#41; &#123;<br />    if &#40;addrtable&#91;opcode&#93; == acc&#41; a = &#40;uint8_t&#41;&#40;saveval &amp; 0x00FF&#41;;<br />        else write6502&#40;ea, &#40;saveval &amp; 0x00FF&#41;&#41;;<br />&#125;<br /><br />#define zerocalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0x00FF&#41; clearzero&#40;&#41;;\<br />        else setzero&#40;&#41;;\<br />&#125;<br /><br />#define signcalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0x0080&#41; setsign&#40;&#41;;\<br />        else clearsign&#40;&#41;;\<br />&#125;<br /><br />#define carrycalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0xFF00&#41; setcarry&#40;&#41;;\<br />        else clearcarry&#40;&#41;;\<br />&#125;<br /><br />#define overflowcalc&#40;n, m, o&#41; &#123; /* n = result, m = accumulator, o = memory */ \<br />    if &#40;&#40;&#40;n&#41; ^ &#40;uint16_t&#41;&#40;m&#41;&#41; &amp; &#40;&#40;n&#41; ^ &#40;o&#41;&#41; &amp; 0x0080&#41; setoverflow&#40;&#41;;\<br />        else clearoverflow&#40;&#41;;\<br />&#125;<br /><br />#define saveaccum&#40;n&#41; a = &#40;uint8_t&#41;&#40;&#40;n&#41; &amp; 0x00FF&#41;<br /><br /><br />//instruction handler functions<br />static void adc&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a + value + &#40;uint16_t&#41;&#40;status &amp; FLAG_CARRY&#41;;<br />   <br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    overflowcalc&#40;result, a, value&#41;;<br />    signcalc&#40;result&#41;;<br />    <br />    #ifndef NES_CPU<br />    if &#40;status &amp; FLAG_DECIMAL&#41; &#123;<br />        clearcarry&#40;&#41;;<br />        <br />        if &#40;&#40;a &amp; 0x0F&#41; &gt; 0x09&#41; &#123;<br />            a += 0x06;<br />        &#125;<br />        if &#40;&#40;a &amp; 0xF0&#41; &gt; 0x90&#41; &#123;<br />            a += 0x60;<br />            setcarry&#40;&#41;;<br />        &#125;<br />        <br />        clockticks6502++;<br />    &#125;<br />    #endif<br />   <br />    saveaccum&#40;result&#41;;<br />&#125;<br /><br />static void and&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a &amp; value;<br />   <br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    saveaccum&#40;result&#41;;<br />&#125;<br /><br />static void asl&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = value &lt;&lt; 1;<br /><br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void bcc&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_CARRY&#41; == 0&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void bcs&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_CARRY&#41; == FLAG_CARRY&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void beq&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_ZERO&#41; == FLAG_ZERO&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void bit&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a &amp; value;<br />   <br />    zerocalc&#40;result&#41;;<br />    status = &#40;status &amp; 0xBF&#41; | &#40;uint8_t&#41;&#40;value &amp; 0xC0&#41;;<br />&#125;<br /><br />static void bmi&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_SIGN&#41; == FLAG_SIGN&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void bne&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_ZERO&#41; == 0&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void bpl&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_SIGN&#41; == 0&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void brk&#40;&#41; &#123;<br />    pc++;<br />    push16&#40;pc&#41;; //push next instruction address onto stack<br />    setbreak&#40;&#41;; //set break flag<br />    push8&#40;status&#41;; //push CPU status to stack<br />    setinterrupt&#40;&#41;; //set interrupt flag<br />    pc = &#40;uint16_t&#41;read6502&#40;0xFFFE&#41; | &#40;&#40;uint16_t&#41;read6502&#40;0xFFFF&#41; &lt;&lt; 8&#41;;<br />&#125;<br /><br />static void bvc&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_OVERFLOW&#41; == 0&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void bvs&#40;&#41; &#123;<br />    if &#40;&#40;status &amp; FLAG_OVERFLOW&#41; == FLAG_OVERFLOW&#41; &#123;<br />        oldpc = pc;<br />        pc += reladdr;<br />        if &#40;&#40;oldpc &amp; 0xFF00&#41; != &#40;pc &amp; 0xFF00&#41;&#41; clockticks6502 += 2; //check if jump crossed a page boundary<br />            else clockticks6502++;<br />    &#125;<br />&#125;<br /><br />static void clc&#40;&#41; &#123;<br />    clearcarry&#40;&#41;;<br />&#125;<br /><br />static void cld&#40;&#41; &#123;<br />    cleardecimal&#40;&#41;;<br />&#125;<br /><br />static void cli&#40;&#41; &#123;<br />    clearinterrupt&#40;&#41;;<br />&#125;<br /><br />static void clv&#40;&#41; &#123;<br />    clearoverflow&#40;&#41;;<br />&#125;<br /><br />static void cmp&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a - value;<br />   <br />    if &#40;a &gt;= &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setcarry&#40;&#41;;<br />        else clearcarry&#40;&#41;;<br />    if &#40;a == &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setzero&#40;&#41;;<br />        else clearzero&#40;&#41;;<br />    signcalc&#40;result&#41;;<br />&#125;<br /><br />static void cpx&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;x - value;<br />   <br />    if &#40;x &gt;= &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setcarry&#40;&#41;;<br />        else clearcarry&#40;&#41;;<br />    if &#40;x == &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setzero&#40;&#41;;<br />        else clearzero&#40;&#41;;<br />    signcalc&#40;result&#41;;<br />&#125;<br /><br />static void cpy&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;y - value;<br />   <br />    if &#40;y &gt;= &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setcarry&#40;&#41;;<br />        else clearcarry&#40;&#41;;<br />    if &#40;y == &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;&#41; setzero&#40;&#41;;<br />        else clearzero&#40;&#41;;<br />    signcalc&#40;result&#41;;<br />&#125;<br /><br />static void dec&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = value - 1;<br />   <br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void dex&#40;&#41; &#123;<br />    x--;<br />   <br />    zerocalc&#40;x&#41;;<br />    signcalc&#40;x&#41;;<br />&#125;<br /><br />static void dey&#40;&#41; &#123;<br />    y--;<br />   <br />    zerocalc&#40;y&#41;;<br />    signcalc&#40;y&#41;;<br />&#125;<br /><br />static void eor&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a ^ value;<br />   <br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    saveaccum&#40;result&#41;;<br />&#125;<br /><br />static void inc&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = value + 1;<br />   <br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void inx&#40;&#41; &#123;<br />    x++;<br />   <br />    zerocalc&#40;x&#41;;<br />    signcalc&#40;x&#41;;<br />&#125;<br /><br />static void iny&#40;&#41; &#123;<br />    y++;<br />   <br />    zerocalc&#40;y&#41;;<br />    signcalc&#40;y&#41;;<br />&#125;<br /><br />static void jmp&#40;&#41; &#123;<br />    pc = ea;<br />&#125;<br /><br />static void jsr&#40;&#41; &#123;<br />    push16&#40;pc - 1&#41;;<br />    pc = ea;<br />&#125;<br /><br />static void lda&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    a = &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;;<br />   <br />    zerocalc&#40;a&#41;;<br />    signcalc&#40;a&#41;;<br />&#125;<br /><br />static void ldx&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    x = &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;;<br />   <br />    zerocalc&#40;x&#41;;<br />    signcalc&#40;x&#41;;<br />&#125;<br /><br />static void ldy&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    y = &#40;uint8_t&#41;&#40;value &amp; 0x00FF&#41;;<br />   <br />    zerocalc&#40;y&#41;;<br />    signcalc&#40;y&#41;;<br />&#125;<br /><br />static void lsr&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = value &gt;&gt; 1;<br />   <br />    if &#40;value &amp; 1&#41; setcarry&#40;&#41;;<br />        else clearcarry&#40;&#41;;<br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void nop&#40;&#41; &#123;<br />&#125;<br /><br />static void ora&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;uint16_t&#41;a | value;<br />   <br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    saveaccum&#40;result&#41;;<br />&#125;<br /><br />static void pha&#40;&#41; &#123;<br />    push8&#40;a&#41;;<br />&#125;<br /><br />static void php&#40;&#41; &#123;<br />    push8&#40;status&#41;;<br />&#125;<br /><br />static void pla&#40;&#41; &#123;<br />    a = pull8&#40;&#41;;<br />   <br />    zerocalc&#40;a&#41;;<br />    signcalc&#40;a&#41;;<br />&#125;<br /><br />static void plp&#40;&#41; &#123;<br />    status = pull8&#40;&#41; | FLAG_CONSTANT;<br />&#125;<br /><br />static void rol&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;value &lt;&lt; 1&#41; | &#40;status &amp; FLAG_CARRY&#41;;<br />   <br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void ror&#40;&#41; &#123;<br />    value = getvalue&#40;&#41;;<br />    result = &#40;value &gt;&gt; 1&#41; | &#40;&#40;status &amp; FLAG_CARRY&#41; &lt;&lt; 7&#41;;<br />   <br />    if &#40;value &amp; 1&#41; setcarry&#40;&#41;;<br />        else clearcarry&#40;&#41;;<br />    zerocalc&#40;result&#41;;<br />    signcalc&#40;result&#41;;<br />   <br />    putvalue&#40;result&#41;;<br />&#125;<br /><br />static void rti&#40;&#41; &#123;<br />    status = pull8&#40;&#41;;<br />    value = pull16&#40;&#41;;<br />    pc = value;<br />&#125;<br /><br />static void rts&#40;&#41; &#123;<br />    value = pull16&#40;&#41;;<br />    pc = value + 1;<br />&#125;<br /><br />static void sbc&#40;&#41; &#123;<br />    value = getvalue&#40;&#41; ^ 0x00FF;<br />    result = &#40;uint16_t&#41;a + value + &#40;uint16_t&#41;&#40;status &amp; FLAG_CARRY&#41;;<br />   <br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    overflowcalc&#40;result, a, value&#41;;<br />    signcalc&#40;result&#41;;<br /><br />    #ifndef NES_CPU<br />    if &#40;status &amp; FLAG_DECIMAL&#41; &#123;<br />        clearcarry&#40;&#41;;<br />        <br />        a -= 0x66;<br />        if &#40;&#40;a &amp; 0x0F&#41; &gt; 0x09&#41; &#123;<br />            a += 0x06;<br />        &#125;<br />        if &#40;&#40;a &amp; 0xF0&#41; &gt; 0x90&#41; &#123;<br />            a += 0x60;<br />            setcarry&#40;&#41;;<br />        &#125;<br />        <br />        clockticks6502++;<br />    &#125;<br />    #endif<br />   <br />    saveaccum&#40;result&#41;;<br />&#125;<br /><br />static void sec&#40;&#41; &#123;<br />    setcarry&#40;&#41;;<br />&#125;<br /><br />static void sed&#40;&#41; &#123;<br />    setdecimal&#40;&#41;;<br />&#125;<br /><br />static void sei&#40;&#41; &#123;<br />    setinterrupt&#40;&#41;;<br />&#125;<br /><br />static void sta&#40;&#41; &#123;<br />    putvalue&#40;a&#41;;<br />&#125;<br /><br />static void stx&#40;&#41; &#123;<br />    putvalue&#40;x&#41;;<br />&#125;<br /><br />static void sty&#40;&#41; &#123;<br />    putvalue&#40;y&#41;;<br />&#125;<br /><br />static void tax&#40;&#41; &#123;<br />    x = a;<br />   <br />    zerocalc&#40;x&#41;;<br />    signcalc&#40;x&#41;;<br />&#125;<br /><br />static void tay&#40;&#41; &#123;<br />    y = a;<br />   <br />    zerocalc&#40;y&#41;;<br />    signcalc&#40;y&#41;;<br />&#125;<br /><br />static void tsx&#40;&#41; &#123;<br />    x = sp;<br />   <br />    zerocalc&#40;x&#41;;<br />    signcalc&#40;x&#41;;<br />&#125;<br /><br />static void txa&#40;&#41; &#123;<br />    a = x;<br />   <br />    zerocalc&#40;a&#41;;<br />    signcalc&#40;a&#41;;<br />&#125;<br /><br />static void txs&#40;&#41; &#123;<br />    sp = x;<br />&#125;<br /><br />static void tya&#40;&#41; &#123;<br />    a = y;<br />   <br />    zerocalc&#40;a&#41;;<br />    signcalc&#40;a&#41;;<br />&#125;<br /><br />//undocumented instructions<br />#ifdef UNDOCUMENTED<br />    static void lax&#40;&#41; &#123;<br />        lda&#40;&#41;;<br />        ldx&#40;&#41;;<br />    &#125;<br /><br />    static void sax&#40;&#41; &#123;<br />        sta&#40;&#41;;<br />        stx&#40;&#41;;<br />        putvalue&#40;a &amp; x&#41;;<br />    &#125;<br /><br />    static void dcp&#40;&#41; &#123;<br />        dec&#40;&#41;;<br />        cmp&#40;&#41;;<br />    &#125;<br /><br />    static void isb&#40;&#41; &#123;<br />        inc&#40;&#41;;<br />        sbc&#40;&#41;;<br />    &#125;<br /><br />    static void slo&#40;&#41; &#123;<br />        asl&#40;&#41;;<br />        ora&#40;&#41;;<br />    &#125;<br /><br />    static void rla&#40;&#41; &#123;<br />        rol&#40;&#41;;<br />        and&#40;&#41;;<br />    &#125;<br /><br />    static void sre&#40;&#41; &#123;<br />        lsr&#40;&#41;;<br />        eor&#40;&#41;;<br />    &#125;<br /><br />    static void rra&#40;&#41; &#123;<br />        ror&#40;&#41;;<br />        adc&#40;&#41;;<br />    &#125;<br />#else<br />    #define lax nop<br />    #define sax nop<br />    #define dcp nop<br />    #define isb nop<br />    #define slo nop<br />    #define rla nop<br />    #define sre nop<br />    #define rra nop<br />#endif<br /><br /><br />static void &#40;*addrtable&#91;256&#93;&#41;&#40;&#41; = &#123;<br />/*        |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  |     */<br />/* 0 */     imp, indx,  imp, indx,   zp,   zp,   zp,   zp,  imp,  imm,  acc,  imm, abso, abso, abso, abso, /* 0 */<br />/* 1 */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx, /* 1 */<br />/* 2 */    abso, indx,  imp, indx,   zp,   zp,   zp,   zp,  imp,  imm,  acc,  imm, abso, abso, abso, abso, /* 2 */<br />/* 3 */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx, /* 3 */<br />/* 4 */     imp, indx,  imp, indx,   zp,   zp,   zp,   zp,  imp,  imm,  acc,  imm, abso, abso, abso, abso, /* 4 */<br />/* 5 */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx, /* 5 */<br />/* 6 */     imp, indx,  imp, indx,   zp,   zp,   zp,   zp,  imp,  imm,  acc,  imm,  ind, abso, abso, abso, /* 6 */<br />/* 7 */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx, /* 7 */<br />/* 8 */     imm, indx,  imm, indx,   zp,   zp,   zp,   zp,  imp,  imm,  imp,  imm, abso, abso, abso, abso, /* 8 */<br />/* 9 */     rel, indy,  imp, indy,  zpx,  zpx,  zpy,  zpy,  imp, absy,  imp, absy, absx, absx, absy, absy, /* 9 */<br />/* A */     imm, indx,  imm, indx,   zp,   zp,   zp,   zp,  imp,  imm,  imp,  imm, abso, abso, abso, abso, /* A */<br />/* B */     rel, indy,  imp, indy,  zpx,  zpx,  zpy,  zpy,  imp, absy,  imp, absy, absx, absx, absy, absy, /* B */<br />/* C */     imm, indx,  imm, indx,   zp,   zp,   zp,   zp,  imp,  imm,  imp,  imm, abso, abso, abso, abso, /* C */<br />/* D */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx, /* D */<br />/* E */     imm, indx,  imm, indx,   zp,   zp,   zp,   zp,  imp,  imm,  imp,  imm, abso, abso, abso, abso, /* E */<br />/* F */     rel, indy,  imp, indy,  zpx,  zpx,  zpx,  zpx,  imp, absy,  imp, absy, absx, absx, absx, absx  /* F */<br />&#125;;<br /><br />static void &#40;*optable&#91;256&#93;&#41;&#40;&#41; = &#123;<br />/*        |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  |      */<br />/* 0 */      brk,  ora,  nop,  slo,  nop,  ora,  asl,  slo,  php,  ora,  asl,  nop,  nop,  ora,  asl,  slo, /* 0 */<br />/* 1 */      bpl,  ora,  nop,  slo,  nop,  ora,  asl,  slo,  clc,  ora,  nop,  slo,  nop,  ora,  asl,  slo, /* 1 */<br />/* 2 */      jsr,  and,  nop,  rla,  bit,  and,  rol,  rla,  plp,  and,  rol,  nop,  bit,  and,  rol,  rla, /* 2 */<br />/* 3 */      bmi,  and,  nop,  rla,  nop,  and,  rol,  rla,  sec,  and,  nop,  rla,  nop,  and,  rol,  rla, /* 3 */<br />/* 4 */      rti,  eor,  nop,  sre,  nop,  eor,  lsr,  sre,  pha,  eor,  lsr,  nop,  jmp,  eor,  lsr,  sre, /* 4 */<br />/* 5 */      bvc,  eor,  nop,  sre,  nop,  eor,  lsr,  sre,  cli,  eor,  nop,  sre,  nop,  eor,  lsr,  sre, /* 5 */<br />/* 6 */      rts,  adc,  nop,  rra,  nop,  adc,  ror,  rra,  pla,  adc,  ror,  nop,  jmp,  adc,  ror,  rra, /* 6 */<br />/* 7 */      bvs,  adc,  nop,  rra,  nop,  adc,  ror,  rra,  sei,  adc,  nop,  rra,  nop,  adc,  ror,  rra, /* 7 */<br />/* 8 */      nop,  sta,  nop,  sax,  sty,  sta,  stx,  sax,  dey,  nop,  txa,  nop,  sty,  sta,  stx,  sax, /* 8 */<br />/* 9 */      bcc,  sta,  nop,  nop,  sty,  sta,  stx,  sax,  tya,  sta,  txs,  nop,  nop,  sta,  nop,  nop, /* 9 */<br />/* A */      ldy,  lda,  ldx,  lax,  ldy,  lda,  ldx,  lax,  tay,  lda,  tax,  nop,  ldy,  lda,  ldx,  lax, /* A */<br />/* B */      bcs,  lda,  nop,  lax,  ldy,  lda,  ldx,  lax,  clv,  lda,  tsx,  nop,  ldy,  lda,  ldx,  lax, /* B */<br />/* C */      cpy,  cmp,  nop,  dcp,  cpy,  cmp,  dec,  dcp,  iny,  cmp,  dex,  nop,  cpy,  cmp,  dec,  dcp, /* C */<br />/* D */      bne,  cmp,  nop,  dcp,  nop,  cmp,  dec,  dcp,  cld,  cmp,  nop,  dcp,  nop,  cmp,  dec,  dcp, /* D */<br />/* E */      cpx,  sbc,  nop,  isb,  cpx,  sbc,  inc,  isb,  inx,  sbc,  nop,  sbc,  cpx,  sbc,  inc,  isb, /* E */<br />/* F */      beq,  sbc,  nop,  isb,  nop,  sbc,  inc,  isb,  sed,  sbc,  nop,  isb,  nop,  sbc,  inc,  isb  /* F */<br />&#125;;<br /><br />static const uint32_t ticktable&#91;256&#93; = &#123;<br />/*        |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  |     */<br />/* 0 */      7,    6,    2,    8,    3,    3,    5,    5,    3,    2,    2,    2,    4,    4,    6,    6,  /* 0 */<br />/* 1 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7,  /* 1 */<br />/* 2 */      6,    6,    2,    8,    3,    3,    5,    5,    4,    2,    2,    2,    4,    4,    6,    6,  /* 2 */<br />/* 3 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7,  /* 3 */<br />/* 4 */      6,    6,    2,    8,    3,    3,    5,    5,    3,    2,    2,    2,    3,    4,    6,    6,  /* 4 */<br />/* 5 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7,  /* 5 */<br />/* 6 */      6,    6,    2,    8,    3,    3,    5,    5,    4,    2,    2,    2,    5,    4,    6,    6,  /* 6 */<br />/* 7 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7,  /* 7 */<br />/* 8 */      2,    6,    2,    6,    3,    3,    3,    3,    2,    2,    2,    2,    4,    4,    4,    4,  /* 8 */<br />/* 9 */      2,    6,    2,    6,    4,    4,    4,    4,    2,    5,    2,    5,    5,    5,    5,    5,  /* 9 */<br />/* A */      2,    6,    2,    6,    3,    3,    3,    3,    2,    2,    2,    2,    4,    4,    4,    4,  /* A */<br />/* B */      2,    5,    2,    5,    4,    4,    4,    4,    2,    4,    2,    5,    4,    4,    4,    4,  /* B */<br />/* C */      2,    6,    2,    8,    3,    3,    5,    5,    2,    2,    2,    2,    4,    4,    6,    6,  /* C */<br />/* D */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7,  /* D */<br />/* E */      2,    6,    2,    8,    3,    3,    5,    5,    2,    2,    2,    2,    4,    4,    6,    6,  /* E */<br />/* F */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    5,    5,    7,    7   /* F */<br />&#125;;<br /><br /><br />void nmi6502&#40;&#41; &#123;<br />    push16&#40;pc&#41;;<br />    push8&#40;status&#41;;<br />    status |= FLAG_INTERRUPT;<br />    pc = &#40;uint16_t&#41;read6502&#40;0xFFFA&#41; | &#40;&#40;uint16_t&#41;read6502&#40;0xFFFB&#41; &lt;&lt; 8&#41;;<br />&#125;<br /><br />void irq6502&#40;&#41; &#123;<br />    push16&#40;pc&#41;;<br />    push8&#40;status&#41;;<br />    status |= FLAG_INTERRUPT;<br />    pc = &#40;uint16_t&#41;read6502&#40;0xFFFE&#41; | &#40;&#40;uint16_t&#41;read6502&#40;0xFFFF&#41; &lt;&lt; 8&#41;;<br />&#125;<br /><br />//can use loopexternal to call an external function after every instruction.<br />//use hookexternal&#40;void *funcptr&#41; function to pass a pointer to one.<br />//pass NULL to hookexternal to disable.<br />uint8_t callexternal = 0;<br />void &#40;*loopexternal&#41;&#40;&#41;;<br /><br />void exec6502&#40;uint32_t tickcount&#41; &#123;<br />    clockgoal6502 += tickcount;<br />    static uint16_t lastpc;<br />   <br />    while &#40;clockticks6502 &lt; clockgoal6502&#41; &#123;<br />        opcode = read6502&#40;pc++&#41;;<br />        lastpc = pc;<br />        status |= FLAG_CONSTANT;<br />       <br />        &#40;*addrtable&#91;opcode&#93;&#41;&#40;&#41;;<br />        &#40;*optable&#91;opcode&#93;&#41;&#40;&#41;;<br />        clockticks6502 += ticktable&#91;opcode&#93;;<br />       <br />        instructions++;<br /><br />        if &#40;callexternal&#41; &#40;*loopexternal&#41;&#40;&#41;;<br />    &#125;<br /><br />&#125;<br /><br />void hookexternal&#40;void *funcptr&#41; &#123;<br />    if &#40;funcptr != &#40;void *&#41;NULL&#41; &#123;<br />        loopexternal = funcptr;<br />        callexternal = 1;<br />    &#125; else callexternal = 0;<br />&#125;<br /></div><br /><br />i know doing all the addressing calcs and instructions as functions from a pointer table isn't the most efficient, but it's just a NES.  it benchmarks around 40-45 million instructions per second on most game ROMs with no speed limiting on my Phenom II X4 955. it's fast enough.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Wed Nov 23, 2011 11:15 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-23T17:57:38-07:00</updated>
<published>2011-11-23T17:57:38-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86732#p86732</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86732#p86732"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86732#p86732"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />If ADC works perfectly, then you can implement SBC by copying your ADC code and then just XORing the byte retrieved from memory with 0xFF. May I see your ADC code?<br /></div><br /><br />ah, yeah that makes sense! that worked! this is my ADC:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void *adc&#40;&#41; &#123;<br />    value = &#40;uint16_t&#41;read6502&#40;ea&#41;;<br />    result = &#40;uint16_t&#41;a + value + &#40;uint16_t&#41;&#40;status &amp; FLAG_CARRY&#41;;<br />    <br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    overflowcalc&#40;result, a, value&#41;;<br />    signcalc&#40;result&#41;;<br />    <br />    saveaccum&#40;result&#41;;<br />&#125;<br /></div><br /><br />now SBC works fine, but i'm getting one error still on the nestest.nes ROM. i get error $59 on the "(indirect,X)" tests, which translates to:<br /><br />"059h - STA didn't store the data where it was supposed to"<br /><br />other than that, all seems well.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Wed Nov 23, 2011 5:57 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2011-11-23T17:37:42-07:00</updated>
<published>2011-11-23T17:37:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86730#p86730</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86730#p86730"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86730#p86730"><![CDATA[
If ADC works perfectly, then you can implement SBC by copying your ADC code and then just XORing the byte retrieved from memory with 0xFF. May I see your ADC code?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Wed Nov 23, 2011 5:37 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2011-11-23T17:06:51-07:00</updated>
<published>2011-11-23T17:06:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86725#p86725</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86725#p86725"/>
<title type="html"><![CDATA[6502 CPU emu SBC bug, and question about page-crossing]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=8353&amp;p=86725#p86725"><![CDATA[
hi, all. over the last couple days i decided to remove Neil Bradley's 6502 core out of my NES emulator, because it's always bugged me that i didn't write one myself for it. (plus his had a few small bugs)<br /><br />so, anyway i've been writing it, and it's coming along great - BUT, for some reason everything involving SBC fails in nestest.nes - i am also supporting all undocumented opcodes possible, and those that need SBC also fail the test.<br /><br /><br /><br />screenshot of my 6502 core running the main tests:<br /><br /><img src="http://rubbermallet.org/moarnes-nestest1.png" alt="Image" /><br /><br /><br />and the undocumented tests:<br /><br /><img src="http://rubbermallet.org/moarnes-nestest2.png" alt="Image" /><br /><br /><br /><br />according to the documentation for nestest.nes, all of those error codes on the main tests indicate "SBC failure", and the two undocumented ones that fail use SBC. so, clearly something is not right in my SBC code.<br /><br />this is from my source code:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void *sbc&#40;&#41; &#123;<br />    value = getvalue&#40;&#41; + &#40;uint16_t&#41;&#40;status &amp; FLAG_CARRY&#41;;<br />    result = &#40;uint16_t&#41;a - value;<br />    <br />    carrycalc&#40;result&#41;;<br />    zerocalc&#40;result&#41;;<br />    overflowcalc&#40;result, a, value&#41;;<br />    signcalc&#40;result&#41;;<br />    <br />    saveaccum&#40;result&#41;;<br />&#125;<br /></div><br /><br /><br />here is the code to the macros it uses:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#define zerocalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0x00FF&#41; clearzero&#40;&#41;;\<br />        else setzero&#40;&#41;;\<br />&#125;<br /><br />#define signcalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0x0080&#41; setsign&#40;&#41;;\<br />        else clearsign&#40;&#41;;\<br />&#125;<br /><br />#define carrycalc&#40;n&#41; &#123;\<br />    if &#40;&#40;n&#41; &amp; 0xFF00&#41; setcarry&#40;&#41;;\<br />        else clearcarry&#40;&#41;;\<br />&#125;<br /><br />#define overflowcalc&#40;n, m, o&#41; &#123; /* n = result, m = accumulator, o = memory */ \<br />    if &#40;&#40;&#40;n&#41; ^ &#40;uint16_t&#41;&#40;m&#41;&#41; &amp; &#40;&#40;n&#41; ^ &#40;o&#41;&#41; &amp; 0x0080&#41; setoverflow&#40;&#41;;\<br />        else clearoverflow&#40;&#41;;\<br />&#125;<br /><br />#define saveaccum&#40;n&#41; a = &#40;uint8_t&#41;&#40;&#40;n&#41; &amp; 0x00FF&#41;<br /></div><br /><br />i assume those macros are fine, since they work correctly for all other opcodes.<br /><br />for the record, this is what my code for the undocumented ISB instruction looks like:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">static void *isb&#40;&#41; &#123;<br />    *inc&#40;&#41;;<br />    *sbc&#40;&#41;;<br />&#125;<br /></div><br /><br />does anybody see what the SBC issue could be? thanks!<br /><br /><br />my other question was simply about adding clock ticks when page boundaries are crossed. what are the cases where i would add a cycle to the total? is it just when indirect addressing mode calculations read data across a boundary, or is it also when the PC register increments past a boundary?<br /><br />i want everything, including timings to be flawless, i plan to release the source for other emu authors to use once i've squashed these issues. i know there are a lot out there, but one more can't hurt right? i think most have bugs anyway.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Wed Nov 23, 2011 5:06 pm</p><hr />
]]></content>
</entry>
</feed>