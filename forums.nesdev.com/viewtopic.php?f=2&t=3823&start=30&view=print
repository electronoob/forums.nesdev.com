<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Rendering enabled after the end of VBlank x Sprites</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Rendering enabled after the end of VBlank x Sprites</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=3823">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=3823</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>3</strong> of <strong>4</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Feb 16, 2008 2:06 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Under an MMC3 bank layout, would the blue guy ever be on the same scanline as the HUD?
<br />
<br />Another tip: The area after the last raster split can probably use sprites from both banks.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sat Feb 16, 2008 2:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well, do as you wish, but I really don't see why the beef with the MMC1.</div><br />I hate writing to it's registers. If one of those writes is interrupted by an NMI, you are pretty much screwed. It's CHR banking scheme is pretty poor, so using CHR-ROM with it is out of the question. Also, since I was using a SUROM board, having to constantly switch between the two 256KB sections of the ROM was pretty annoying, even though I came up with a decent way to do that, it would be so much better if I didn't have to.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Also you shouldn't get even if there is 3 glitchy pixels on the screen or something, because this happens often on the NES.</div><br />I know. But I want to be like the programmers that found ways to get rid of the glitches rather than the ones that just learned to live with them. I've been going through so many commercial games the last few days, and I've seen many creative ways people got rid of scrolling glitches (while still using only 2 name tables) that it's a bit inspiring actually.<br /><br />There are 2 games that really cought my attention: Alfred Chicken and Jurassic Park. Alfred Chicken uses horizontal mirroring to get avoid vertical scroliing glitches, masks the leftmost 8 pixels of the screen and goes as far as sacrificing a large number of sprites to mask the right side of the screen. I'd never waste that many sprites, and reduce the scanline limit to just 7, but it's still a nice solution, that works for this game and it's small sprites. Jurassic Park keeps the CHR banks mapped to blank tiles, and at a certain point switches the actual graphics in. I find this pretty clever, and am considering something similar to hide glitches.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It's possible to have sprite-zero hit without any glitches, but this sometimes makes restrictions in the level.</div><br />I admit that my biggest problem with sprite 0 hits at the bottom of the screen isn't a possible visible glitch, but the fact that you must be sure that the frame calculations will be done before the hit, or else it'll look like Micro Machines, with it's flashing border, and that sucks. I know you could set up APU IRQ's to make sure you don't miss the sprite 0 hit, but since the timing of the IRQ's vary so much, you end up loosing valuable processing time and will probably miss more frames.<br /><br />I don't expect to miss a lot of frames, but even the originalsonic games slowed down quite often when many objects were present. I can't expect to make something much better than that with a slower CPU, no matter how efficient my code is, so I must be prepared for a few slowdowns.<br /><br />Most NES games that use sprite 0 hits to hide part of the bottom of the screen do not have slowdown problems, as the processing ends long before the sprite hit. Or they'd be like Micro Machines.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">By the way, to answer your previous question, Battletoads seems to enable sprites one scanline before BG, and do both $2001 writes during HBlank if that helps you. I haven't heary anything about sprites glitch because of this, but I don't own the real thing. Seeing how many Battletoads fans are arround, if there were a glitch it'd probably be known by now.</div><br />Yeah, but Battletoads has a huge black section at the top that could very well hide any glitches. It takes some time to jump into the action part of the frame, while my game doesn't. Anyway, even in my game the glitch is pretty small, not such a big thing. It doesn't even flicker, it's static, so it doesn't stand out much. I'm now much more worried about how complex and fragile the kernel can be than with small glitches, actually. I'd rather move to a more stable setup, even if that means a couple of glitches.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If you don't blank any scanline, and only use NTSC systems where top and bottom lines are hidden, it's possible to do multidirectionnal scrolling (without a status bar) without any glitches at all.</div><br />I know. As I said, I've been looking at tons of comercial games loking for interesting solutions.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You definitely couldn't be a programmer at Rare, where they did awesome things with the worst mapper to code for, mapper 7.</div><br />I'm sure I could, I just wouldn't be able to code Sonic there! =)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Personally I like the spirit of doing the most thing possible on a basic mapper.</div><br />I'm all for that too! It's just a bit harder in my case, because this is not a fully original game. There is a set of rules I must follow if I want the game to feel like a real Sonic game, rules that were created for a system more capable than the NES, so it gets really hard to mimic those features with so little resources. It's just this special case.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You'll see, when my mapper 3 game will be released (if this ever happens) everyone won't belive it, you'll all be saying "hey that's impossible it looke like MMC3 !". No I'm just kidding here.</div>
<br />Looking forward to that! =)
<br />
<br />Please note that everything I said about the MMC1, sprite 0 hits, etc, applies to the type of game I'm coding. Please don't think that I'm saying "everything sucks", it's just that these common solutions don't seem to fit my game very well, that's all. But I'm sure there is a way out for everything. If in the end I can't avoid all glitches, so be it, I'll have to live with some.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sat Feb 16, 2008 2:54 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">Under an MMC3 bank layout, would the blue guy ever be on the same scanline as the HUD?</div><br />I think that regardless of the mapper, Sonic can move faster than the camera at times, so it is possible for him to be anywhere on the screen, and even out of it. BTW, there is another playable character besides the "blue guy"! =)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Another tip: The area after the last raster split can probably use sprites from both banks.</div>
<br />
<br />It would be pretty hard to control which sprites are where... rings are fetched from the background side, so you can imagine that you can't really control that.
<br />
<br />I am however taking what you said into consideration. I made that other topic about changing the sprite height exactly for that reason. The idea is to keep PPU updates all inside VBlank, and having rendering enabled by the start of the frame (no different dot crawl). All 4 background banks would be mapped in, the sprite banks pointing to empty tiles. Sprites would be set to 8x8, and both sprites and background set to fetch patterns from the transparent tiles. I'd set up and IRQ for a few scanlines in (enough to hide scrolling glitches). When the NMI fires, I switch in the 2 sprite banks, set sprites to 8x16 and set the background to fetch tiles from the correct side (this is possible with less than 28 cycles, more or less the length of HBlank). It would also be more compatible with PAL systems.
<br />
<br />That would allow for a very clean border at the top, with almost no wasted time (the IRQ would interrupt the processing of the frame that would have already started). I believe I'd have again that 1 scanline without sprites I tried to get rid of a when using the MMC1, because during the scanline the sprites were evaluated, all sprite patterns were transparent. But I don't think I care about that anymore, that can't even be considered a glitch I guess, because it's very consistent behavior. Also, not wasting time just waiting or copying an insane amount of bytes to the PPU is a relief, and might even result in less dropped frames, resulting in a more efficient engine.
<br />
<br />I'm starting to think the MMC3 is a reasonable choice now. It's PRG-ROM bankswitching scheme is pretty useful too, allowing for better separation of code and data than I had with the MMC1.
<br />
<br />EDIT: There is a small problem with the idea above... can't use the scanline counter if sprites and background use the same pattern table area. Oh well. This wouldn't be an isue with the FME-7, and there'd be no need for so much tile redundancy. The MMC5 would handle it well too, but that's a bit overkill.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sat Feb 16, 2008 7:17 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Wow... as I keep looking at commercial games I see some strange stuff... I just know checked this game, "Super Cars", which seems to hide a few scanlines at the top.
<br />
<br />I don't know what it does yet, but it must be something very funky, because Nestopia seems to be the only one to emulate it correctly... In FCEUXD the bar flickers a lot, and Nintendulator goes completely crazy. I wouldn't expect Nintendulator to act so crazy over something that works on the NES (it probably does, since it seems to be a commercial game).
<br />
<br />I'll try and figure out what the hell this game is doing that confuses emulators so much.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>strangenesfreak</b> [ Sat Feb 16, 2008 7:36 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Wow... as I keep looking at commercial games I see some strange stuff... I just know checked this game, "Super Cars", which seems to hide a few scanlines at the top.<br /><br />I don't know what it does yet, but it must be something very funky, because Nestopia seems to be the only one to emulate it correctly... In FCEUXD the bar flickers a lot, and Nintendulator goes completely crazy. I wouldn't expect Nintendulator to act so crazy over something that works on the NES (it probably does, since it seems to be a commercial game).<br /><br />I'll try and figure out what the hell this game is doing that confuses emulators so much.</div>
<br />I tried the game myself on the official latest version of Nintendulator (0.965 beta) and it works fine.  However, it does <strong>NOT</strong> work fine on the special debugger version of Nintendulator I recommended to you before.  The flickering bar glitch in FCEUxD also occurs during certain cutscenes of Metal Slader Glory, when it needs to turn off rendering early at the bottom.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sat Feb 16, 2008 7:45 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">strangenesfreak wrote:</div><div class="quotecontent">I tried the game myself on the official latest version of Nintendulator (0.965 beta) and it works fine.</div><br />Oh yeah, I forgot this one was out!<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">However, it does <strong>NOT</strong> work fine on the special debugger version of Nintendulator I recommended to you before.</div><br />Yeah, I tried it too.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The flickering bar glitch in FCEUxD also occurs during certain cutscenes of Metal Slader Glory, when it needs to turn off rendering early at the bottom.</div>
<br />Well, it's normal for this to happen at the bottom of the screen, but at the top it's a bit weird...
<br />
<br />I was just wondering what could confuse the previous version of Nintendulator so much... I'll debug this a bit know and see if I can figure it out.
<br />
<br />EDIT: Are you sure you got it working with Nintendulator 0.965? It's not working for me. The screen just stays white. The game seems to be running though, because when I switch to PAL mode I can see something, and the game runs for a while before glitching up.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Feb 17, 2008 2:29 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Well, what to say ? You may be just worrying too much. Note that if the Sonic game on the NES looks slightly different than their megadrive counterpart and if a few details are lacking, I guess noone will blame you, because after all, while we all love the NES, it's still technically an inferior system.
<br />
<br />If you want to use MMC3 why not change between 4 BG banks/2 SPR banks and 2 BG banks/4 SPR banks ? Levels that needs heavy BG graphics with animation would use the 4 BG banks, and manage to not bankswitch sprites (if you're using bankswitching for Sonic himself at $1000 say, this will need sacrifice at $1400-$1800 with garbage tiles since they'd be unpredictable). Then for most levels, you'd just go with the 2 BG banks / 4 SPR banks, where more customisation is allowed for sprites.
<br />
<br />Also as long as you don't use the scanline counter, you're free to use BG and sprites from any pattern tables with no problem, so if you're going to use any raster effect, you can design your level according to this pattern table limitation, but don't care about it for other levels where there is no raster effects.
<br />
<br />I guess the better way to hide glitches is to place them where the user will be less likely looking... If you're scrolling right, the user will LOGICALLY watch on the right of the screen... where new enemy and stuff will come. The player will be completely pissed to what happens on the left of the screen.
<br />So if there is color glitches on the very left of the screen, noone will ever see them... Most games with attributes glitches always set them on the same side of the screen, and that's just not clever. Knowing that, use Horizontal mirroring will allow you to have "no" glitches on both NTSC and PAL.
<br />
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I admit that my biggest problem with sprite 0 hits at the bottom of the screen isn't a possible visible glitch, but the fact that you must be sure that the frame calculations will be done before the hit, or else it'll look like Micro Machines, with it's flashing border, and that sucks. I know you could set up APU IRQ's to make sure you don't miss the sprite 0 hit, but since the timing of the IRQ's vary so much, you end up loosing valuable processing time and will probably miss more frames.<br /></div>
<br />Yeah, I have also wondering about this for a while. Many games, like Gradius, Life Fore, Wizard and Warriors series, Solar Jetman, etc... handle this somehow (and without using APU IRQ nor DMC IRQs). I've tried to log Gradius when it slows down... It's rather amazing, I guess somehow the game engine is KNOWING it will lag before actually lagging, and so it perform less calculations for one frame, check for sprite zero hit in time, and repeat next frame, so while the game is technically lagging, the CPU still doesn't run at 100%. I guess other Konami games use similar techniques.
<br />However, Double Dragon handles this badly, and when there is too much CPU process to be completed in a frame, the status bar shakes.
<br />
<br />For MMC1 writes, the MMC3 won't help much because there is the same problem, an NMI can occur between a write to $8000 and a write to $8001, screwing things up.
<br />To fix the problem of the MMC1, you would of course disable NMIs when you're writing to registers, and enable NMI back after this, but this may delay the NMI a little and screw your timing up. Another trick is to simply avoid writing to any MMC1 registers in the NMI routine when a flag is set (and set this flag when the main programm writes to the registers). A third, more sophisticated method, is to disable NMI when the main programm does its MMC1 writes, and after the fifth write read $2002.7 instead before re-enabling NMIs. If the bit was set, then you just missed an NMI but you can call a routine that does exacly the same, and that with a fixed timing that won't screw up (typically the time wasted on the end of the MMC1 write can be saved back by not saving the registers). You may also use the BRK instruction to have an "IRQ" routine that would be a NMI clone that just start differently, and jump to the normal NMI routine, assuming you don't use any other type of IRQs.
<br />
<br />For the MMC3, it's simple enough, after write to $8000 simply write a copy of it to a memory location, before writing to $2001. At the end of NMI just read that memory location and write it to $8000, that should do the trick. The above methods will work as well, but it's probably better to "waste" a single byte of RAM. In fact now that I think about it it you can do more elvolved method to handle the MMC1 case, for exemple each time the main programm writes something to the MMC1, set a flag during this time, and the NMI code check this flag (once everything time-critical has been done). If set, it will change the return adress so that it doesn't do the rest of the write, but directly return, and instead write "latched" values in RAM before returning. That would seem the most perfect method to me, at the price of a few RAM bytes, once for a flag and other to mirror MMC1 writes.
<br />
<br />EDIT : If you're really worried about graphical glitches.... I have a method that will completely remove them, both horizontal and vertical, and with any mirroring mode... However this introduce a limitation to the graphics themselves. Are you ready ?
<br />Just make all 4 BG palettes identical. You don't have to worry about any attribute updates, you don't have to worry about attributes glitches. Since you don't use attribute tables, you're free to set PPU adress to $3c0 during rendering and have nametable data instead, effectively making the screen 32x32 instead of the usual 32x30. The bad news is that you'll have to do it manually, and without IRQs that could be a pain. Wizard and Warriors II doesn't do exactly that, but have all its graphics using a single BG palette for some reason, so that is possible.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Feb 17, 2008 11:12 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well, what to say ? You may be just worrying too much.</div><br />Yup.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Note that if the Sonic game on the NES looks slightly different than their megadrive counterpart and if a few details are lacking, I guess noone will blame you, because after all, while we all love the NES, it's still technically an inferior system.</div><br />Heh, I'm sure I will not be able to fool anyone into thinking "hey, is this for the NES or MD again?", but I want it to feel similar enough, inspite of the obvious graphical inferities. It's not my intention to mimic everything from a MD game anyway, because I'm sure it will look better if I intentionally simplify a few things rather than forcing the NES to do what it obviously can't and fail miserably.<br /><br />My goal is actually to surpass the SMS titles, getting closer to the MD titles than they ever did. And the NES does have a few advantages over the SMS: there are more tiles available (although they have less colors), which may result in less repetitive graphics, specially when combined with CHR-ROM bankswitching, for example. The SMS games look kinds dull, and whenever a larger amount of tiles needs to be loaded the game lags.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If you want to use MMC3 why not change between 4 BG banks/2 SPR banks and 2 BG banks/4 SPR banks ?</div><br />Iguess you are right, this would be possible. But I don't think I would "scrifice" anything, meaning that I'd still have a 1KB of common sprites following every 1KB of player graphics, in case sprites use the 2KB switching. And if the background used 2KB switching, I'd make it responsible for animating the common objects stored there (rings, monitors, etc).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Also as long as you don't use the scanline counter, you're free to use BG and sprites from any pattern tables with no problem, so if you're going to use any raster effect, you can design your level according to this pattern table limitation, but don't care about it for other levels where there is no raster effects.</div><br />There is simply no way for me to act according to it's scanline counter limitations. Except for the border at the top, but as soon as the IRQ fires, I'll do everything that's not allowed. So yeah, I won't be using raster effects during the rest of the frame, not even for the water levels, I have another idea for them already.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I guess the better way to hide glitches is to place them where the user will be less likely looking...</div><br />The only serious problem with me using that approach is that most NES games only update rows/columns that are a single tile tall/wide when scrolling, while I update full metatiles (2 tiles tall/wide) at a time, because of the fast scrolling. That means more visible glitches than the average game. Unless I'm able to hide exactly 16 pixels in the direction of the mirroring, which is harder to do horizontally (like Alfred Chicken) than vertically.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It's rather amazing, I guess somehow the game engine is KNOWING it will lag before actually lagging, and so it perform less calculations for one frame, check for sprite zero hit in time, and repeat next frame, so while the game is technically lagging, the CPU still doesn't run at 100%. I guess other Konami games use similar techniques.</div><br />Hum... it may be possible to predict when the calculations are going to take too long. The things that have more impact over the time spent are the need to render a new background row/column and the number of loaded objects. But even then, the complexity of each loaded object can make the actual amount meaningless. But if you think about it, even if a game can predict this, it still must sacrifice a great deal of otherwise usable time just to make sure it doesn't get too close to the hit (risking missing it), even when the sacrificed time might had been enough to finish the calculations, which causes more frame drops.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">However, Double Dragon handles this badly, and when there is too much CPU process to be completed in a frame, the status bar shakes.</div><br />This is just terrible, specially if it happens all the time.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">For MMC1 writes, the MMC3 won't help much because there is the same problem, an NMI can occur between a write to $8000 and a write to $8001, screwing things up.</div><br />I see your point, but I don't think this is as bad. I can think of a simple solution for the MMC3 case, while it's not so easy for the MMC1. Like, setting a flag before mapper writes that might be interrupted, using different registers for each write (say, X for $8000 and A for $8001). Before returning from the interrupting code, it checks this flag and clears it if it's set, then performs the two writes (X to $8000 and A to $8001). This should work well no matter where the code was interrupted. There should be no problem if after returning, both writes occur again, only the second write occurs again, or no write at all. The correct bank will be loaded. Not as simple with the MMC1, because of the larger number of writes to perform a switch and because it's harder to reset it's bit counter in order for the writes to reamain aligned.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To fix the problem of the MMC1, you would of course disable NMIs when you're writing to registers, and enable NMI back after this, but this may delay the NMI a little and screw your timing up. Another trick is to simply avoid writing to any MMC1 registers in the NMI routine when a flag is set (and set this flag when the main programm writes to the registers). A third, more sophisticated method, is to disable NMI when the main programm does its MMC1 writes, and after the fifth write read $2002.7 instead before re-enabling NMIs. If the bit was set, then you just missed an NMI but you can call a routine that does exacly the same, and that with a fixed timing that won't screw up (typically the time wasted on the end of the MMC1 write can be saved back by not saving the registers). You may also use the BRK instruction to have an "IRQ" routine that would be a NMI clone that just start differently, and jump to the normal NMI routine, assuming you don't use any other type of IRQs.</div><br />Your solutions are interesting, but I'd rather interrupt a MMC3 write than having to worry about the MMC1 ever again! =)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">For the MMC3, it's simple enough, after write to $8000 simply write a copy of it to a memory location, before writing to $2001. At the end of NMI just read that memory location and write it to $8000, that should do the trick. The above methods will work as well, but it's probably better to "waste" a single byte of RAM.</div><br />Oh, I didn't read this before! Yeah, this solution is almost what I said above, but yours is simpler. You are right, there is no need for a flag, and there is no need to write to $8001 as well at the end of the NMI/IRQ. See? It's much better! =)<br /><br />EDIT: Hey, if do want to have the correct bank loaded after returning from the NMI/IRQ, you do have to write to $8001 as well. Say that I was switching in a bank with metatile definitions when the NMI fired. Inside the NMI, I'll see that the frame isn't ready, and will want to call the sound engine, which switches in a bank with music data in place of the metatile definitions. Before I return, I must write to $8000 and $8001 the value that I was trying to write earlier, if I want the metatile definitions to be there, not the music data.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">EDIT : If you're really worried about graphical glitches.... I have a method that will completely remove them, both horizontal and vertical, and with any mirroring mode... However this introduce a limitation to the graphics themselves. Are you ready ? </div>
<br />That's nasty... But having a 4-color background would be pretty dull. Not even considering this for a Sonic game!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Feb 17, 2008 11:44 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Heh, I'm sure I will not be able to fool anyone into thinking "hey, is this for the NES or MD again?", but I want it to feel similar enough, inspite of the obvious graphical inferities. It's not my intention to mimic everything from a MD game anyway, because I'm sure it will look better if I intentionally simplify a few things rather than forcing the NES to do what it obviously can't and fail miserably.<br /></div><br />Yeah, but compare the SNES Final Fight and the NES Mighty Final Fight and you'll see what I mean... Personally I like Mighty Final Fight better. Capcom got it all, instead of trying to do the same on the NES port, they just designed another NES Final Fight game that had nothing to do with the original SNES version, and that was intended for the NES from the start : Smaller sprites, samller levels, and the gameplay is much funier. I guess you could do smaller sprites than MD games, and maybe make smaller background elements too, that would probably help by using less tiles and still look very good, as long as everything keeps more or less in proportion.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The only serious problem with me using that approach is that most NES games only update rows/columns that are a single tile tall/wide when scrolling, while I update full metatiles (2 tiles tall/wide) at a time, because of the fast scrolling. That means more visible glitches than the average game. Unless I'm able to hide exactly 16 pixels in the direction of the mirroring, which is harder to do horizontally (like Alfred Chicken) than vertically. </div><br />I guess I see what you mean here. I guess upload metatiles simplifies things a lot. Unless you use single-palette BG I see no way to completely fix it, but you can just put those glitches on the side the player is not looking and it should be allright... Too much glitches can be annoying, tough.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Hum... it may be possible to predict when the calculations are going to take too long. The things that have more impact over the time spent are the need to render a new background row/column and the number of loaded objects. But even then, the complexity of each loaded object can make the actual amount meaningless. But if you think about it, even if a game can predict this, it still must sacrifice a great deal of otherwise usable time just to make sure it doesn't get too close to the hit (risking missing it), even when the sacrificed time might had been enough to finish the calculations, which causes more frame drops. </div>
<br />Well, Gradius can have a lot at objects at once in Level 1 without lagging. In level 5 when there is those flowers attacking, the game lags A LOT, but the status bar doesn't move a single bit, even tough it's made entierly on sprite zero hit. And there is only 2 flowers attacking, as opposed to dozen of projectiles from stage 1. I guess it's mazing them to sprites who takes so long... Life Force is pretty much the same, it lags, but still manage to never miss a single sprite zero hit.
<br />EDIT : Also instead of making a programm that would lag proprely when so many objects are on screen, I'd rather limit the number of object and design the game with that in mind.
<br />
<br />So in the end you'll end up using MMC3+CHR ROM, have vertical mirroring to hide horizontal glitches, and use a all-black CHRROM blank to hide the top border of the screen to hide vertical glitches (without having to worry about setting the scroll midframe a complete way) ? That souds like a good sheme.
<br />Also by the way about the method to use sprites to clip the right part of the screen, I gess it may waste a lot of sprites, but if you use 8x16 sprites you can do it with 14/15 sprites only (NTSC/PAL). I guess Zelda II and Lagrange Point does this. The very good side, however, is that you have a 100% symetrical screen and have really nothing to worry about horizontal glitches. I guess having a screen with even number of tiles horizontally is a bit annoying (but I've never actually used the left clipping yet).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Feb 17, 2008 2:41 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well, Gradius can have a lot at objects at once in Level 1 without lagging. In level 5 when there is those flowers attacking, the game lags A LOT, but the status bar doesn't move a single bit, even tough it's made entierly on sprite zero hit.</div><br />If the game had a way to get even a vague idea of where in the frame it was, it could wait for the next frame before executing a potentially large task.<br /><br />Some games might alternate tasks (for example, process less enemies if there is background to draw or something like that) to make sure they ramain within the limit of cycles. However, they might choose to introduce slowdown in case a large task needs to be performed, but it's only performed during the next frame, so that the sprite hit is not affected.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Life Force is pretty much the same, it lags, but still manage to never miss a single sprite zero hit.</div><br />I think this one relies on IRQ's firing a few scanlines before the hit. Someone in here said this a while ago.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">EDIT : Also instead of making a programm that would lag proprely when so many objects are on screen, I'd rather limit the number of object and design the game with that in mind.</div><br />Once again, this depends on the type of game you are making. Sonic Team went with the lagging option (they had to, with that insane amount of rings flying around when Sonic looses them), so that might be the best option for me too. The Sonic engine can get pretty busy at times. A little slowdown does not bother me, but visual glitches do.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So in the end you'll end up using MMC3+CHR ROM, have vertical mirroring to hide horizontal glitches, and use a all-black CHRROM blank to hide the top border of the screen to hide vertical glitches (without having to worry about setting the scroll midframe a complete way) ? That souds like a good sheme.</div><br />That's the idea. I'll use transparent tiles though, so that the "border" uses color 0. While loading the actual patterns through $8000 and $8001, I might have to disable background rendering for a while and re-enable it during HBlank (this shouldn't do anything bad with the scroll, as long as I re-enable rendering before the start of the next scanline), because it takes a while to switch all 6 CHR banks, and with the background enabled there would be glitches. The good news is that this will produce a very clean border, without messing with the dot crawl pattern, without wasting CPU cycles, and with minimal timed code (from when the NMI fires, going through resizing the sprites, disabling the background, switching in the 6 banks, ending by enabling the background during HBlank). All of that might even get close to using the full scanline, so I'd really be wasting almost nothing.<br /><br />The good thing about this scheme is that it's really easy to implement, I con do it right now without wasting much time timing things. My old VBlank code used about 18 scanlines worth of time (another 18 were needed to update 256 bytes of CHR data, but I don't have to worry about this anymore), so they'll fit inside the normal 20 of VBlank easily.<br /><br />Now, why do people usually prefer to clip scanlines at the bottom of the screen rather than at the top? In all TV's I tested, many more scanlines are cropped from the top than from the bottom. This may be an issue with my TV's though. Anyway, people sem to think that a blank bar at the bottom is less noticeable. Is this true?<br /><br />In a game like mine, where most of the background uses color 0 (which allows for some layering effects through the priority bit of the sprites), the border may be harder to notice at the top, because at the bottom you are likely to have the floor where the player is standing, which doesn't use color 0. This is not always the case, but most of the time you have only sky at the top, and sky mixes well with color 0.<br /><br />EDIT: Another clear advantage of blanking the top instead of the bottom (specially when using 8x16 sprites), is that sprites can can move smoothly at the top, something that leaves only the left side of the screen with sprite issues, and if that really bothers you, just hide the leftmost 8 pixels as the PPU allows it, and you get perfect sprite movement. <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Also by the way about the method to use sprites to clip the right part of the screen, I gess it may waste a lot of sprites, but if you use 8x16 sprites you can do it with 14/15 sprites only (NTSC/PAL).</div>
<br />I know, this is a great idea. I'd worry more about reducing the sprites per scanline limit to 7 than about using 14 of 15 out of the 64, though.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>strangenesfreak</b> [ Sun Feb 17, 2008 3:06 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If your game is faced with big tasks, I think you could reduce the framerate of the game when the tasks need to be executed instead of slowing it down.  If your game segregates the main tasks to the main thread, you could also reduce the framerate of the main thread instead of the whole game.  You could even do multi-threading within the main thread and just reduce the framerate of the offending thread within the main thread.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Feb 17, 2008 3:25 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">strangenesfreak wrote:</div><div class="quotecontent">If your game is faced with big tasks, I think you could reduce the framerate of the game when the tasks need to be executed instead of slowing it down.  If your game segregates the main tasks to the main thread, you could also reduce the framerate of the main thread instead of the whole game.  You could even do multi-threading within the main thread and just reduce the framerate of the offending thread within the main thread.</div>
<br />Really, the ones to blame for slowdown are always the objects/enemies. It'd be tough to not process them every frame though, because if they are not rendered, the action will look very weird with objects missing or not moving. Collisions with the player might go undetected, because it can move very fast. Objects that are drawn to the background are even worse, because those are drawn at the same time as columns and rows of metatiles are, so if a row or a column is updated but the object isn't processed, entire parts of it will be missing!
<br />
<br />I'm betting on coding things as efficiently as possible in order to have very few parts slowing down. In previous tests, with the engine running normally, it wasn't until I had 16 objects loaded at a time that I started to loose frames, but even then I was scrolling and updating rows and columns every frame. Sure, the objects were really simple and did nothing but constantly move in a single direction, but all of them were composed by 8 sprites (very few objects will actually have that many), and rendering their sprite definitions does take a lot of time. So I think I'm not that bad on the timing department. Of course I'll try to optmize everything as much as I can.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>strangenesfreak</b> [ Sun Feb 17, 2008 4:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Really, the ones to blame for slowdown are always the objects/enemies. It'd be tough to not process them every frame though, because if they are not rendered, the action will look very weird with objects missing or not moving. Collisions with the player might go undetected, because it can move very fast. Objects that are drawn to the background are even worse, because those are drawn at the same time as columns and rows of metatiles are, so if a row or a column is updated but the object isn't processed, entire parts of it will be missing!</div>
<br />In that case, would reducing the framerate of the whole game be better during situations with too many objects?  That way, even though other processes are burdened with the choppiness, everything would stay "proportional" in framerate.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun Feb 17, 2008 5:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Some games might alternate tasks (for example, process less enemies if there is background to draw or something like that) to make sure they ramain within the limit of cycles. However, they might choose to introduce slowdown in case a large task needs to be performed, but it's only performed during the next frame, so that the sprite hit is not affected.</div><br />Or given that the enemies tend appear in groups of a half-dozen or so, perhaps only give one enemy of the group "think time" in any given frame and use dead reckoning for the rest.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Now, why do people usually prefer to clip scanlines at the bottom of the screen rather than at the top?</div><br />For one thing, it's often easier to mess with the post-render scanline than with the pre-render scanline. The pre-render scanline is responsible for v=t, which allows easy setting of the camera position with PPUSCROLL.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Another clear advantage of blanking the top instead of the bottom (specially when using 8x16 sprites), is that sprites can can move smoothly at the top, something that leaves only the left side of the screen with sprite issues, and if that really bothers you, just hide the leftmost 8 pixels as the PPU allows it, and you get perfect sprite movement. </div>
<br />The NES picture is drawn about two pixels too far to the right, making the choice to clip on the left even more noticeable.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Feb 17, 2008 6:44 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">For one thing, it's often easier to mess with the post-render scanline than with the pre-render scanline. The pre-render scanline is responsible for v=t, which allows easy setting of the camera position with PPUSCROLL.</div><br />Not that it is any hard to prepare the values you write to $2006/$2005 in order to set the position of the camera. I don't remember exactly how I was doing it, but a few commands to shift bits around did the trick. I won't be doing this anymore, though. Besides, the few games I found that clip the top do keep rendering enabled at least at the very start of the frame, so they can set the scroll the usual way.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The NES picture is drawn about two pixels too far to the right, making the choice to clip on the left even more noticeable.</div>
<br />I can clearly see this on my TV's, while the rightmost column of tiles is usually cut in half.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>3</strong> of <strong>4</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>