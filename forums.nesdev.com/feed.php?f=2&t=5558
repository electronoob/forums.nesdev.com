<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=5558" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2009-09-09T23:32:57-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=5558</id>
<entry>
<author><name><![CDATA[Banshaku]]></name></author>
<updated>2009-09-09T23:32:57-07:00</updated>
<published>2009-09-09T23:32:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=5558&amp;p=50551#p50551</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=5558&amp;p=50551#p50551"/>
<title type="html"><![CDATA[ca65: Passing parameter to function with a software stack]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=5558&amp;p=50551#p50551"><![CDATA[
Warning: wall of text.<br /><br />In some previous threads (<a href="http://nesdev.com/bbs/viewtopic.php?t=5491" class="postlink">here</a> and <a href="http://nesdev.com/bbs/viewtopic.php?t=5481" class="postlink">here</a>) me, Miau and Disch have been talking about macros, how to use the stack in a better way, parameters etc.<br /><br />Disch came out with the concept of a software stack in zero page instead of using the real one.  After thinking a little bit about it, I decided to make one and tried to make a few macro to help the process of using it.<br /><br />Here's the concept.  First, you need to define a variable in zero page for the stack pointer and some constant for the location of the stack. You have to init it like the real stack with the value $FF<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">.segment &quot;ZEROPAGE&quot;<br />zpStackPointer:      .res 1 ; Software stack pointer<br /><br />; ... Some code later<br /><br />; Define for stack location<br />SOFTWARE_STACK   = $00      ; Software stack pointer is in zero page<br /><br />.segment &quot;CODE&quot;<br />   ldx #$FF<br />   stx zpStackPointer       ; Set software stack pointer<br /></div><br /><br />The init must be done after your init your memory to zero.  Then, you need to create a method that defines a few parameters.  The way you define a method is this way:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; The procedure with parameter <br />.proc subShowAnimFrame<br />; Parameters on software stack:<br />.struct Param<br />   PosX        .byte   ; X location<br />   PosY        .byte   ; Y Location<br />   SpriteDir   .byte   ; Sprite direction<br />.endstruct<br /><br />; ... some code here<br />.endproc<br /></div><br /><br />The structure defined inside the .proc is important: it defines the size of your parameters and where they are located. It will become clearer later.<br /><br />Now you need a few macro to make your life easier (and make your code cleaner to read). One is for allocating memory, one is for loading parameters and the other one is for releasing memory.<br /><br />Here's the macros:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;-&gt;BEGIN----------------------------------------------------------------------<br />; Allocate memory on the stack for parameters<br />;<br />; Parameter:  <br />;   paramStruct : The structure that represent the parameters that needs memory<br />;                 to be allocated.<br />;<br />; Notes: The stack pointer value is put by default in the X index at the end. This<br />;        is because we expect to store parameters after alocating memory.<br />;<br />.macro alocateMemOnStack paramStruct<br />   lda zpStackPointer         ; Load stack pointer<br />   sec               <br />   sbc #.sizeof&#40;paramStruct&#41;      ; Adjust stack pointer<br />   sta zpStackPointer         ; save it<br />   tax               ; Store stack pointer value in index<br />.endmacro<br />;-&lt;END------------------------------------------------------------------------<br /><br />;-&gt;BEGIN----------------------------------------------------------------------<br />; Release the memory stored for the parameters on the stack<br />;<br />; Parameter:  <br />;   paramStruct : The structure that represent the parameters that needs memory<br />;                 to be released.<br />;<br />.macro releaseMemFromStack paramStruct<br />   lda zpStackPointer         ; Load stack pointer<br />   clc               <br />   adc #.sizeof&#40;paramStruct&#41;      ; Adjust stack pointer<br />   sta zpStackPointer         ; save it<br />.endmacro<br />;-&lt;END------------------------------------------------------------------------<br /><br />;-&gt;BEGIN----------------------------------------------------------------------<br />; Store parameter on the stack<br />;<br />; Parameter:  <br />;   paramLocation : Where in memory relative to the stack pointer that is should<br />;                   be stored.<br />;   value         : The value we want to store<br />;<br />; Note: We should make it more inteligent and knows when it's a 16/8 value to store<br />;<br />.macro spos paramLocation, value<br />   lda value<br />   sta SOFTWARE_STACK + paramLocation, x<br />.endmacro<br />;-&lt;END------------------------------------------------------------------------<br /></div><br /><br />Now that we have some macro to do the job, it's time to see how to use them.  Here's the code example to call a function with parameters:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">   ; Alocate ram the size of all parameters<br />   alocateMemOnStack subShowAnimFrame::Param<br /><br /><br />   ; Store parameters on stack<br />   spos subShowAnimFrame::Param::PosX, #$00<br />   spos subShowAnimFrame::Param::SpriteDir, zpDebugMMDir<br />   spos subShowAnimFrame::Param::PosY, #$64<br />   <br />   jsr subShowAnimFrame<br />   <br />   ; Release it<br />   releaseMemFromStack subShowAnimFrame::Param<br /></div><br /><br />Now without explanation it will be hard to understand. The first line allocate ram on the stack. How it work is that is the macro receive as a parameter the function parameter's structure (subShowAnimFrame::Param).  The macro will check the size of the structure and will allocate the ram right away. Then it will set the X register with the current stack location.<br /><br />The spos puts a parameter on the stack. The first parameter is the location on the stack (subShowAnimFrame::Param::PosX). The second one is the value you want to put. In it's current stage, you can only put 8 bits value. I want to improve it later.<br /><br />One thing you will find interesting is the order of parameters is <strong>not important</strong>. Since the structure knows the location in memory of a parameter and you allocated the RAM you need before using it, you don't have to worry about parameters order. this will be the same thing when retrieving them too.<br /><br />Now that we called the method, we need to know how to access those parameters inside it. Here's the code example:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">   ldx zpStackPointer<br />   lda SOFTWARE_STACK + Param::SpriteDir, x ; Check sprite orientation.<br /></div><br /><br />Since you use a software stack in zero page, you must first load the X register with the stack pointer. Then you can access the location of the variable with stack location + location in RAM (SOFTWARE_STACK + Param::SpriteDir).  You don't have to worry if it's parameter 1 or 2, the structure will take care of it.<br /><br />The pro of this approach is to have dynamic allocation of parameters. Once you understand how to use the macro properly, it's quite simple.  It removes the possibility of using by accident some temp variable defined elsewhere too. If you want local variables, you could just add a few extra parameters inside the struct. The value of those "parameters" will be initialized inside the method. This way, the memory for the parameters and local variables would be allocated before calling the function.<br /><br />The cons are that there will be a small price in performance. You need to load the stack pointer in X every time you want to access a value. Compared to a direct zero page variable, you have do do a few processing before being able to access it. So I will not recommend this approach for critical method used in the vblank for example.  But in some other cases, it could make the programming easier for methods that have many parameters. You don't have to worry how many temp variable you have and if someone is using them.<br /><br />I have been testing it yesterday and for now it's working. I need to test it more to see if there is any issues I didn't see yet.  <br /><br />That's was a long message.  Any comment on the subject will be appreciated.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3559">Banshaku</a> — Wed Sep 09, 2009 11:32 pm</p><hr />
]]></content>
</entry>
</feed>