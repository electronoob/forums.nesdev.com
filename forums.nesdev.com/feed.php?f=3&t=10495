<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=3&amp;t=10495" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2013-10-04T05:09:34-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=3&amp;t=10495</id>
<entry>
<author><name><![CDATA[ArsonIzer]]></name></author>
<updated>2013-10-04T05:09:34-07:00</updated>
<published>2013-10-04T05:09:34-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118939#p118939</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118939#p118939"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118939#p118939"><![CDATA[
Thanks for all the info guys, things are starting to clear up. Just gotta learn to understand those datasheets and whatnot and I'll be fine <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /><br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />But this game probably doesn't:<br /><a href="https://en.wikipedia.org/wiki/Disney%27s_Hercules_%28video_game%29" class="postlink"><img src="https://upload.wikimedia.org/wikipedia/en/a/ae/Hercposter.jpg" alt="Image" /></a><br /></div><br /><br />Lol, talk about off topic. That game sure brings back some memories though. I used to play it on the PS1 as a kid, and I never managed to complete it at that time because it had no way of saving progress. You could collect some of those pots/urns or whatever and get a password, but I sucked as a kid and never got them. Ironically, this is one of those PS1 games that makes me want to get better at emulation so I can one day write a PS1 emu <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" />.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6075">ArsonIzer</a> — Fri Oct 04, 2013 5:09 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2013-10-03T19:46:00-07:00</updated>
<published>2013-10-03T19:46:00-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118934#p118934</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118934#p118934"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118934#p118934"><![CDATA[
But this game probably doesn't:<br /><a href="https://en.wikipedia.org/wiki/Disney%27s_Hercules_%28video_game%29" class="postlink"><img src="https://upload.wikimedia.org/wikipedia/en/a/ae/Hercposter.jpg" alt="Image" /></a><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Thu Oct 03, 2013 7:46 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Dwedit]]></name></author>
<updated>2013-10-03T19:37:00-07:00</updated>
<published>2013-10-03T19:37:00-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118933#p118933</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118933#p118933"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118933#p118933"><![CDATA[
Ultima 6 DID have a hercules mode...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=53">Dwedit</a> — Thu Oct 03, 2013 7:37 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-10-03T12:02:37-07:00</updated>
<published>2013-10-03T12:02:37-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118922#p118922</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118922#p118922"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118922#p118922"><![CDATA[
<div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><br />While I understand the driver thing, I don't understand how you can run a disk image like MS-DOS and have it run normally whether a CGA, WCGA, or whatever graphics card is installed.<br /></div> That's part of the purpose of the BIOS and DOS itself. They provide a set of globally provided functions (&quot;interrupts&quot; at the time, &quot;syscalls&quot; in modern parlance) that abstract away much of the lower-level functionality. It's just that the scale and scope of these functions were very limited, especially compared to the entirety of Win32s.<br /><br /><div class="quotetitle">Arsonizer wrote:</div><div class="quotecontent"><br />How does the processor/graphics card make sure that the write is received as a write to the expected register, even though there are multiple possibly connected cards with different registers/behavior?<br /></div>For the x86, there are two separate memory spaces: RAM and I/O. They're both readable and writeable, but the latter can't be executed from. Also, because the I/O space is distinct, there's very few configuration registers in RAM (they're almost all in the I/O space instead).<br />So drawing pixels onscreen was almost always some variant on &quot;call [System Call Interface] 0x10 with configuration parameters, allow video card BIOS to set up screen, and then write data to memory starting at 0xa0000 (EGA and newer), 0xb0000 (MDA), or 0xb8000 (CGA).  (How do you know which? Documentation...)<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />Some PC graphics programming books from the early SVGA era even had a list of cards, how to probe for them, and in what order to probe for them, because the probe sequence for one brand card would cause another brand of card to lock up.<br /></div> As I recall it, most software just completely gave up and simply asked the end-user what graphics card they had, presumably because the heuristics were so lousy and mistakes would usually crash.<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />At that time, input protection was so poor that the wrong poke could damage a Hercules monochrome graphics card or the monitor connected to it (I forget which).<br /></div>The monitor. High voltage power electronics are comparatively easy to toast; 5V logic is comparatively amazingly resilient.<br /><br /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><br />So let's say a game like Ultima VI (as shown in one of the fake86 screenshots by miker00lz) is run on a Hercules/CGA card, what would happen? Would the game crash/give errors and why? Because it can't detect its minimally required graphics card, or because certain VGA-specific instructions are failing on the machine/emulator?<br /></div><br />Very little visible would happen, but it's unlikely the game would crash. Depending on exactly how they wrote the game, it might even quit cleanly with a &quot;where's my VGA?&quot;. Otherwise, because the VGA was specifically designed to put the majority of its configuration registers in a completely different location than the CGA, it's mostly likely the game would start, clear the screen, and then you'd be left with a blank text mode screen with a blinking cursor. You might hear the game music.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Thu Oct 03, 2013 12:02 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[ArsonIzer]]></name></author>
<updated>2013-10-03T07:48:46-07:00</updated>
<published>2013-10-03T07:48:46-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118916#p118916</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118916#p118916"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118916#p118916"><![CDATA[
So let's say a game like Ultima VI (as shown in one of the fake86 screenshots by miker00lz) is run on a Hercules/CGA card, what would happen? Would the game crash/give errors and why? Because it can't detect its minimally required graphics card, or because certain VGA-specific instructions are failing on the machine/emulator?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6075">ArsonIzer</a> — Thu Oct 03, 2013 7:48 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2013-10-03T06:04:12-07:00</updated>
<published>2013-10-03T06:04:12-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118913#p118913</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118913#p118913"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118913#p118913"><![CDATA[
Some PC graphics programming books from the early SVGA era even had a list of cards, how to probe for them, and <em>in what order</em> to probe for them, because the probe sequence for one brand card would cause another brand of card to lock up. At that time, input protection was so poor that <a href="https://en.wikipedia.org/wiki/Killer_poke" class="postlink">the wrong poke</a> could damage a Hercules monochrome graphics card or the monitor connected to it (I forget which).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Thu Oct 03, 2013 6:04 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-10-03T05:50:07-07:00</updated>
<published>2013-10-03T05:50:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118912#p118912</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118912#p118912"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118912#p118912"><![CDATA[
<div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><br />While I understand the driver thing, I don't understand how you can run a disk image like MS-DOS and have it run normally whether a CGA, WCGA, or whatever graphics card is installed. What I mean is that MS-DOS can for instance write to address $F00 to set certain pixels on the screen or whatever, because it expects some kind of graphics register there. How does the processor/graphics card make sure that the write is received as a write to the expected register, even though there are multiple possibly connected cards with different registers/behavior?<br /></div><br />AFAIK, programs relied on tests to detect what hardware was present. MS-DOS most likely only made use of the most basic features that every video card was supposed to offer (it's only text after all!) but any program that wished to use more advanced features would probably have to look for a &quot;signature&quot; indicating that said features are indeed present.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Thu Oct 03, 2013 5:50 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[ArsonIzer]]></name></author>
<updated>2013-10-03T05:06:25-07:00</updated>
<published>2013-10-03T05:06:25-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118911#p118911</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118911#p118911"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118911#p118911"><![CDATA[
<div class="quotetitle">lidnariq wrote:</div><div class="quotecontent"><br />Fortunately, IBM actually released a set of incredibly complete documents for the IBM PC—the &quot;IBM Personal Computer XT Technical Reference manual&quot;—and thus also the CGA. These documents explain exactly what and how everything is. It's basically the equivalent of Disch's documentation for nintendo mappers, but written in schematics and datasheets instead of prose and tables.<span style="font-size: 75%; line-height: normal"> (Also consider looking for &quot;Ralf Brown's Interrupt List&quot;.)<br /><br />(For reference, the CGA has the MC6845 at I/O addresses 0x3D4 and 0x3D5, mirrored across 0x3D0-0x3D7. Later compatible things didn't mirror that full range. It also has a bunch of other control registers from 0x3D8-0x3DC.)</span><br /></div><br /><br />Yeah, too bad I can't really read those schematics and datasheets, so I'd have to learn that first. I appreciate the info though, I came across the document but I thought it would be more about the low hardware-level aspects of components, like pin arrangement and voltage levels and stuff, so I skipped it. I'll look more into it though. <br /><br /><div class="quotetitle">lidnariq wrote:</div><div class="quotecontent"><br />The same badness that happens if you're (trying to) using the video driver for an ATI video card but you actually have an Intel card instead. Some certain features are completely compatible (e.g. &quot;VGA compatible&quot;), many aren't. In the bad old days, you'd sometimes have quite a dance of moving things around to get everything to play together.<br /></div><br /><br />While I understand the driver thing, I don't understand how you can run a disk image like MS-DOS and have it run normally whether a CGA, WCGA, or whatever graphics card is installed. What I mean is that MS-DOS can for instance write to address $F00 to set certain pixels on the screen or whatever, because it expects some kind of graphics register there. How does the processor/graphics card make sure that the write is received as a write to the expected register, even though there are multiple possibly connected cards with different registers/behavior?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6075">ArsonIzer</a> — Thu Oct 03, 2013 5:06 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-10-03T02:22:24-07:00</updated>
<published>2013-10-03T02:22:24-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118909#p118909</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118909#p118909"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118909#p118909"><![CDATA[
<div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><br />Obviously, the 8086 doesn't work exclusively with CGA or MCGA or whatever, so what determines where the locations of, for instance, the CGA's registers are (if it has any). I've tried finding documents about it but there's nothing but a mediocre description on Wikipedia of the CGA.<br /></div>Fortunately, IBM actually released a set of incredibly complete documents for the IBM PC—the &quot;IBM Personal Computer XT Technical Reference manual&quot;—and thus also the CGA. These documents explain exactly what and how everything is. It's basically the equivalent of Disch's documentation for nintendo mappers, but written in schematics and datasheets instead of prose and tables.<span style="font-size: 75%; line-height: normal"> (Also consider looking for &quot;Ralf Brown's Interrupt List&quot;.)<br /><br />(For reference, the CGA has the MC6845 at I/O addresses 0x3D4 and 0x3D5, mirrored across 0x3D0-0x3D7. Later compatible things didn't mirror that full range. It also has a bunch of other control registers from 0x3D8-0x3DC.)</span><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Let's say you run MS-DOS, and DOS writes to a certain memory address expecting a CGA register, but instead an MCGA card is present, what happens?<br /></div>The same badness that happens if you're (trying to) using the video driver for an ATI video card but you actually have an Intel card instead. Some certain features are completely compatible (e.g. &quot;VGA compatible&quot;), many aren't. In the bad old days, you'd sometimes have quite a dance of moving things around to get everything to play together.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Thu Oct 03, 2013 2:22 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[ArsonIzer]]></name></author>
<updated>2013-10-03T01:55:45-07:00</updated>
<published>2013-10-03T01:55:45-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118908#p118908</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118908#p118908"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118908#p118908"><![CDATA[
<div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><br />ArsonIzer - Nope, the 8086 on it's own has no FPU at all fortunately. What you're thinking of is the 8087 co-processor (edit: koitsu beat me to it) which is required by virtually no software out there. I don't really understand the FPU stuff in detail either. As for graphics, emulating CGA and 320x200 256-color MCGA is dead simple to emulate compared to the NES. Not even close, really. They're simple bitmaps (CGA is interlaced, but it's still simple) mapped in the CPU's address space. Couldn't be any easier. If you really want to be super-accurate there is scanline timing involved, but for 99.999% of programs it doesn't matter.<br /><br />Yes, I implemented the graphics in my emu. (everything except EGA and 640x480 4-color VGA, but I'll get to that eventually)<br /><br />There are some screenshots from it here: <!-- m --><a class="postlink" href="http://sourceforge.net/projects/fake86/">http://sourceforge.net/projects/fake86/</a><!-- m --><br /></div><br /><br />Damn, I'm impressed, but I have a somewhat newb-ish question. What determines the memory map of an 8086 combined with, for instance, a CGA? Let's say I want to emulate them like I'm emulating the NES: I know that the NES has the NMI, RESET and IRQ vectors at $FFFA-$FFFF (in that order), the PPU registers in $2000-$20007, controller registers in $4016 and $4017, and so on. Obviously, the 8086 doesn't work exclusively with CGA or MCGA or whatever, so what determines where the locations of, for instance, the CGA's registers are (if it has any). I've tried finding documents about it but there's nothing but a mediocre description on Wikipedia of the CGA. Let's say you run MS-DOS, and DOS writes to a certain memory address expecting a CGA register, but instead an MCGA card is present, what happens? While I understand the basic premise of hardware and emulation, I don't yet understand how various pieces of hardware with different specifications can just work together like that. <br /><br />PS: Sorry for asking this so late, but I just today remembered your reply.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6075">ArsonIzer</a> — Thu Oct 03, 2013 1:55 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2013-09-18T06:03:43-07:00</updated>
<published>2013-09-18T06:03:43-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118233#p118233</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118233#p118233"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118233#p118233"><![CDATA[
Now attempting a segue back to topic.<br /><br />We've been discussing aspects of an emulated CPU that can help determine whether an emulator is fast or slow:<br /><ul><li>how complex the emulated CPU is </li><li>instructions per clock (higher can sometimes be emulated faster) </li><li>clock speed (higher usually means emulated slower) </li></ul>Instructions in the 8080 family (8080, Z80, Game Boy, 8086) tend to take far more cycles than instructions on a 6502. This makes a 6502 as fast as an 8080 family CPU at a much higher clock rate. This is how the NES and Atari 800 got away with a 1.8 MHz 6502 when the ColecoVision, MSX, Master System, and Game Gear were using a 3.6 MHz Z80: the higher IPC cancels out the lower clock rate. The same is true of 65816 in the Super NES and the 68000 in the Genesis, much to the chagrin of Sega &quot;blast processing&quot; fanboys. But an emulator is mostly concerned with the externally visible behavior: 1. how many instructions it can run, and 2. whether the reads, writes, and interrupts happen on the correct cycle relative to the other devices on the bus.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Wed Sep 18, 2013 6:03 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2013-09-18T01:54:41-07:00</updated>
<published>2013-09-18T01:54:41-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118225#p118225</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118225#p118225"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118225#p118225"><![CDATA[
koitsu - I'm dead tired and typing this from my laptop in bed, but good work. That was fast. I'll check it out in more detail tomorrow.<br /><br />ArsonIzer - Nope, the 8086 on it's own has no FPU at all fortunately. What you're thinking of is the 8087 co-processor (edit: koitsu beat me to it) which is required by virtually no software out there. I don't really understand the FPU stuff in detail either. As for graphics, emulating CGA and 320x200 256-color MCGA is dead simple to emulate compared to the NES. Not even close, really. They're simple bitmaps (CGA is interlaced, but it's still simple) mapped in the CPU's address space. Couldn't be any easier. If you really want to be super-accurate there is scanline timing involved, but for 99.999% of programs it doesn't matter.<br /><br />Yes, I implemented the graphics in my emu. (everything except EGA and 640x480 4-color VGA, but I'll get to that eventually)<br /><br />There are some screenshots from it here: <!-- m --><a class="postlink" href="http://sourceforge.net/projects/fake86/">http://sourceforge.net/projects/fake86/</a><!-- m --><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Wed Sep 18, 2013 1:54 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[koitsu]]></name></author>
<updated>2013-09-18T01:51:36-07:00</updated>
<published>2013-09-18T01:51:36-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118224#p118224</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118224#p118224"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118224#p118224"><![CDATA[
<div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><br />Another thing, doesn't the 8086 have an FPU? I can only assume that for the mathematical dimwits like myself, it's a hell to implement. Of course, I'm assuming this, maybe the FPU isn't hard at all to implement.<br /></div><br /><!-- m --><a class="postlink" href="http://en.wikipedia.org/wiki/Intel_8086#Floating_point">http://en.wikipedia.org/wiki/Intel_8086#Floating_point</a><!-- m --><br /><br />TL;DR -- 8086 has support for an FPU add-on chip (mainboards would have sockets for it), usually the Intel 8087 (but some others made their own), which you'd buy, plug in, and <a href="http://www.csee.umbc.edu/courses/undergraduate/CMSC313/fall07/burt/CMSC313_lectures/Floating%20Point/floatingPoint.html" class="postlink">get a bunch more opcodes and FPU-specific registers</a>.  I imagine emulating this really isn't that bad, considering that any present-day language you'd use (C, etc.) could &quot;emulate&quot; this using standard mathematical operations within the programming language itself, along with some limitations you'd have to write in/code in yourself.  I wouldn't imagine it'd be all that bad.<br /><br />Just reviewing that page, particularly all the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">qword ptr [edi+ebx]</tt> crap, is just further stuff that makes me hate x86.  It's so easy to get lost in the syntax and &quot;addon words&quot; to the assembly language portion.  I swear, when/when not to use things like <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">dword ptr</tt> and brackets for certain addressing modes/methods, was such a pain in the ass.  I remember doing 320x200 graphics (segment A000 (or A0000 in protected mode)) and was saying things like &quot;Why the hell do I have to use brackets here?  I don't get it, I'm not wanting indirect addressing... or am I?  GRAAAHHHH!!!&quot; and &quot;Why can't I just hard-code the value of the address I want to use in the instruction?  Why must I use a register?&quot;<br /><br />Sorry, 65xxx just makes all this stuff really bloody obvious when you look at it.  Not to a newbie, no, but there's a lot LESS to grasp overall.  I find the syntax to be easier to understand.  Friends of mine who have tried repeatedly to learn 65xxx (I think 6502 in particular) but fail, for example, have no problem learning LISP.  This still baffles my mind to no end, from a syntactical standpoint anyway.  It's one of those things where if I could sit down with them for a week and step them through basic assembly programming I think they'd understand it, but languages that add tons of crap on top -- or abstraction of any sort -- make it harder for the person to actually know what's going on under the hood.  Off-topic big time, but this is exactly why I loathe things like Java.  Too many layers of crap that can go wrong between you and the CPU.  :-)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3">koitsu</a> — Wed Sep 18, 2013 1:51 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[ArsonIzer]]></name></author>
<updated>2013-09-18T01:21:06-07:00</updated>
<published>2013-09-18T01:21:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118220#p118220</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118220#p118220"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118220#p118220"><![CDATA[
<div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><br /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent">Writing your first CPU emulator is one hell of a learning experience for sure. My first was the 8086. That was.... taxing.<br /></div><br /><br />Haha I have to give it to you, you've got some guts to do that as your first emulator. I think I would've thrown away my laptop and lived in the woods after becoming permanently paranoid if I had to do that with the knowledge I had prior to making the 6502. Even now, I think the 8086 would be a major, several-month challenge to me that would have a pretty big chance of failure to be honest. I do, however, plan to emulate one at some point. The NES is just a start in my journey (hopefully) <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /></div><br /><br />Well, if you can do the 6502 you can definitely do the 8086. The most confusing thing on the 8086 is understanding the addressing mode byte (aka mod/reg/rm byte)... once you get that it's really not much harder. There are more opcodes and more addressing modes, so it will take more time. There are also &quot;group&quot; opcodes where the first instruction byte indicates which group, then it has a modregrm byte where one of it's fields indicates the exact operation. It can get pretty weird. Oh and there are segments to worry about too, but that's not so bad. Yeah, it DID take a few months before I was able to boot DOS.<br /><br />If you get around to doing it, let me know if you want a little help. Once you understand the couple confusing aspects, it does become about as easy as the 6502. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div><br /><br />The thing that scares me about the 8086 is the huge and more complex x86 architecture. The few dozen 6502 opcodes compared to a washing list of instructions seems like hell to me, and all the terminology you're using while arguing with the other guys is like a foreign language. I had literally no experience with lower level stuff like I mentioned before, so to get to the point of knowledge you guys have would take me many years, and that's how long I'm guessing it would take me to get an 8086 running, let alone have it run DOS (which is actually a long-term goal I have for emulation). Another thing, doesn't the 8086 have an FPU? I can only assume that for the mathematical dimwits like myself, it's a hell to implement. Of course, I'm assuming this, maybe the FPU isn't hard at all to implement. <br /><br />Another thing would be the graphics. If I actually wanted to RUN DOS like DosBox does (running actual games as well), I'd have to implement some kind of complex graphics card (relative to the NES or SNES). Did you manage to do that too?<br /><br />PS: I will definitely take you up on that. The moment I start on an 8086 is the moment you might receive 200 messages a day of me flipping out because I can't get another opcode right. Watch your spambox my friend.<br /><br />PPS: Just kidding, but seriously, if I ever get started on that I might ask you some questions if that's ok <img src="http://forums.nesdev.com/images/smilies/icon_razz.gif" alt=":P" title="Razz" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6075">ArsonIzer</a> — Wed Sep 18, 2013 1:21 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[koitsu]]></name></author>
<updated>2013-09-18T00:34:11-07:00</updated>
<published>2013-09-18T00:34:11-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118213#p118213</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118213#p118213"/>
<title type="html"><![CDATA[Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10495&amp;p=118213#p118213"><![CDATA[
Found a <a href="http://www.mathemainzel.info/files/x86asmref.html" class="postlink">better opcode list</a> (thank you people who actually document how opcodes affect CPU flags, sheesh).  So:<br /><br />* The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov ah,al</tt> now make sense because you're essentially just wanting to fill memory with a value (16 bits at a time).  Got it.<br /><br />* The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">jnc done</tt> is indeed to deal with even/odd number of bytes, and in the case of an odd number, to store the last byte (since <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> copies 16 bits at a time).  The carry being set or clear comes from the preceding <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">shr cx, 1</tt>.  So okay, got it.  Easy enough to do in 65816, but again the length (number in CX) actually matters because of the whole mvn/mvp vs. manual loop situation.<br /><br />For shits and giggles lets just say we're trying to fill 513 bytes of data (an odd number) with the value $ffff, but only a byte is specified ($ff).  Cycle counts per opcode are in brackets (<tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">[]</tt>).<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  sep #$30             ; &#91;3&#93; Set A/X/Y to 8-bit size <br />  lda #$ff             ; &#91;2&#93; $ff = upper and lower half of the 16-bit value we want to fill<br />  tay                  ; &#91;2&#93; Copy A ($ff) into Y<br />  xba                  ; &#91;3&#93; Swap upper and lower bytes of A (yes you can do this when A size is 8-bit!)<br />  tya                  ; &#91;2&#93; Copy Y ($ff) into lower byte of A; 16-bit A now contains $ffff<br />  rep #$30             ; &#91;3&#93; Set A/X/Y to 16-bit size<br />  tay                  ; &#91;2&#93; Y=$ffff<br />  lda #513             ; &#91;3&#93; 513 bytes to transfer (odd number)<br />  lsr                  ; &#91;2&#93; Divide by 2, A will now contain 256 ($100) with carry set to 1<br />  bcs OddNum           ; &#91;!&#93; If carry set, then lsr had a leftover (i.e. odd number)<br />  tax                  ; &#91;2&#93; X = number of words (16-bits) to write<br />  tya                  ; &#91;2&#93; A=$ffff<br />- sta &gt;ESDILocation,x  ; &#91;6&#93; Write $ffff to ESDILocation+X offset (full 24-bit address) -- LOOP<br />  dex                  ; &#91;2&#93; ...repeat -- LOOP<br />  bne -                ; &#91;!&#93; ....until X=0 -- LOOP<br />  sep #$30             ; &#91;3&#93; Set A/X/Y to 8-bit<br />  bra Done             ; &#91;3&#93; GTFO<br />OddNum:<br />  tax                  ; &#91;2&#93; X = number of words (16-bits) to write<br />  tya                  ; &#91;2&#93; A=$ffff<br />- sta &gt;ESDILocation,x  ; &#91;6&#93; Write $ffff to ESDILocation+X offset (full 24-bit address) -- LOOP<br />  dex                  ; &#91;2&#93; ...repeat -- LOOP<br />  bne -                ; &#91;!&#93; ....until X=0 -- LOOP<br />  sep #$30             ; &#91;3&#93; Set A/X/Y to 8-bit -- LOOP<br />  sta &gt;ESDILocation    ; &#91;6&#93; Write that odd byte ($ff) to ESDILocation (same as ESDILocation,x in this case) -- LOOP<br />Done:<br /></div><br /><br />The cycle count labelled <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">[!]</tt> is 2 cycles if the branch IS NOT taken, otherwise is 3 cycles.  In most cases in the above code, it will be taken.<br /><br />Is this optimised?  No.  More on that in a moment.<br /><br />Is it ugly and long?  Yes, because most of the work stems from the &quot;setup&quot; -- first the need to take an 8-bit accumulator value and copy the value into the high byte of the accumulator, and then dealing with the number of bytes and so on.  If I had made this in a &quot;general subroutine&quot; where you'd simply push the byte you wanted filled onto the stack, followed by another push of the length (in bytes), the routine would be a lot shorter and maybe use less cycles.  Not sure.<br /><br />The reason the code looks doubled (more or less) is because I did not care to elegantly handle the situation where the number of bytes being transferred was odd vs. even (i.e. storing something in a temporary variable to indicate such, etc.).  My focus was not on code length but a bit more on cycles.  It's totally possible to make this routine shorter and handle the odd vs. even thing in a more sane manner.<br /><br /><span style="font-size: 150%; line-height: normal"><strong>ANYWAY...  ;-)</strong></span><br /><br />The most important part here is the cycle counts within the loops (I've labelled them with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">-- LOOP</tt>, including the odd-byte count where the sep #$30 is actually needed (to write an 8-bit value vs. 16-bit) and the actual write itself).<br /><br />So let's do the math of the loops, given the number of iterations within the loops that we know:<br /><br />513 bytes = $100 (256) loop iterations + 9 extra cycles (sep + sta at the end)<br /><br />Loop itself: 6 cycles for the sta + 2 cycles for the dex + 3 cycles for the bne (except the last iteration which will be 2 cycles)<br /><br />So: 255 * (6 + 2 + 3) = 2805 cycles<br />2805 cycles + 2 cycles for the non-branch-taken bne = 2807 cycles<br />2807 cycles + the 9 extra cycles (sep + sta at the end) = 2816 cycles<br /><br />To repeat: is it possible to optimise this routine?  Absolutely.  Getting rid of the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta &gt;ESDILocation,x</tt> (24-bit addressing, STA Absolute Long Indexed X) and turning it into <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta ESDILocation,x</tt> (16-bit addressing, STA Absolute Indexed X) is the best choice, since you save 1 cycle per every <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta</tt> in that case.  The catch is that you have to know in advance what the bank of the 24-bit address ESDILocation is, and that's doable in lots of ways (again: how a programmer chooses to design things).<br /><br />The reason I chose to use a 24-bit addressing STA is because [ES:DI] -- it's been a while, so if I get this wrong, I apologise -- allows you to write to any segment (ES) starting at offset DI, up to 65536 bytes.  I wanted to make this &quot;easy&quot;, so I just went with a linear 24-bit addressing store.  More realistically though, as I said, setting B (bank) to the destination followed by a 16-bit store would save a cycle per every loop iteration, and is &quot;more akin&quot; to the segmented memory model (hard to explain what I mean by this, sorry, it's late and I'm tired (see below)) in this way, along with the &quot;up to 65536 byte&quot; limitation too.<br /><br />Another optimisation possibility is to do self-modifying code.  I'm not sure how much time this would save so this is speculative.  I've written such code, but I really don't enjoy it and try to stay away from it on the 65816.  On 6502, with only 64K of addressing space (and often even less RAM and ROM) it's more common.<br /><br />There is also the possibility of using a stack-based copying method, which may save other cycles.  I will admit it has been a long time since I've used <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">pea/pei</tt> to do this, so my familiarity there is a bit rusty, but I'm sure I could figure it out.  Note: I used this methodology in the aforementioned link (re: demo/utility group) to do some text scrolling.  There's a point where the stack-based method is faster than the manual loop.<br /><br />So I imagine it is very possible to get the cycle count down to the low-2000s for the same number of bytes (words) transferred.<br /><br />Now let's bring <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> into the picture (rather than a manual loop), but speaking on a general level because I took diphenhydramine and melatonin earlier and I'm really getting dozy (plus angry that I've spent time doing this rather than reading my awesome scifi book in comfy bed, but hey that's my own fault not anyone elses):<br /><br />The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> opcodes take a whopping <strong>7 cycles <span style="text-decoration: underline">PER BYTE</span> moved</strong>.  Not per word (16-bit), but per byte.  The CPU does the move itself (entire CPU blocks/waits until the opcode is done, obviously).  Whether it operates internally on a per-byte basis or per-word, I do not know, but I bet you it's per-byte given the nature of how it works.  Yeah, it's expensive.<br /><br />I hope someone else here (probably byuu) comes along and says &quot;holy shit dude, that routine is crap, you are REALLY out of practise&quot; and optimises the hell out of it.  That's how the guys at MIT did things on the old PDPs -- they would literally revamp or optimise each other's code to shave off cycles or bytes here and there.  Hell, Bill Gates did this too.<br /><br />Now you see why a little inexpensive DMA chip alongside the 65816 for memory transfers really, really helps.<br /><br />P.S. -- Despite my sort of annoyed/irritated tone (just how I am, nothing personal), this is probably the most thorough 65816 I've done since working on the SNES/SFC many years ago and my days in the IIGS scene.  <strong>BIG</strong> nostalgia for me here.  Really brought back memories -- especially since my IIGS is sitting in a storage bin behind me.  I also had to bust out ActiveGS (didn't have KEGS laying around) to run the IIGS mini-assembler (<tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">call -151 ; !</tt>) to write some code to test some of my theories about certain opcodes behaving certain ways in 8-bit vs. 16-bit mode.  So thank you, miker00lz, for the trip back in time.  I do appreciate it.<br /><br />P.P.S. -- I edited the initial code at the start to remove use of a temporary DP variable because I realised I could safely use other registers for it.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3">koitsu</a> — Wed Sep 18, 2013 12:34 am</p><hr />
]]></content>
</entry>
</feed>