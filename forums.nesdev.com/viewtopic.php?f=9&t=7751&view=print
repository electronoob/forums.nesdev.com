<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - All-in-one dev cart for NES</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">All-in-one dev cart for NES</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=9&amp;t=7751">http://forums.nesdev.com/viewtopic.php?f=9&amp;t=7751</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sat May 14, 2011 4:13 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>All-in-one dev cart for NES</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hey guys,
<br />
<br />I've been working on a project lately that's similar to the PowerPak.  Basically I love the idea of the PowerPak but really want to make my own for fun and as a learning experience.  I would also like to make a portable NES at some point and then incorporate my hardware so I don't need to carry NES carts around in my pocket, which I hear doesn't work so well... 
<br />
<br />The main differences between my setup and the PowerPak is I'm using an Atmega664 and Xilinx CPLD vice a FPGA.  I basically chose this because of I have experience with the two and none with FPGAs and NES programming.  I almost went with a FPGA but I didn't want to figure out the configuration issues.  Plus since I'm starting off with the actual MMC3 and MMC1 original chips really all I need my logic to do is MUX up the correct mapper's signal and recreate some of the basic CNROM/UNROM mappers etc.  So my CPLD should suffice with nearly every pin spoken for, and I can always upgrade down the road.
<br />
<br />I'm also going with SD micro vice CF, and programming my RAM chips with the atmega vice the NES like the powerpak does.  Because of this I'm starting off with a external user interface to select the desired rom instead of an onscreen selection.  I recognize on screen would be better but I don't have any NES programming experience yet.  So that may be something I play with down the road.
<br />
<br />To start off, I'm going to set my goal to allow all standard logic mappers (ie CN/UN/ANROM)  and MMC1 and MMC3.  This covers most of the games I own.  Something I'd like to add is Tengen rambo1 for Rolling Thunder and MMC5 for StarTropics.  But that wouldn't be until I have better idea what I'm working with and get a multilayer PCB made up so I can go surface mount for everything allowing more room to play with.
<br />
<br />My IC lineup:
<br />Atmega644 (may go the atmega1284)
<br />Xlinix XCC-9572 CPLD
<br />WRAM- 32K SRAM (thinner dip version)
<br />PRG/CHR ROM/RAM- alliance 512KB SRAM  as6c4008 (not pictured)
<br />MMC3 (on SMB3 board)
<br />MMC1 (to add on the right socket)
<br />MUXs, counters, etc for programming the ROMs (not pictured to be added beneath the SMB3 board)
<br />
<br />Anyways, Just thought I'd share my project with everyone.  And open it up to comments, questions, and suggestions.  
<br />-Paul
<br />
<br /><a href="http://www.infiniteneslives.com/img/images/MasterCart.jpg" class="postlink">Big image: MasterCart.jpg</a>
<br />
<br />I don't really expect anyone to be able to read it but I've got my block diagram up too, if you're curious.
<br /><a href="http://www.infiniteneslives.com/img/images/MasterCartBD.jpg" class="postlink">Big image: MasterCartBD.jpg</a>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat May 14, 2011 4:20 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Priceless</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />There are some things money can't buy.
<br /><img src="http://www.retrousb.com/includes/languages/english/images/buttons/unavailable.png" alt="Image" />
<br />For everything else there's MasterCart.
<br />
<br />According to BootGod's NesCartDB, StarTropics is MMC6, which is MMC3 with different PRG RAM enable. You might be able to paper over the differences in your CPLD, or you might not. MMC5 is for Castlevania 3 and a bunch of Koei games.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sat May 14, 2011 4:39 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />HAHA that's awesome <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />  The powerpak was actually temporarily unavailable when I originally though up the idea, so there's more truth to that comment than one might think. 
<br />
<br />Yeah, sorry I had MMC5 on the brain from this morning.  I meant MMC6.  I haven't looked into MMC6 much but I did see a quick note that it was similar to MMC3.  Once I get it up and working I wanted to look into it more.  That would be cool if it was easy enough to just play around with the PRG RAM enable.  Maybe I'll be able to play Star Tropics sooner than I thought!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>qbradq</b> [ Sat May 14, 2011 6:00 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I am <strong><em>VERY</em></strong>[/imfasis] interested in this project! I have all the NES programming skills you'll need for the project, just let me know what you want and what the hardware interface is.
<br />
<br />I also have experience with AVR micro-controllers and can help you there if you need it.
<br />
<br />I have looked into doing a project somewhat similar to this, but failed as I do not have enough hardware and CPLD knowledge.
<br />
<br />I have already implemented MMC3 in Verilog, but you'd need the next larger CPLD family to fit it (or at least I did, I don't know much about this stuff).
<br />
<br />Have you thought about using a larger CPLD for implementing all of the mappers, then using the JTAG port to reprogram the mapper code for every game? That's basically what the PowerPak does, but with an FPGA. You could cut down on burn-in problems by storing the current mapper number of the CPLD in the EEPROM of the AVR and only re-program the mapper CPLD when needed.
<br />
<br />Anyhow, let me know what you need. I'll do anything I can to help out. Graphics, NES / AVR coding, heck I'll even code Verilog for you if you need it (test benches too), I'm just not terribly good with it <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" />
<br />
<br />And if Microsoft will ever pay me for my dang game I can help pay for a prototype <img src="./images/smilies/icon_mad.gif" alt=":x" title="Mad" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sat May 14, 2011 9:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />WOW I didn't really think anyone would be interested in teaming up with me on this.  I guess that's the beauty of open source though.  So I'm curious what makes this project appealing?  Is it just for fun?  Or is there something better about it than the power pak?  I don't own a power pak and don't know a whole lot about it beyond what the site advertises.  My end goal isn't just to  make a copy power pak but if there are things that the powerpak leaves to be desired I'm curious what.  Is it because it's not open source?  Does the addition of a microcontroller have significant benefits over the power pak?
<br />
<br />Of course maybe your just like me qbradq in that you want to make something yourself.
<br />
<br />It would be really cool if you were able to do NES programming to allow for an inscreen menu rom selection.   I've taken an AVR assembly class and that's where my assembly knowledge stops.   I might be able to use some help with AVR programming as well.   Right now I'm trying to work out the SD card interface so I can program the ROMs and test out some basic mappers.  Right now time is my biggest issue though, but hopefully that will change when classes get out in a month.  
<br />
<br />I'm taking a intro to VLSI class right now and and learning Verilog right now.  But that's awesome that you've already got a working MMC3.  I wanted  to get the MMC1 and MMC3 integrated in with my logic instead of using the actual hardware, but this was the easy way for me to start.  What do you require from a CPLD to pack the MMC3 into it?  I knew it wouldn't fit in mine, and expected to upgrade to an FPGA whenever I moved from the MMC hardware.    I basically got the biggest Xilinx CPLD I could that I could throw in a socket and stay through hole.  
<br />
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> Have you thought about using a larger CPLD for implementing all of the mappers, then using the JTAG port to reprogram the mapper code for every game? That's basically what the PowerPak does, but with an FPGA. You could cut down on burn-in problems by storing the current mapper number of the CPLD in the EEPROM of the AVR and only re-program the mapper CPLD when needed. </div>
<br />
<br />I think if we were going to go this route an FPGA is the answer.  It solves both the logic capabilities and the any burnin issues.  We would have to do something similar to the power pak if we went this route.  I've found a project that uses SD card and MCU to configure the FPGA so we'd have to do similarly with our atemga.
<br />
<br />
<br />You bring up a bunch of things that are a little farther down the pipeline than I was originally planning for the immediate future.  But this is really because I was setting my immediate goals based on my skill set.  I'd be willing to make some changes to my current design to incorporate some of these goals, I just want to take small steps making sure basic things go well before tackling bigger things like non-standard mappers.
<br />
<br />The one major thing I would have figure out is how to interface the NES and atmega.  I'm not really sure how this would work but here's what I'm imagining.  The transistion between steps is what I'm really fuzzy on.
<br />
<br />1) AVR boots and loads NES assembly and interface graphics to my PRG/CHR rams.  Including the current list of available roms.
<br />
<br />2) NES boots off that data and gives you the on screen rom selection menu.
<br />
<br />3) User selects a rom and that gets communicated to the atmega somehow.  Perhaps the NES writes to a specific location in WRAM or something?  So the AVR would be waiting for a PRG /WR signal, and it would look at the value on the prg data bus.  That number on the bus could then correlate to the rom number selected.
<br />
<br />4) The AVR then needs to take control away from the NES so it can write the rom to PRG and CHR ram.  
<br />
<br />5) The NES starts to execute the game.
<br />
<br /> I'm thinking the only way to make steps 4 and 5 work is to hold the reset button on the NES console.  So the NES isn't trying to execute garbage data and all kinds of bus conflicts while the atmega is writing to the ram chips.  Is there a way to a software reset?  Or handle this issue some other way?  
<br />
<br />I guess the power pak gets around this by having the NES program everything and then just points it's self to start executing the game.  But this isn't really where I want to go with this.
<br />
<br />I imagined getting around this whole issue by a using a hard user interface with the cart front with some push buttons and 7seg displays.  You could just hold reset on the console since you're already at the console while everything was programming. 
<br />
<br />I'm not too concerned about money for a prototype.  Really the hardware is pretty cheap.  The multilayer PCB is what starts to get spendy.  My controller conversion business brings in enough play money for me to splurge on stuff like this.  
<br />
<br />I kind of want to stick with through hole for right now, then once things are rolling and the hardware requirements are more clearly defined I could order up some more finalized boards and surface mount most everything.  
<br />
<br />And if there were people interested in it the project and wanted one themselves board cost would quickly become a non-issue.  But I'm not really counting on this, I expected to just do everything myself and have everyone tell me I'm crazy for wasting all my time and money.  And that I should have just bought a power pak:)  But who knows.
<br />
<br />
<br />If we really knew what we were doing it would be cool to incorporate a state saver and all other kinds of craziness.  But that's not really a goal of mine.   I'm not a big fan of "cheating"  IMO if a game is too difficult to beat and I just keep trying over and over again great, you've consumed large amounts of my time that's that video games are for...  It just gives an even bigger sense of accomplishment at the end.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun May 15, 2011 4:48 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />The PRG ROM won't need to be taken off the bus while loading the game if the AVR talks to the SD card and feeds whole bytes to the NES, one at a time. Then the menu code copies the bytes to the RAM that implements PRG ROM, much as the PowerPak's menu reads bytes from the CF card's ATA interface. But the NES will have to pause for a moment while the AVR boots so that the menu can get loaded. Unless you have a (tiny) boot ROM in the cartridge, you'll have to somehow feed the NES a bunch of jog-in-place instructions.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>qbradq</b> [ Sun May 15, 2011 5:00 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">WOW I didn't really think anyone would be interested in teaming up with me on this.  I guess that's the beauty of open source though.</div><br /><br />Yes, yes it is <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> My project was also open source. I knew I lacked the hardware knowledge to get it to work and was hoping someone would pitch in <img src="./images/smilies/icon_redface.gif" alt=":oops:" title="Embarassed" /><br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">So I'm curious what makes this project appealing?  Is it just for fun?  Or is there something better about it than the power pak?  I don't own a power pak and don't know a whole lot about it beyond what the site advertises.  My end goal isn't just to  make a copy power pak but if there are things that the powerpak leaves to be desired I'm curious what.</div><br /><br />The PowerPak does not work on clone systems (like the Yobo for instance) and that is a deal breaker for me. Support for the clone systems is going to be very important to the future of the NES as a development platform. It's a major advantage we have over some of the other homebrew platforms.<br /><br />Also using an SD card is a huge improvement.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">Of course maybe your just like me qbradq in that you want to make something yourself.</div><br /><br />I'd much rather by one off the shelf, but seeings as how none exist yet... <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">It would be really cool if you were able to do NES programming to allow for an inscreen menu rom selection.   I've taken an AVR assembly class and that's where my assembly knowledge stops.   I might be able to use some help with AVR programming as well.   Right now I'm trying to work out the SD card interface so I can program the ROMs and test out some basic mappers.  Right now time is my biggest issue though, but hopefully that will change when classes get out in a month.</div><br /><br />Not a problem. There is plenty of code floating around the net, and even several FAT32 implementations we can use <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> Remember, it's not reading the data off the drive that's the hard part, it's making sense of the file system that is challenging. I will slap a test bed together with my Arduino board and get to work on this.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">What do you require from a CPLD to pack the MMC3 into it?  I knew it wouldn't fit in mine, and expected to upgrade to an FPGA whenever I moved from the MMC hardware.</div><br /><br />I ended up needing the 144 macro cell version, although I got the distinct impression that I was doing it wrong. Unfortunately I don't seem to have that code any more. I never uploaded it to SVN because I didn't want to "clutter the branch". That's usually a bad call <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /><br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">You bring up a bunch of things that are a little farther down the pipeline than I was originally planning for the immediate future.  But this is really because I was setting my immediate goals based on my skill set.  I'd be willing to make some changes to my current design to incorporate some of these goals, I just want to take small steps making sure basic things go well before tackling bigger things like non-standard mappers.</div><br /><br />Small steps, got 'cha <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> What you are proposing here would fill the need I am trying to get filled, so I am content with that.<br /><br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">1) AVR boots and loads NES assembly and interface graphics to my PRG/CHR rams.  Including the current list of available roms.</div><br /><br />The problem here is that the NES expects a reset vector to be available at CPU address $FFFC - $FFFD basically the instant you power up, and then the code that points to just a few clocks latter.<br /><br />Seems to me the best way to address this is to include an 8KB (or 16 or 32) ROM on the board with the boot loader and menu system and have the power-on state of the board be to mirror all PRG reads to that 8KB ROM. Then this program would interface with the AVR to load program data into the RAMs, configure / set the mapper and turn control over to the program.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">3) User selects a rom and that gets communicated to the atmega somehow.  Perhaps the NES writes to a specific location in WRAM or something?  So the AVR would be waiting for a PRG /WR signal, and it would look at the value on the prg data bus.  That number on the bus could then correlate to the rom number selected.</div><br /><br />Using an AVR to detect and react to the changing states of the address and data buses turns out to be a lot harder than it sounds, timing-wise. That's a tough problem really. Perhaps an 8-bit parallel to serial latch register on the data lines, with the latch line wired to R//W could be used.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">4) The AVR then needs to take control away from the NES so it can write the rom to PRG and CHR ram.</div><br /><br />The AVR taking control won't happen too easily, but here's one way that springs to mind:<br /><br />1. Copy over the following routine from the boot loader into the NES's RAM<br />2. Executing from RAM, signal the AVR that it's safe to write to the CHR / PRG RAMs.<br />3. Wait for some signal from the AVR that it's time to execute the program (maybe an IRQ?).<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">I'm thinking the only way to make steps 4 and 5 work is to hold the reset button on the NES console.  So the NES isn't trying to execute garbage data and all kinds of bus conflicts while the atmega is writing to the ram chips.  Is there a way to a software reset?  Or handle this issue some other way?</div><br /><br />No software resets, sorry. The best we can do is jump to the restart routine to fake the program into thinking it is just powering up, but no way to effect the hardware itself.<br /><br />You will either need to put a bus buffer on all PRG and CHR buses so you can disconnect them from the NES or you will need to allow the NES to program the PRG and CHR chips.<br /><br />Now that we've talked it through, using the NES to program this chips probably is the best solution. We would have to have some way of passing data at high speed from the AVR to the boot loader, then have a command for the AVR to enable / disable the /WE lines of the RAMs.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">I guess the power pak gets around this by having the NES program everything and then just points it's self to start executing the game.  But this isn't really where I want to go with this.</div><br /><br />Why? It seems to me to be the same thing, just one is doing everything on an AVR while the other has a (very small) routine on the NES to bang bits. And again if we run this routine out of system RAM we won't be stomping on ourselves or anything.<br /><br /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">If we really knew what we were doing it would be cool to incorporate a state saver and all other kinds of craziness.  But that's not really a goal of mine.   I'm not a big fan of "cheating"  IMO if a game is too difficult to beat and I just keep trying over and over again great, you've consumed large amounts of my time that's that video games are for...  It just gives an even bigger sense of accomplishment at the end.</div>
<br />
<br />I agree with that. State saving requires direct access to the hardware, something we won't have. All we see is a slice of the buses. Now retaining and reloading SRAM is a must, otherwise games like Zelda and Final Fantasy will not be very playable.
<br />
<br />That introduces more issues. Storing the data is easy, just write it to the SD card with some kind of hash value or long file name. As for restoring that data that's a no-brainier too, just load it the same way you do everything else.
<br />
<br />The hard part is when and how to read the SRAM. One solution that springs to mind is this:
<br />
<br />1. Provide a conventional battery-backup circuit for the SRAM.
<br />2. Store what game you have loaded in the EEPROM of the AVR.
<br />3. At power-up, read the game info from the AVR to determine if we need to back up the SRAM from last time.
<br />4. If so, read the SRAM and feed it back to the AVR for saving to the SD card.
<br />
<br />One thing you might want to keep in mind is that may games use RAM instead of ROM for their CHR memory. You will need to understand that the /OE and /WE lines of your CHR-RAM will need to be attached to the CHR bus as well. I couldn't tell from your block diagram if you had taken that into account.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>3gengames</b> [ Sun May 15, 2011 7:13 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />My bad, was pointing to the all-in-one console. Sorry for my stupidity. But yeah the powerpak is there, but still I wouldn't hesitate to do it if I were you. Seems like a great challenging project! There's the Tototek SNES flash cart and the Super PowerPak. Doesn't seem like a bad thing for more tech to be made especially if you have fun with it! Good luck. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Grumskiz</b> [ Sun May 15, 2011 7:55 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />@3gengames
<br />I think they are talking about a PowerPak like development cart and not a new NES clone or something.
<br />Maybe I misunderstood your post, but it seems to me like you misunderstood this thread due to a misleading title that fooled me before.
<br />
<br />
<br /><strong>[Good point. Preposition added. --MOD]</strong>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sun May 15, 2011 12:49 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> Using an AVR to detect and react to the changing states of the address and data buses turns out to be a lot harder than it sounds, timing-wise. That's a tough problem really. Perhaps an 8-bit parallel to serial latch register on the data lines, with the latch line wired to R//W could be used. </div><br /><br /><br />Correct me if I'm wrong. I agree you latch idea would work, but if we were running at 20Mhz wouldn't we have around 10 clock cycles to catch the bus's data?  <br /><br />A thought: Doesn't the cart have a 21Mhz clock available to it?  Is that just an undivided clock that the CPU is running off of?  What if we drove our atmega off that clock?  Would that help out with timing issues?  Could we watch the bus and then sync up with the CPU?  Let me know if I'm crazy.<br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> Not a problem. There is plenty of code floating around the net, and even several FAT32 implementations we can use Very Happy Remember, it's not reading the data off the drive that's the hard part, it's making sense of the file system that is challenging. I will slap a test bed together with my Arduino board and get to work on this. </div><br /><br />I've been going off this guy's work:<a href="http://frank.circleofcurrent.com/cache/fat_sd.htm" class="postlink">http://frank.circleofcurrent.com/cache/fat_sd.htm</a>  got stuck somewhere with something doubly defined or something and couldn't find where I was doing it...  I need to sit back down with it.<br /><br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You will either need to put a bus buffer on all PRG and CHR buses so you can disconnect them from the NES or you will need to allow the NES to program the PRG and CHR chips.<br /><br />Now that we've talked it through, using the NES to program this chips probably is the best solution. We would have to have some way of passing data at high speed from the AVR to the boot loader, then have a command for the AVR to enable / disable the /WE lines of the RAMs. </div><br /><br />Yeah when you spell it out like that I agree.  The 30 buffers might be okay on surface mount but not with what I've got now.  I guess we're trading sitting on our ass for the 30 sec it takes to program for getting up and hitting reset for a few seconds it would take for the AVR to program it.  Now that I think about it the avr won't be 10x faster because it's getting the data from the SD card serially.  So the time difference is negligible 25 seconds vice 30... I'd rather sit on my ass and take a beer break.<br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> The hard part is when and how to read the SRAM. One solution that springs to mind is this:<br /><br />1. Provide a conventional battery-backup circuit for the SRAM.<br />2. Store what game you have loaded in the EEPROM of the AVR.<br />3. At power-up, read the game info from the AVR to determine if we need to back up the SRAM from last time.<br />4. If so, read the SRAM and feed it back to the AVR for saving to the SD card.<br /><br />One thing you might want to keep in mind is that may games use RAM instead of ROM for their CHR memory. You will need to understand that the /OE and /WE lines of your CHR-RAM will need to be attached to the CHR bus as well. I couldn't tell from your block diagram if you had taken that into account.</div><br /><br />Yeah I was kind of delaying the game save for after things were working well.  I would like to have a plan though atleast for now to save the WRAM save data.<br /><br />I think the power pak does this when coming out of reset after you've played a game you want to save.  Which seems logical.  Couldn't we just have that as a menu option?  We could even take note that we just came out of reset from a savable game and prompt the user to save?  And if there weren't battery data just go back to the menu?<br /><br />So we would just copy the SRAM to the SD card and move on.  And not have to bother with saving it to EEPROM and comparing and everything?<br /><br />Yeah I do understand about the CHR-RAM/ROM.  I know it needs to be handled, I just didn't include it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> The PRG ROM won't need to be taken off the bus while loading the game if the AVR talks to the SD card and feeds whole bytes to the NES, one at a time. Then the menu code copies the bytes to the RAM that implements PRG ROM, much as the PowerPak's menu reads bytes from the CF card's ATA interface. But the NES will have to pause for a moment while the AVR boots so that the menu can get loaded. Unless you have a (tiny) boot ROM in the cartridge, you'll have to somehow feed the NES a bunch of jog-in-place instructions.</div><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The problem here is that the NES expects a reset vector to be available at CPU address $FFFC - $FFFD basically the instant you power up, and then the code that points to just a few clocks latter.<br /><br />Seems to me the best way to address this is to include an 8KB (or 16 or 32) ROM on the board with the boot loader and menu system and have the power-on state of the board be to mirror all PRG reads to that 8KB ROM. Then this program would interface with the AVR to load program data into the RAMs, configure / set the mapper and turn control over to the program.<br /></div>
<br />
<br />This is what I was most concerned about...  I want to try to figure out how we're going to do this with the hardware as the first priority.  We need to clearly define the interface between the NES and AVR.  
<br />
<br />The issue is communicating the selected rom , save data, and menu navigation.
<br />
<br />I like the idea of a small chunk of memory I'd like to go with SRAM and either battery back it or we could require the user to hold the reset button at console power up and then load the boot menu and everything we needed to it.  I'm kinda thinking it would be nice if it were dual ported, but I'm not sure.
<br />
<br />So then instead of Prg /CE enabling our PRG-ROM we'd have it enable our "BOOT-RAM".  I'd like it to be as small as possible like 8K.  Now that I think about it though...  I've already replaced my 8K of WRAM with 32KB SRAM.  What if we just put our boot menu in the upper 24-16K of my WRAM?  And make it appear to be $FFFC - $FFFD to the NES.  We'd have to control all this with logic and the AVR.
<br />
<br />We'd still be requiring the user to hold reset durring the initial power up, so we could load our boot menu, but that's it.  And still use the lower 8K of my WRAM for it's original purpose.  
<br />
<br />Just brain storming here.  I'm all ears for ideas and pointing out where my knowledge is flawed.
<br />
<br />P.S.  you guys will have to let me know how I can make the user name show up in my quotes. I couldn't find anything in the FAQ.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sun May 15, 2011 1:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Thinking about my idea of using the memory I already have still has the issue with the AVR accessing it so things can be communicated back and forth...  
<br />
<br />Perhaps if my "WRAM/BOOTRAM" were dual ported???
<br />
<br />If this sounds like a good solution to ya'll I'm interested in what your suggestions are for specific part numbers.  
<br />
<br />Here's what I'm thinking:
<br />
<br />-16K minimum, could be 8K if separated from the WRAM and have the NES copy and load our save data too.
<br />-asynchronous
<br />-dual ported
<br />-through hole or J-lead package that's socket-able.  Something that can be easily prototyped now, but be moved to a surface mount package with the final layout.  This isn't a firm requirement, I could easily make a surfboard for it if it were a coarser surface mount part, but this would be preferred.
<br />
<br />I'm not finding a lot that meets this though.  So that may trash this idea...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Sun May 15, 2011 1:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I made <a href="http://www.parodius.com/~memblers/nes/squeedo/" class="postlink">a cart</a> that is somewhat like this, about 6 or 7 years ago.  I used a PIC18 because it had a parallel port peripheral, which made communication with the NES dead simple.  I don't know if the AVR has something similar, I never used one but I guess not.  Mistake I made in the first version was not putting the RS232 transceiver on board, instead there was a 6-pin header with TTL-level serial on it because I figured that would allow interface boards for RS232, MIDI, or an SD card.  But I only got as far as doing RS232 with it, and having that on a separate board just made it more of a pain to build.  Now it's also easier to get an MCU that has 3 more UARTs on it, no need to share the same one for everything.
<br />
<br />I don't think you'll be able to use the 21Mhz clock.  I don't know what the clock signal looks like exactly, but I do know that absolutely nothing ever used it, and it was dropped entirely from the top-loading NES.  So I doubt it would be on any clones (and it's definitely not on Famicom or Famiclones).
<br />
<br />My board used just a few 74HCxx parts for the mapper, I didn't know how to use a CPLD at the time.  Sometime (before too long I hope) I'm going to redesign the board to work in a much smarter, and extremely more powerful setup.  I guess the big difference with the mappers I've been coming up with is that I never gave a crap about it being compatible with Nintendo's ASIC mappers.  Since I figured it's optimized for writing new stuff, where using the old ASIC mappers are more of a hindrance than anything.  A big focus on my mapper wasn't just using the PIC to handle boring system tasks, but to use it more like a coprocessor for the NES.  It was really successful at it, I got 4 channels of wavetable sound out of it, and had it able to handle lots of other stuff at the same time.
<br />
<br />Yeah, for dual-ported RAM I don't think there is anything appropriate to use.  For my redesign I've wanted that, and I've settled on using a fast synchronous SRAM and making a homemade memory controller for it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sun May 15, 2011 2:12 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> I used a PIC18 because it had a parallel port peripheral, which made communication with the NES dead simple. I don't know if the AVR has something similar, I never used one but I guess not.</div>
<br />
<br />What do you mean by parallel port peripheral?  I'm missing something here...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun May 15, 2011 2:18 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">infiniteneslives wrote:</div><div class="quotecontent">A thought: Doesn't the cart have a 21Mhz clock available to it?</div><br />NTSC NES has the undivided 21.5 MHz clock. PAL NES has the undivided 26.6 MHz clock (I think). Famicom has no undivided clock.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">We could even take note that we just came out of reset from a savable game and prompt the user to save?  And if there weren't battery data just go back to the menu?</div><br />This is exactly what the PowerPak does, based on the battery bit.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The issue is communicating the selected rom , save data, and menu navigation.</div><br />It might be possible to do all the FAT work on the 6502, as the PowerPak does, and consign the AVR to just reading and writing SD sectors.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So then instead of Prg /CE enabling our PRG-ROM we'd have it enable our "BOOT-RAM".</div><br />Ever heard of something called a "suicide battery"?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I've already replaced my 8K of WRAM with 32KB SRAM.  What if we just put our boot menu in the upper 24-16K of my WRAM?</div><br />Then 1. the three SXROM games (PR8 and two Japan-only RPGs) that use all 32 KB would interfere with the boot menu, and 2. loss of battery power would render the cart inoperable.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">We'd still be requiring the user to hold reset durring the initial power up</div><br />That could be a pain and lead to tech support calls and even product returns from people who don't RTFM. What's the cost of this support, compared to the cost of, say, a 2 KiB ROM chip that can load the full menu (mcart.ipl) from the root directory?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">P.S.  you guys will have to let me know how I can make the user name show up in my quotes. I couldn't find anything in the FAQ.</div>
<br />You can click the "quote" button at the top right of a post, which inserts the BBCode syntax [quote="tepples"]...[/quote].

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>infiniteneslives</b> [ Sun May 15, 2011 3:03 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"> NTSC NES has the undivided 21.5 MHz clock. PAL NES has the undivided 26.6 MHz clock (I think). Famicom has no undivided clock. </div><br /><br />I'm ready to ditch the thought of using the cart's clock.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Ever heard of something called a "suicide battery"?<br /><br />Quote:<br />I've already replaced my 8K of WRAM with 32KB SRAM. What if we just put our boot menu in the upper 24-16K of my WRAM?<br /><br />Then 1. the three SXROM games (PR8 and two Japan-only RPGs) that use all 32 KB would interfere with the boot menu, and 2. loss of battery power would render the cart inoperable.<br /><br />Quote:<br />We'd still be requiring the user to hold reset durring the initial power up<br /><br />That could be a pain and lead to tech support calls and even product returns from people who don't RTFM. What's the cost of this support, compared to the cost of, say, a 2 KiB ROM chip that can load the full menu (mcart.ipl) from the root directory? </div>
<br />
<br />Some of these issues are of non-concern to me right now.  I didn't really plan on selling these and providing support for them.  Not to say that I'll never consider it though. 
<br />
<br />Battery backed ram is a good option for what I'm already working with.  I'll just fix it myself if I kill the battery.  Or, just do without the battery and have the AVR load it up while the user is holding reset during power up. (although I'm not certain this will work)
<br />
<br />I also don't care much about SXROM games right now like I said before I want to get the basic logic mappers and MMC1 and MMC3 in their more common board configurations.  If this whole project became really refined though I agree with the use of a 2KiB rom chip in a final draft type stage.  This would be a simple upgrade from the hardware already used by the prototype.
<br />
<br />I like all of these points though, and it's best to think about how it could be made better and allow for simple improvements to be made in the future that would add the capabilities people might be looking for.  Right now I'm heavily limited by the fact I'm sticking to through hole components.  But I'd rather find out what works and what doesn't on something that's easy to modify.  I don't want to drop significant money on a multilayer PCB that ends up being a rough and drafty design that's difficult to modify.  I can't do as much with surface mount components and hidden wire runs.  
<br />
<br />I'm going to lean on the simplest options now, and take notes as I go on how I want to improve it for the next draft.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>