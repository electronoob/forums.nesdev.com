<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=9&amp;t=656" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2005-10-15T23:29:54-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=9&amp;t=656</id>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2005-10-15T23:29:54-07:00</updated>
<published>2005-10-15T23:29:54-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5552#p5552</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5552#p5552"/>
<title type="html"><![CDATA[Rare's &quot;Stop-n-swop&quot; technique on NES]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5552#p5552"><![CDATA[
Ugh, flood! :)  I see you changed the constants from APPLEsci to ASCII, so it'd work with a normal terminal.<br /><br />I'm now testing the MMC3 IRQ behavior. One problem I encountered was finding a cartridge with IRQ vectors that point into RAM. I wasn't able to, so I used the Game Genie to alter the IRQ vector at $fffe and $ffff. That is working, and I'm now beginning the IRQ testing.<br /><br />Since my code can run before the Game Genie loads, I figured out how to write to the Game Genie registers (trivial to determine in an emulator, just run the Game Genie ROM and enter various codes while looking at the writes to $8000-$ffff). I doubt there's any way to re-enable it once its ROM has been hidden, except perhaps by pulsing one of the lines (which I plan on trying, since my Game Genie has DIP chips rather than glop tops).<br /><br />I'm having so much fun testing all this hardware which I thought I wouldn't have access to.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Oct 15, 2005 11:29 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[drk421]]></name></author>
<updated>2005-10-15T13:49:21-07:00</updated>
<published>2005-10-15T13:49:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5538#p5538</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5538#p5538"/>
<title type="html"><![CDATA[Rare's &quot;Stop-n-swop&quot; technique on NES]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5538#p5538"><![CDATA[
As a test for my UART, I ported Woz's Apple 1 monitor (256 bytes!).<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />;Wozniak Apple1 Monitor<br />;written by Wozniak in 1975<br /><br />   .inesprg 1<br />   .ineschr 0<br />   .inesmir 1<br />   .inesmap 1<br /><br />   .bank 1<br /><br />   .org $FE00   ; Rom Start<br /><br />;******* Hardware Variables ************<br /><br />UART = $5400<br />UARTLCR = $5403<br />UARTLSR = $5405<br /><br />;********* Zero Page Variables *********<br /><br />TEMP = $54<br />XAML = $24<br />XAMH = $25<br />STL  = $26<br />STH  = $27<br />L    = $28<br />H    = $29<br />YSAV = $2A<br />MODE = $2B<br /><br />;******** $200-$27F Text Buffer *********<br /><br />IN = $0200<br /><br />;******** Listing *************<br /><br /><br />Init:          SEI             ;Clear decimal arithmetic mode.<br />                CLD             ;Clear Interrupt disable bit.                <br />               LDX #$00<br />                LDY #$00<br />                LDA #$00<br /><br />               STA $2000<br />               STA $2001<br /><br />UARTInit:       <br />                LDA #$80<br />                STA UARTLCR<br /><br />                LDA #$0C<br />                STA UART<br /><br />                LDA #$00<br />                STA $5401<br /><br />                LDA #$03<br />                STA UARTLCR<br /><br />                LDA #$00<br />                STA $5401<br />      STA $5404<br /><br />                LDY #$7F        ;Mask for DSP data direction register<br />                ;STY UART         ;Set it up.<br />                LDA #$A7        ;KBD and DSP control register mask.<br />                ;STA KBDCR       ;Enable interrupts, set CA1, CB1, for<br />                ;STA DSPCR       ;postitive edge sense/output mode.<br /><br />NOTCR:          <br />                CMP #$08        ;&quot;&lt;-&quot;?<br />                BEQ BACKSPACE   ;Yes.<br />                CMP #$1B        ;ESC?<br />                BEQ ESCAPE      ;Yes.<br />                INY             ;Advance text index.<br />                BPL NEXTCHAR    ;Auto ESC if &gt; 127.<br /><br />ESCAPE:         <br />                LDA #$5C        ;&quot;\&quot;.<br />                JSR ECHO        ;Output it.<br /><br />GETLINE:        <br />                LDA #$0D        ;CR.<br />                JSR ECHO   ;Output it.<br />                LDY #$01        ;Initiallize text index.<br /><br />BACKSPACE:      <br />                DEY             ;Backup text index.<br />                BMI GETLINE     ;Beyond start of line, reinitialize<br />                ;LDA KBDCR       ;Key ready?<br /><br />NEXTCHAR:       <br />                LDA UARTLSR<br />                AND #$01<br />                BEQ NEXTCHAR    ;Loop until ready.<br />                LDA UART         ;Load character. B7 shoul be '1'<br />           ;STA UART<br />                STA IN,Y        ;Add to text buffer.<br /><br />                JSR ECHO        ;Display character.<br /><br />                CMP #$0D        ;CR?<br />                BNE NOTCR       ;No.<br />                LDY #$FF        ;Reset text index.<br />                LDA #$00        ;For XAM mode.<br />                TAX             ;0-&gt;X.<br /><br />SETSTOR:        <br />                ASL A           ;Leaves $7B if setting STOR mode.<br /><br />SETMODE:        <br />                STA &lt;MODE        ;$00 = XAM, $7B = STOR, $A3 = BLOK XAM<br /><br />BLSKIP:         <br />                INY             ;Advance text index.<br /><br />NEXTITEM:       <br />                LDA IN,Y        ;Get character.<br />                CMP #$0D        ;CR?<br />                BEQ GETLINE     ;Yes, done this line.<br />                CMP #$2E        ;&quot;.&quot;?<br />                BCC BLSKIP      ;Skip delimiter.<br />                BEQ SETMODE     ;Set BLOCK XAM mode.<br />                CMP #$3A        ;&quot;:&quot;?<br />                BEQ SETSTOR     ;Yes, set STOR mode.<br />                CMP #$52        ;&quot;R&quot;?<br />                BEQ RUN         ;Yes, run user program.<br />                STX &lt;L           ;$00-&gt;L.<br />                STX &lt;H           ;and H.<br />                STY &lt;YSAV        ;Save Y for comparison.<br /><br />NEXTHEX:        <br />                LDA IN,Y        ;Get character for hex test.<br />                EOR #$30        ;Map digits to $0-9.<br />                CMP #$0A        ;Digit?<br />                BCC DIG         ;Yes.<br />                ADC #$88        ;Map letter &quot;A&quot;-&quot;F&quot; to $FA-FF.<br />                CMP #$FA        ;Hex letter?<br />                BCC NOTHEX      ;No, character not hex.<br /><br />DIG:            <br />                ASL A<br />                ASL A            ;Hex digit to MSD of A.<br />                ASL A            <br />                ASL A            <br />                LDX #$04        ;Shift count.<br /><br />HEXSHIFT:       <br />                ASL A            ;Hex digit left, MSDB to carry.<br />                ROL &lt;L           ;Rotate into LSD.<br />                ROL &lt;H           ;Rotate into MSD's.<br />                DEX             ;Done 4 shifts?<br />                BNE HEXSHIFT    ;No, loop.<br />                INY             ;Advance text index.<br />                BNE NEXTHEX     ;Always taken. Check next character for hex.<br /><br />NOTHEX:         <br />                CPY &lt;YSAV        ;Check if L, H empty &#40;no hex digits&#41;<br />                BEQ ESCAPE      ;Yes, generate ESC sequence.<br />                BIT &lt;MODE        ;Test MODE byte.<br />                BVC NOTSTOR     ;B6 = 0 for STOR, 1 for XAM and BLOCK XAM<br />                LDA &lt;L           ;LSD's of hex data.<br />                STA &#91;STL,X&#93;     ;Store at current 'store index'.<br />                INC &lt;STL         ;Increment store index.<br />                BNE NEXTITEM    ;Get next item. &#40;no carry&#41;.<br />                INC &lt;STH         ;Add carry to 'store index' high order.<br /><br />TONEXTITEM:     <br />                JMP NEXTITEM    ;Get next command item.<br /><br />RUN:            <br />                JMP &#91;XAML&#93;      ;Run at current XAM index.<br /><br />NOTSTOR:        <br />                BMI XAMNEXT     ;B7 = 0 for XAM, 1 for BLOCK XAM.<br />                LDX #$02        ;Byte count.<br /><br />SETADR:         <br />                LDA &lt;STH,X      ;Copy hex data to<br />                STA &lt;XAMH,X     ;'store index'.<br />                STA &lt;$23,X      ;And to 'XAM index'.<br />                DEX             ;Next of 2 bytes.<br />                BNE SETADR      ;Loop unless X = 0.<br /><br />NXTPRNT:        <br />                BNE PRDATA      ;NE means no address to print.<br />                LDA #$0D        ;CR.<br />                JSR ECHO        ;Output it.<br />                LDA &lt;XAMH        ;'Examine index' high-order byte.<br />                JSR PRBYTE      ;Output it in hex format.<br />                LDA &lt;XAML        ;Low-order 'examine index' byte.<br />                JSR PRBYTE      ;Output it in hex format.<br />                LDA #$3A        ;&quot;:&quot;.<br />                JSR ECHO        ;Output it.<br /><br />PRDATA:         <br />                LDA #$20        ;Blank.<br />                JSR ECHO        ;Output it.<br />                LDA &#91;XAML,X&#93;    ;Get data byte at 'examine index'<br />                JSR PRBYTE      ;Output it in hex format.<br /><br />XAMNEXT:        <br />                STX &lt;MODE        ;0-&gt;MODE &#40;XAM mode&#41;.<br />                LDA &lt;XAML<br />                CMP &lt;L           ;Comapre 'examine index' to hex data.<br />                LDA &lt;XAMH        <br />                SBC &lt;H<br />                BCS TONEXTITEM  ;Not less, so no more data to output.<br />                INC &lt;XAML        <br />                BNE MOD8CHK     ;Increment 'examine index'.<br />                INC &lt;XAMH<br /><br />MOD8CHK:        <br />                LDA &lt;XAML        ;Check low-order 'examine index' byte<br />                AND #$07        ;For MOD 8=0<br />                BPL NXTPRNT     ;Always taken.<br /><br />PRBYTE:         <br />                PHA             ;Save A for LSD.<br />                LSR A<br />                LSR A<br />                LSR A            ;MSD to LSD position.<br />                LSR A<br />                JSR PRHEX       ;Output hex digit.<br />                PLA             ;Restore A.<br /><br />PRHEX:          <br />                AND #$0F        ;Make LSD for hex print.<br />                ORA #$30        ;Add &quot;0&quot;.<br />                CMP #$3A        ;Digit?<br />                BCC ECHO        ;Yes, output it.<br />                ADC #$06        ;Add offset for letter.<br />                ;BIT DSP         ;DA bit &#40;B7&#41; cleared yet?<br />                ;BMI ECHO        ;No, wait for display<br /><br />ECHO:<br />                STA &lt;TEMP<br />ECHOLOOP:       LDA UARTLSR         ;Output character. Sets DA.<br />                AND #$20<br />                BEQ ECHOLOOP<br />                LDA &lt;TEMP<br />                STA UART<br />                CMP #$0D   ;if output is CR then<br />                BEQ LINEFEED   ;linefeed<br />                RTS             ;Return.<br /><br />LINEFEED:       LDA UARTLSR<br />                AND #$20<br />                BEQ LINEFEED<br />                LDA #$0A<br />      STA UART<br />      LDA #$0D<br />      RTS<br /><br />   .bank 1<br />   .org $FFFA<br /><br />   .dw 0<br />   .dw Init<br />   .dw 0<br /><br />;End<br /><br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=45">drk421</a> — Sat Oct 15, 2005 1:49 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2005-10-15T11:33:25-07:00</updated>
<published>2005-10-15T11:33:25-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5535#p5535</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5535#p5535"/>
<title type="html"><![CDATA[Rare's &quot;Stop-n-swop&quot; technique on NES]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5535#p5535"><![CDATA[
I haven't written any kind of monitor yet. The only resident code is the loader, which I usually jump to at the end of any test code so it's ready to re-load. It's so easy to run new code that I just keep tweaking the asm code and re-running it. I was thinking of writing a small driver that allows the PC to request memory reads and writes, to allow interactive testing.<br /><br />As for serial, it's in software running at 57.6 kbps. The only hardware is a MAX-232 level-shifter connected to the second joypad port, using the strobe for send and D0 to receive. It uses a simple checksum when loading code, and it hasn't ever gotten a bad checksum since I got it working over a year ago.<br /><br />I've done more dumps and tests and it usually doesn't crash when swapping most cartridges. I wrote a small program that generates a tone with $4011 until you press a button on the joypad, to tell if it's crashed while swapping. I've been able to put a cartridge in and jiggle it, pop it up and down, etc. without it crashing.<br /><br />This technique should work with any kind of devcart, so it's a viable means of dumping any NES game without any elaborate copy hardware.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Oct 15, 2005 11:33 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[drk421]]></name></author>
<updated>2005-10-15T10:07:18-07:00</updated>
<published>2005-10-15T10:07:18-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5531#p5531</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5531#p5531"/>
<title type="html"><![CDATA[Rare's &quot;Stop-n-swop&quot; technique on NES]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5531#p5531"><![CDATA[
blargg,<br />do you have a machine language monitor for your RS-232 based comm?<br /><br />Are you doing RS-232 in software, or using a UART?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=45">drk421</a> — Sat Oct 15, 2005 10:07 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2005-10-15T05:33:56-07:00</updated>
<published>2005-10-15T05:33:56-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5522#p5522</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5522#p5522"/>
<title type="html"><![CDATA[Rare's &quot;Stop-n-swop&quot; technique on NES]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=656&amp;p=5522#p5522"><![CDATA[
Taking a cue from <a href="http://www.rare-extreme.com/?section=tourofrare&amp;page=stop_n_swop.html" class="postlink">Rare's rumored "stop-n-swop" cartridge system</a> for N64, where you swap game cartridges while the system is powered, I peformed the CIC disabling modification on my NES. I had the idea to copy my RS-232-based loader into low-memory from my devcart, eject the cart <em>with the power still on</em>, then insert a normal game cartridge, for the purpose of getting access to its mapper, etc.<br /><br />The idea works (though it takes several tries until I get the game in without my code crashing as I insert it, much to the dismay of my NES cartridge connector). I've been able to dump several MMC1 and UNROM games and get a checksum match with dumps on the net, save and restore battery RAM to my PC, and do some reverse-engineering of the MMC5 in Castlevania 3. I plan on doing more reverse-engineering of the MMC1, MMC3, and MMC5. It would be neat to figure out how to enable MMC5 sound (I see several empty pads on my CV3 board for various resistors, perhaps necessary for digital-to-analog conversion).<br /><br />I was also able to dump my US Game Genie ROM (it matches what's on the main nesdev page). I should also be able to access its custom hardware for reverse-engineering, in case anyone's interested.<br /><br />The final thing I want to try is restoring a complete snapshot from my emulator into the actual game. This will be tricky since the code will ultimately have to erase itself. I'm hoping I can find half a page of bytes in a given snapshot that all have the same value. Combined with the movie replayer I made a few days ago, this could allow recording of movies on an emulator and playback on a real NES from any point, not just the beginning. Since my SNES devcart is almost the same, I was thinking of trying something similar on the SNES.<br /><br />This might help me bootstrap to a better devcart. I was thinking of making one with flash RAM where the NES does the writing itself, using the serial interface with the PC. With this I could program the initial devcart, and easily program more for other people.<br /><br />All this started with Zelda board with a single trace rerouted so that the battery RAM is selected in place of the ROM... :)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Oct 15, 2005 5:33 am</p><hr />
]]></content>
</entry>
</feed>