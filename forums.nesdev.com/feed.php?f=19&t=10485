<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=19&amp;t=10485" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2013-10-06T11:29:06-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=19&amp;t=10485</id>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-10-06T11:29:06-07:00</updated>
<published>2013-10-06T11:29:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119029#p119029</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119029#p119029"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119029#p119029"><![CDATA[
Try running it inside an emulator with a debugger, such as FCEUX (windows build only), NO$NES, or Nintendulator. They should all let you look at the CHR-RAM and sprite memory and trace back why you're seeing squares.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Sun Oct 06, 2013 11:29 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[turboninja]]></name></author>
<updated>2013-10-06T11:04:11-07:00</updated>
<published>2013-10-06T11:04:11-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119027#p119027</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119027#p119027"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=119027#p119027"><![CDATA[
Well, my bad. It actually works. I had forgotten to turn off the rendering everywhere when I first did it. However, my sprites are not displayed any more now... Instead, I just have big squares. Help please <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6164">turboninja</a> — Sun Oct 06, 2013 11:04 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[turboninja]]></name></author>
<updated>2013-10-04T14:13:38-07:00</updated>
<published>2013-10-04T14:13:38-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118953#p118953</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118953#p118953"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118953#p118953"><![CDATA[
Thanks for the quick answer ! I just tried and unfortunately this does not solve the problem <img src="http://forums.nesdev.com/images/smilies/icon_sad.gif" alt=":(" title="Sad" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6164">turboninja</a> — Fri Oct 04, 2013 2:13 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-10-04T13:45:33-07:00</updated>
<published>2013-10-04T13:45:33-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118950#p118950</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118950#p118950"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118950#p118950"><![CDATA[
Here's some things that I immediately see:<br /><br />1- Don't leave the old stubs (from &quot;reset&quot; through &quot;nmi&quot;) in your code). They're misleading (and currently horrifically wrong)<br />2- You need to wait two vblanks before you start writing to any PPU register: see <!-- m --><a class="postlink" href="http://wiki.nesdev.com/w/index.php/PPU_power_up_state">http://wiki.nesdev.com/w/index.php/PPU_power_up_state</a><!-- m --><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Fri Oct 04, 2013 1:45 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[turboninja]]></name></author>
<updated>2013-10-04T12:45:09-07:00</updated>
<published>2013-10-04T12:45:09-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118948#p118948</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118948#p118948"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118948#p118948"><![CDATA[
Hello everybody,<br /><br />I am here because I have another problem with my code <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> hope I will be able to propose a clear release someday for the people who (just as me) want to play this Tron game on their old NES.<br /><br />Here is where I get stuck : switching from NES ROM to NES RAM. I definitely need to keep track of the tiles that have been visited and the other ones. So, I just tried to switch from NES ROM to NES RAM (to start with). But I am getting a lot of graphic mistakes (the graphical output has a totally unpredictable behaviour), though we can still play &quot;decently&quot;.<br /><br />Changing x in the line : (in the load_to_ppu routine)<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">   ldx #32  ; number of 256-byte chunks to load<br />     ldy #0<br /></div><br /><br />definitely modifies the behaviour of the game once compiled (for 32, we have decent sprites, for 16, something that looks like the title screen I had before trying to switch). I guess there must be some limitations I am not respecting, but I cannot figure out which one ! Some help would be more than welcome ! The whole code is below<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    ;;--- CODE START ---;;<br />    .inesprg 1<br />    .inesmap 0<br />    .inesmir 1<br />    .ineschr 0<br /><br />    .bank 1<br /><br />    .org $FFFA<br />    .dw 0        ; no VBlank<br />    .dw Start    ; address to execute on reset<br />    .dw 0        ; no whatever<br />    .bank 0<br />    .org $0000<br />    <br />reset:<br />    sei          ; disable IRQs<br />    cld          ; disable decimal mode<br />    ldx #$40<br />    stx $4017    ; disable APU frame IRQ<br />    ldx #$FF<br />    txs          ; Set up stack<br />    inx          ; now X = 0<br />    stx $2000    ; disable NMI<br />    stx $2001    ; disable rendering<br />    stx $4010    ; disable DMC IRQs<br /><br />nmi:<br />    lda        #$00<br />    sta        $2003        ; Set the low byte (00) of the ram address<br />    lda        #$02<br />    sta        $4014        ; Set the high byte (02) of the RAM address,<br />    <br />; actually, these variables could be stored in only one byte<br />; maybe a little bit less...<br /><br />PPUMASK = $2001<br />PPUADDR = $2006<br />PPUDATA = $2007<br /><br />speed1_Up:   .db 0<br />speed1_Left:   .db 0<br />speed1_Down:   .db 0<br />speed1_Right:   .db 0<br />speed2_Up:   .db 0<br />speed2_Down:   .db 0<br />speed2_Left:   .db 0<br />speed2_Right:   .db 0<br />; actually, these variables could be stored in only one byte<br />speed1_Up_To_Be:   .db 0<br />speed1_Down_To_Be:   .db 0<br />speed1_Left_To_Be:   .db 0<br />speed1_Right_To_Be:   .db 0<br />speed2_Up_To_Be:   .db 0<br />speed2_Down_To_Be:   .db 0<br />speed2_Left_To_Be:   .db 0<br />speed2_Right_To_Be:   .db 0<br /><br />Sprite1_T_To_Be:     .db  0   ; sprite #1's Tile Number<br />Sprite2_T_To_Be:     .db  0   ; sprite #1's Tile Number<br /><br />edge_horiz1_pos:     .db 0<br />edge_vert1_pos:     .db 0<br />edge_horiz2_pos:    .db 0<br />edge_vert2_pos:     .db 0<br /><br />loop_count: .db 0<br /><br />addrLO: .db 0  ; make &quot;variable&quot;s for our indirect addressing<br />addrHI: .db 0<br /><br />vidlow: .db 0<br />vidhigh: .db 0<br /><br />src: .db 0<br /><br />    .org $0200 ; OAM Copy location $0300<br />;; THE FIRST TWO SPRITES REPRESENT THE MOTORBIKES<br />Sprite1_Y:     .db  0   ; sprite #1's Y value<br />Sprite1_T:     .db  0   ; sprite #1's Tile Number<br />Sprite1_S:     .db  0   ; sprite #1's special byte<br />Sprite1_X:     .db  0   ; sprite #1's X value<br />Sprite2_Y:     .db  0   ; same thing, same order for sprite #2<br />Sprite2_T:     .db  0   ; note that I numbered 1 2 ...<br />Sprite2_S:     .db  0   ; some people may actually prefer starting<br />Sprite2_X:     .db  0   ; the count at 0, but it doesn't really matter.<br />;; THESE SPRITES WILL REPRESENT THE SCORE OF EACH PLAYER<br />;; BETWEEN 0 AND 9<br />Sprite3_Y:     .db  0   ; <br />Sprite3_T:     .db  0   ; This will be the score of P1<br />Sprite3_S:     .db  0   ; <br />Sprite3_X:     .db  0   ; <br />Sprite4_Y:     .db  0   ;<br />Sprite4_T:     .db  0   ; This will be the score of P2<br />Sprite4_S:     .db  0   ;<br />Sprite4_X:     .db  0   ;<br /><br />    .org $8000  ; code starts at $8000 or $C000<br />Start:<br />    cld ; supposedly useless but, let's keep it for now<br /><br />    ldx #$00    ; clear X            ;; start of palette loading code<br />    lda #$3F    ; have $2006 tell<br />    sta $2006   ; $2007 to start<br />    lda #$00    ; at $3F00 (palette).<br />    sta $2006    <br />    <br />    jsr init_pal<br /><br />    jsr load_to_ppu<br />    jsr turn_on_PPU<br />    <br />    <br />    jsr init_background  ; calls the routine to load the backgrounds<br />    jsr init_players_positions<br />    jsr init_scores<br />    jsr init_sound<br />    jsr title_screen ; loads the title_screen<br />    <br />    <br />;; THE MAIN LOOP<br />infinite:  ; a label to start our infinite loop<br /><br />    jsr disp_Sprites_DMA<br />    jsr strobe_keypad1<br />    jsr update_keypad1   <br />    jsr move_charac1<br /><br />    inc loop_count ; this variable will enable to distribute operations over different steps of the loop_count<br /><br />    lda loop_count<br />    cmp #2<br />    beq modulo2<br /><br />    lda loop_count<br />    cmp #4<br />    beq modulo4<br /><br />    lda loop_count<br />    cmp #8<br />    beq modulo8<br />    <br />    jmp infinite<br /><br />modulo8:<br />    clc ;; THIS THING IS FUCKING MANDATORY AFTER A CMP<br />    ;; OTHERWISE, ODD EFFECTS WILL APPEAR<br />    jsr update_speed1<br />    ldx #0<br />    stx loop_count<br />    jmp infinite<br />    <br />modulo4:<br />    clc<br />    ldy Sprite1_Y<br />    cpy #24<br />    bne south_test<br />    jsr player1_loose<br />south_test:<br />    clc<br />    cpy #224<br />    bne west_test<br />    jsr player1_loose<br />west_test:<br />    clc<br />    ldy Sprite1_X<br />    cpy #248<br />    bne modulo4rts<br />    jsr player1_loose<br />modulo4rts:<br />    clc<br />    jmp infinite<br />    <br />modulo2:<br />    clc<br />    ldy Sprite1_X<br />    cpy #2<br />    bne modulo2rts<br />    jsr player1_loose<br />modulo2rts:<br />    clc<br />    jmp infinite<br />    <br />update_keypad1:<br />    lda $4016  ; load Abutton Status ; note that whatever we ain't interested   <br />    lda $4016  ; load Bbutton Status ; in we just load so it'll go to the next one.<br />    lda $4016  ; load Select button status<br />    lda $4016  ; load Start button status<br />    lda $4016  ; load UP button status<br />    and #1      ; AND status with #1<br />    bne UPKEYdown  ; for some reason (not gonna reveal yet), need to use NotEquals<br />    ;with ANDs. So it'll jump (branch) if key was down.<br />    lda $4016  ; load DOWN button status<br />    and #1     ; AND status with #1<br />    bne DOWNKEYdown<br />    lda $4016  ; load LEFT button status<br />    and #1     ; AND status with #1<br />    bne LEFTKEYdown<br />    lda $4016  ; load RIGHT button status<br />    and #1     ; AND status with #1<br />    bne RIGHTKEYdown<br />    ;ldy $0<br />    jmp NOTHINGdown2  ; if nothing was down, we just jump (no check for conditions)<br />    ; down past the rest of everything.<br />    UPKEYdown:<br />        lda speed1_Down;_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda speed1_Down_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda #1<br />        sta speed1_Up_To_Be<br />        lda #0<br />        sta speed1_Left_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Right_To_Be<br />        sta Sprite1_T_To_Be<br />        jmp NOTHINGdown2  ; jump over the rest of the handling code<br />    DOWNKEYdown:<br />        lda speed1_Up;_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda speed1_Up_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda #1<br />        sta speed1_Down_To_Be<br />        lda #2<br />        sta Sprite1_T_To_Be<br />        lda #0<br />        sta speed1_Left_To_Be<br />        sta speed1_Right_To_Be<br />        sta speed1_Up_To_Be<br />        jmp NOTHINGdown ; jump over the rest of handling code.<br />    NOTHINGdown2:<br />        jmp NOTHINGdown<br />    LEFTKEYdown:<br />        lda speed1_Right;_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda speed1_Right_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda #1<br />        sta speed1_Left_To_Be<br />        lda #0<br />        sta speed1_Up_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Right_To_Be<br />        lda #3<br />        sta Sprite1_T_To_Be<br />        jmp NOTHINGdown<br />    RIGHTKEYdown:<br />        lda speed1_Left;_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda speed1_Left_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda #1<br />        sta speed1_Right_To_Be<br />        sta Sprite1_T_To_Be<br />        lda #0<br />        sta speed1_Up_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Left_To_Be<br />    NOTHINGdown:<br />        rts<br /><br />move_charac1:<br />    lda Sprite1_Y ; load A with Y position<br />    sbc speed1_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite1_Y; store back to memory<br />    lda Sprite1_Y<br />    adc speed1_Down  ; add 1 to A. ADC (Add with Carry)((to A register))<br />    sta Sprite1_Y<br />    lda Sprite1_X<br />    sbc speed1_Left<br />    sta Sprite1_X<br />    lda Sprite1_X<br />    adc speed1_Right<br />    sta Sprite1_X<br />    rts<br />    <br />move_charac2:<br />    lda Sprite2_Y ; load A with Y position<br />    sbc speed2_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite2_Y; store back to memory<br />    lda Sprite2_Y<br />    adc speed2_Down  ; add 1 to A. ADC (Add with Carry)((to A register))<br />    sta Sprite2_Y<br />    lda Sprite2_X<br />    sbc speed2_Left<br />    sta Sprite2_X<br />    lda Sprite2_X<br />    adc speed2_Right<br />    sta Sprite2_X<br />    rts<br /><br />player1_loose:  ;; the following could (and will) be improved, a loop would be cleaner !<br />    jsr make_sound<br />    ldx #16<br />    stx Sprite1_T<br />    ldy #16    <br />loopAnim:<br />    jsr disp_Sprites_DMA<br />    inc Sprite1_T<br />    jsr disp_Sprites_DMA<br />    nop<br />    dey<br />    bne loopAnim  <br />    jsr init_players_positions<br />    inc Sprite4_T ;Recall that Sprite4_T is also the score of P2<br />    ldy #0<br />    sty loop_count<br />    rts<br />    <br />player2_loose:<br />    jsr init_players_positions<br />    inc Sprite3_T<br />    ldy #0<br />    sty loop_count<br />    rts<br /><br />update_speed1:<br />    ldx speed1_Up_To_Be<br />    stx speed1_Up<br />    ldx speed1_Down_To_Be<br />    stx speed1_Down<br />    ldx speed1_Left_To_Be<br />    stx speed1_Left<br />    ldx speed1_Right_To_Be<br />    stx speed1_Right<br />    ldx Sprite1_T_To_Be<br />    stx Sprite1_T<br />    rts<br />    <br />update_speed2:<br />    ldx speed2_Up_To_Be<br />    stx speed2_Up<br />    ldx speed2_Down_To_Be<br />    stx speed2_Down<br />    ldx speed2_Left_To_Be<br />    stx speed2_Left<br />    ldx speed2_Right_To_Be<br />    stx speed2_Right<br />    ldx Sprite2_T_To_Be<br />    stx Sprite2_T<br />    rts<br /><br />disp_Sprites_DMA: ;; Displays all the sprites using Direct Memory Access. So cool<br />    waitblank:<br />        bit $2002  ; these 3 lines wait for VBlank, this loop will actually miss VBlank<br />        bpl waitblank ; alot, in a later Day, I'll give a better way.<br />    lda #2<br />    sta $4014<br />    lda #0;<br />    rts<br /><br />strobe_keypad1:<br />    lda #$01   ; these<br />    sta $4016  ; lines<br />    lda #$00   ; setup/strobe the<br />    sta $4016  ; keypad.<br />    lda #0;<br />    rts<br /><br />strobe_keypad2:<br />    lda #$01   ; these<br />    sta $4017  ; lines<br />    lda #$00   ; setup/strobe the<br />    sta $4017  ; keypad.$<br />    lda #0;<br />    rts<br /><br />init_pal:                ; this is a freaky loop<br />    lda palette, x  ; that gives 32 numbers<br />    sta $2007       ; to $2007, ending when<br />    inx             ; X is 32, meaning we<br />    cpx #32         ; are done.<br />    bne init_pal     ; if X isn't =32, goto &quot;loadpal:&quot; line.<br />    rts<br /><br />palette: <br />    ; this upper line is used for the background palette<br />    .db $0F,$2D,$16,$2C,$0F,$2D,$16,$2C,$0F,$2D,$16,$2C,$0F,$2D,$16,$2C<br />    ; this lower line is used for the sprites palette<br />    .db $0F,$08,$07,$06,$0F,$01,$03,$02,$0F,$3A,$3A,$3A,$0F,$3A,$3A,$3A<br /><br /><br />title_screen:<br />    jsr turn_off_PPU<br />    lda #255 ; These lines allow to scroll the background<br />    sta $2005 ; X POS first<br />    lda #0 ; Y POS <br />    sta $2005 ; store it at the same address<br />    jsr turn_on_PPU<br />title_screen_loop:    <br />    jsr strobe_keypad1<br />    lda $4016  ; load Abutton Status ; note that whatever we ain't interested   <br />    lda $4016  ; load Bbutton Status ; in we just load so it'll go to the next one.<br />    lda $4016  ; load Select button status<br />    lda $4016  ; load Start button status<br />    and #1      ; AND status with #1<br />    bne jump_to_rts_title_screen; for some reason (not gonna reveal yet), need to use NotEquals<br />    jmp title_screen_loop<br />    <br />jump_to_rts_title_screen:<br />    clc<br />    jsr turn_off_PPU<br />    lda #0<br />    sta $2005 ; This address regards scrolling<br />    lda #0<br />    sta $2005 <br />    jsr turn_on_PPU<br />    rts<br />    <br />;; THE SOUND PART<br />init_sound:<br />    lda #$FF   ; typical<br />    sta $4000  ; write<br />    lda #%11011011  ; % means binary number, remember the '#' for immediate values.<br />    sta $4001  ; immediate means &quot;not an address, just a number&quot;.<br />    rts<br />;; THIS COULD BE SOMEHOW IMPROVED, BUT IT IS NOT THE PRIORITY<br />make_sound: <br />    lda #$A5<br />    sta $4002<br />    lda #$AB<br />    sta $4003<br />    lda #%00000001<br />    sta $4015<br />    rts<br /><br />    <br />init_players_positions:<br />    clc ; once again, removing it would cause nasty bugs<br />    lda #0<br />    sta loop_count<br />    sta Sprite2_S;<br />    sta Sprite1_T;<br />    sta Sprite1_T_To_Be<br />    lda #1;<br />    sta Sprite2_T<br />    sta Sprite1_S;<br />    lda #124;<br />    sta Sprite1_X;<br />    sta Sprite2_X<br />    lda #164<br />    sta Sprite1_Y<br />    lda #124<br />    sta Sprite2_Y<br />    lda #0<br />    sta speed1_Down;    <br />    sta speed1_Right;    <br />    sta speed1_Left;<br />    sta speed1_Up;<br />    sta speed2_Down;    <br />    sta speed2_Right;    <br />    sta speed2_Left;<br />    sta speed2_Up;<br />    sta speed1_Down_To_Be<br />    sta speed1_Right_To_Be<br />    sta speed1_Left_To_Be<br />    sta speed2_Up_To_Be<br />    sta speed2_Right_To_Be<br />    sta speed2_Left_To_Be<br />    lda #1<br />    sta speed1_Up_To_Be<br />    sta speed2_Down_To_Be<br />    rts <br />    <br />init_scores:<br />    lda #6<br />    sta Sprite3_T<br />    sta Sprite4_T<br />    lda #0;<br />    sta Sprite3_S<br />    sta Sprite4_S<br />    lda #15<br />    sta Sprite3_Y<br />    sta Sprite4_Y<br />    lda #72<br />    sta Sprite3_X<br />    lda #238<br />    sta Sprite4_X<br />    rts<br />    <br />init_background: ; uses indirect addressing<br />    ldx #0<br />    lda #$20  ; set the destination address in PPU memory<br />    sta $2006  ; should be $2000<br />    stx $2006<br />    <br />    lda #low(background)   ; put the high and low bytes of the address &quot;backg&quot;<br />    sta addrLO        ; into the variables so we can use indirect addressing.<br />    lda #high(background)<br />    sta addrHI<br />    ldx #16  ; number of 256-byte chunks to load<br />    ldy #0<br />loopIndirectAddressing:<br />    lda &#91;addrLO&#93;,y<br />    sta $2007     ; load 256 bytes<br />    iny<br />    bne loopIndirectAddressing<br />;--------------------<br />    inc addrHI  ; increment high byte of address backg to next 256 byte chunk<br />    dex        ; one chunk done so X = X - 1.<br />    bne loopIndirectAddressing   ; if X isn't zero, do again<br />    <br />    rts<br /><br />;; OKAY, this is a little bit scarying, but it is ways better than using the strange<br />;; programs proposed to create the .bin files..<br /><br />load_to_ppu:<br />    ldy #0       ;; starting index into the first page<br />    sty PPUMASK  ;; turn off rendering just in case<br />    sty PPUADDR  ;; load the destination address into the PPU<br />    sty PPUADDR<br /><br />   lda #0  ; set the destination address in PPU memory<br />     sta $2006  ; should be $0000<br />     sta $2006<br />     lda #low(ppumem)   ; put the high and low bytes of the address ppumem<br />     sta vidlow        ; into the variables so we can use indirect addressing.<br />     lda #high(ppumem)<br />     sta vidhigh<br /><br />   ldx #32  ; number of 256-byte chunks to load<br />     ldy #0<br />ppuloop:<br />     lda &#91;vidlow&#93;,y<br />     sta $2007     ; load 256 bytes<br />     iny<br />     bne ppuloop<br />     inc vidhigh  ; increment high byte of address vidhigh to next 256 byte chunk<br />     dex        ; one chunk done so X = X - 1.<br />     bne ppuloop   ; if X isn't zero, do again<br />   rts<br /><br />turn_on_PPU:<br />    lda #%00001000  ;<br />    sta $2000       ;<br />    lda #%00011110  ; Our typical PPU Setup code.<br />    sta $2001       ;<br />    rts<br /><br />turn_off_PPU:<br />    lda #%00000000  ;<br />    sta $2000       ;<br />    lda #%00000000  ; Our typical PPU Setup code.<br />    sta $2001       ;<br />    rts<br /><br />title:<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,42,43,44,47,48,55,56,57,64,65,66,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,45,0,49,50,63,0,62,67,68,69,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,45,0,51,54,58,0,62,70,71,72,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,46,0,52,53,59,60,61,73,74,75,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,76,77,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,84,0,0,0,0,0<br />    .db 0,0,0,0,0,0,78,79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,86,0,0,0,0,0<br />    .db 0,0,0,0,0,0,80,81,82,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,87,88,89,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,30,32,19,33,33,0,33,34,15,32,34,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    <br />background:    <br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,16,39,0,24,35,26,23,19,28,0,32,19,36,19,26,26,19,0,0,0,0,0,0,0,7,5,6,8,0,0,0,0<br />    .db 0,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 30,26,15,39,19,32,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,30,26,15,39,19,32,0,7,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2    <br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2    <br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br /><br />ppumem: .incbin &quot;bkg.nes&quot;<br />my_sprites: .incbin &quot;sprites.nes&quot;<br /><br /><br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6164">turboninja</a> — Fri Oct 04, 2013 12:45 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[turboninja]]></name></author>
<updated>2013-09-19T07:18:05-07:00</updated>
<published>2013-09-19T07:18:05-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118278#p118278</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118278#p118278"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=118278#p118278"><![CDATA[
Ok ! Thank you so much ! I had time to realize my mistake reading some code that I found here and there. Indeed, I was lacking of clc and did not realize how important it was (this game is actually my first experience with assembly).<br /><br />Anyway, T H A N K  Y O U !<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6164">turboninja</a> — Thu Sep 19, 2013 7:18 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Kasumi]]></name></author>
<updated>2013-09-12T11:26:26-07:00</updated>
<published>2013-09-12T11:26:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117963#p117963</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117963#p117963"/>
<title type="html"><![CDATA[Re: Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117963#p117963"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />However, with this cmp line, the motorbike has a strange diagonal direction when I press the left and right keys (that should not happen at all) but works perfectly fine with up and down keys (which confuses me a lot). And without the cmp (just jumping to &quot;modulo&quot;) everything works perfectly fine as well.<br /></div><br />Sounds like you don't understand the carry flag. When you add (adc) or subtract (sbc) on the 6502, the state of the carry flag is taken into account to possibly add or subtract 1 more than the actual value given.<br /><br />To get the true value that will end up in the accumulator (A) for adc, the equation is A+value+C. (where C is the value of the carry flag.)<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda #$00<br />clc;Clears the carry<br />adc #$00<br />;A = #$00<br />A+value+C<br />#$00+#$00+#0 (because we cleared the carry flag) = #$00<br /></div><br />Now see this example where we set the carry instead, but change nothing else:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda #$00<br />sec;Sets the carry<br />adc #$00<br />;A = #$01<br />A+value+C<br />#$00+#$00+#1 (because we set the carry flag) = #$01<br /></div><br /><br />For SBC, it subtracts the OPPOSITE of the carry. So if the carry is 1 (set), sbc will subtract the value, and if it is 0 (clear) it will subtract the value and then it will subtract 1.<br /><br />Additionally, the carry is set or cleared after ADC and SBC depending on the result of the instruction. (Other instructions affect it as well, like cmp.) Here's a post that explains the carry in very great detail: <!-- l --><a class="postlink-local" href="http://forums.nesdev.com/viewtopic.php?p=112830#p112830">viewtopic.php?p=112830#p112830</a><!-- l --><br />Edit: Wait... that may not be the best post on the subject since it covers mainly 16 bit stuff. I swear I've written a good general one, and will look for it.<br /><br />So when you have this code here: <br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">move_charac1:<br />    lda Sprite1_Y ; load A with Y position<br /><br /><br />;What is the state of the carry before the following sbc? <br />;Because you don't set it, it's whatever the CPU last had it as. Effectively unknown!<br />;So you could be subtracting speed1_Up if it was last set, or speed1_Up and then another 1 if it was last clear!<br />;To remove this ambiguity, just use sec before an SBC when you don't know the<br />;state of the carry<br /><br /><br />    sbc speed1_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite1_Y; store back to memory<br /></div><br /><br />Like so:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">move_charac1:<br />    lda Sprite1_Y ; load A with Y position<br />    sec<br />    sbc speed1_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite1_Y; store back to memory<br /></div><br /><br />You should read this post right here for great detail: <!-- l --><a class="postlink-local" href="http://forums.nesdev.com/viewtopic.php?p=112830#p112830">viewtopic.php?p=112830#p112830</a><!-- l --> <br /><br />Edit: Wait... that may not be the best post on the subject since it covers mainly 16 bit stuff. I swear I've written a good general one, and will look for it.<br /><br />But the general rule is to set the carry before subtractions and clear it before additions if you don't know the state of it.<br /><br />Interesting tidbit: You say everything works fine without the cmp. Cmp affects the carry flag! So check this out:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    cmp #8<br />    beq modulo<br />    jmp infinite<br /></div><br />In the case A = 8, we jump to modulo. This means the carry is guaranteed set when we get to modulo. (cmp would set the carry in that case)<br />Nothing in update_speed1 affects it, so it's still set. Nothing in the rest of modulo affects it. So we jmp to infinite with it still set.<br /><br />In the case that A &lt; 8, we jump to infinite. (if A &lt; 8 when it hits the cmp, the carry would be cleared by cmp #8). So we jmp to infinite with it clear.<br /><br />Nothing in disp_Sprites_DMA affects it... <br /><br />Then we get to here: <br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">move_charac1:<br />    lda Sprite1_Y ; load A with Y position<br />    sbc speed1_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite1_Y; store back to memory<br /></div><br /><br />Because nothing has changed the carry between that cmp #8 and that code, when A = 8, we subtract speed1_Up, and when A &lt; 8 (i.e. most of the time), it's subtracting speed1_Up and another one.<br /><br />To fix, put a sec before that sbc. <br /><br />Put a sec before all your sbcs unless you're doing 16bit math or really know what you're doing.<br />Put a clc before all your adcs unless you're doing 16bith math or really know what you're doing.<br /><br />And I'll plug it a third time  <img src="http://forums.nesdev.com/images/smilies/icon_razz.gif" alt=":P" title="Razz" /> : <!-- l --><a class="postlink-local" href="http://forums.nesdev.com/viewtopic.php?p=112830#p112830">viewtopic.php?p=112830#p112830</a><!-- l --><br />Edit: Wait... that may not be the best post on the subject since it covers mainly 16 bit stuff. I swear I've written a good general one, and will look for it.<br />Edit2: Yep... sadly that's all I got. It should still explain things, if not ask some questions!<br /><br />Read that for full understanding.<br /><br />PS: I could be totally wrong about this being the cause of the problem, but your lack of sec/clc before additions and subtractions is definitely a problem on its own. If there's still a problem after you fix that, we'll solve it then.  <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3504">Kasumi</a> — Thu Sep 12, 2013 11:26 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[turboninja]]></name></author>
<updated>2013-09-11T15:42:13-07:00</updated>
<published>2013-09-11T15:42:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117930#p117930</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117930#p117930"/>
<title type="html"><![CDATA[Help ! can anyone see the mistake ?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10485&amp;p=117930#p117930"><![CDATA[
Hello everybody,<br /><br />I am new here, I looked into this forum and tutos regarding my problem but I could not find anything similar. So here I am. <br /><br />I am developing a Tron game (the one with the motorcycles seen from above, I always dreamt on playing this game on an actual NES, don't know why) with NESASM (it does not seem to be the best assembler but it has so many tutos and sources). I am now trying to constrain the user to move along a grid (grid defined as the border of the tiles composing the screen). So what I did is quite simple : save the input in the keypad and load it into the &quot;actual&quot; variables (the speed of the motorbike on every axis) every 8 time the program goes through the main loop. Here is the thing I am doing.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">infinite:  ; a label to start our infinite loop<br />    waitblank:<br />        bit $2002  ; these 3 lines wait for VBlank, this loop will actually miss VBlank<br />        bpl waitblank ; alot, in a later Day, I'll give a better way.<br /><br />    jsr disp_Sprites_DMA<br />    jsr move_charac1    <br />    jsr move_charac2    ; this is optional<br />    jsr strobe_keypad1<br />    jsr strobe_keypad2 ; this is optional<br />    jsr update_keypad1   <br />    <br />    ldx loop_count<br />    inx<br />    stx loop_count<br />    txa<br />    cmp #8<br />    beq modulo<br />    jmp infinite<br /><br />modulo:<br />    jsr update_speed1<br />    ldx #0<br />    stx loop_count<br />    lda #0;<br />    jmp infinite<br /></div><br /><br />However, with this cmp line, the motorbike has a strange diagonal direction when I press the left and right keys (that should not happen at all) but works perfectly fine with up and down keys (which confuses me a lot). And without the cmp (just jumping to &quot;modulo&quot;) everything works perfectly fine as well. <br /><br />So, here is my question, is it possible, by any chance, that I am overwriting some of my speed variables doing something that I do not suspect affects the &quot;speed&quot; variables ? (I am not very familiar with assembler, I don't know the kind of bugs it can produce)<br /><br />If somebody wants to try the whole code, here it is, with the files needed. Any help would be more than welcome  <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> <br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    ;;--- CODE START ---;;<br />    .inesprg 1<br />    .inesmap 0<br />    .inesmir 1<br />    .ineschr 1<br /><br />    .bank 1<br />    .org $FFFA<br />    .dw 0        ; no VBlank<br />    .dw Start    ; address to execute on reset<br />    .dw 0        ; no whatever<br />    .bank 0<br />    .org $0000<br /><br /><br />;; What follows will be useful to make sure the cycle follows the grid<br /><br /><br />    .org $0300 ; OAM Copy location $0300<br />;; THE FIRST TWO SPRITES REPRESENT THE MOTORBIKES<br />Sprite1_Y:     .db  0   ; sprite #1's Y value<br />Sprite1_T:     .db  0   ; sprite #1's Tile Number<br />Sprite1_S:     .db  0   ; sprite #1's special byte<br />Sprite1_X:     .db  0   ; sprite #1's X value<br />Sprite2_Y:     .db  0   ; same thing, same order for sprite #2<br />Sprite2_T:     .db  0   ; note that I numbered 1 2 ...<br />Sprite2_S:     .db  0   ; some people may actually prefer starting<br />Sprite2_X:     .db  0   ; the count at 0, but it doesn't really matter.<br />;; THESE SPRITES WILL REPRESENT THE SCORE OF EACH PLAYER<br />;; BETWEEN 0 AND 9<br />Sprite3_Y:     .db  0   ; sprite #1's Y value<br />Sprite3_T:     .db  0   ; sprite #1's Tile Number<br />Sprite3_S:     .db  0   ; sprite #1's special byte<br />Sprite3_X:     .db  0   ; sprite #1's X value<br />Sprite4_Y:     .db  0   ; same thing, same order for sprite #2<br />Sprite4_T:     .db  0   ; note that I numbered 1 2 ...<br />Sprite4_S:     .db  0   ; some people may actually prefer starting<br />Sprite4_X:     .db  0   ; the count at 0, but it doesn't really matter.<br /><br />    .org $0500<br />;; This part allows variables declarations (or definition)<br />speed1_Up:   .db 0<br />speed1_Left:   .db 0<br />speed1_Down:   .db 0<br />speed1_Right:   .db 0<br />speed2_Up:   .db 0<br />speed2_Down:   .db 0<br />speed2_Left:   .db 0<br />speed2_Right:   .db 0<br /><br />speed1_Up_To_Be:   .db 0<br />speed1_Down_To_Be:   .db 0<br />speed1_Left_To_Be:   .db 0<br />speed1_Right_To_Be:   .db 0<br />speed2_Up_To_Be:   .db 0<br />speed2_Down_To_Be:   .db 0<br />speed2_Left_To_Be:   .db 0<br />speed2_Right_To_Be:   .db 0<br />loop_count: .db 0<br /><br /><br />    .org $8000  ; code starts at $8000 or $C000<br />Start:<br />    lda #1;<br />    sta speed1_Up_To_Be;<br />    sta speed2_Up;<br />    sta Sprite2_T<br />    sta Sprite1_S;<br />    lda #0;<br />    sta Sprite2_S;<br />    sta Sprite1_T;<br />    sta speed1_Down;    <br />    sta speed1_Right;    <br />    sta speed1_Left;<br />    sta speed2_Down;    <br />    sta speed2_Right;    <br />    sta speed2_Left;<br />    ;lda #0<br />    <br />    lda #80;<br />    sta Sprite1_X;<br />    sta Sprite2_X<br />    <br />    lda #80<br />    sta Sprite1_Y<br />    lda #120<br />    sta Sprite2_Y<br /><br />    lda #%00001000  ;<br />    sta $2000       ;<br />    lda #%00011110  ; Our typical PPU Setup code.<br />    sta $2001       ;<br /><br />    ldx #$00    ; clear X            ;; start of palette loading code<br />    lda #$3F    ; have $2006 tell<br />    sta $2006   ; $2007 to start<br />    lda #$00    ; at $3F00 (palette).<br />    sta $2006<br />    <br />loadpal:                ; this is a freaky loop<br />    lda palette, x  ; that gives 32 numbers<br />    sta $2007       ; to $2007, ending when<br />    inx             ; X is 32, meaning we<br />    cpx #32         ; are done.<br />    bne loadpal     ; if X isn't =32, goto &quot;loadpal:&quot; line.<br />;; end of palette loading code<br /> ;;--- CODE START ---;;<br /><br />    <br />    jsr dispBackground  ; calls the routine to display the background<br /><br /><br />;; THE MAIN LOOP<br /><br />infinite:  ; a label to start our infinite loop<br />    waitblank:<br />        bit $2002  ; these 3 lines wait for VBlank, this loop will actually miss VBlank<br />        bpl waitblank ; alot, in a later Day, I'll give a better way.<br /><br />    jsr disp_Sprites_DMA<br />    jsr move_charac1    <br />    jsr move_charac2    <br />    jsr strobe_keypad1<br />    jsr strobe_keypad2<br />    jsr update_keypad1   <br />    <br />    ldx loop_count<br />    inx<br />    stx loop_count<br />    txa<br />    cmp #8<br />    beq modulo<br />    jmp infinite<br /><br />modulo:<br />    jsr update_speed1<br />    ldx #0<br />    stx loop_count<br />    lda #0;<br />    jmp infinite<br /><br /> update_keypad1:<br />    lda $4016  ; load Abutton Status ; note that whatever we ain't interested   <br />    lda $4016  ; load Bbutton Status ; in we just load so it'll go to the next one.<br />    lda $4016  ; load Select button status<br />    lda $4016  ; load Start button status<br />    lda $4016  ; load UP button status<br />    and #1      ; AND status with #1<br />    bne UPKEYdown  ; for some reason (not gonna reveal yet), need to use NotEquals<br />    ;with ANDs. So it'll jump (branch) if key was down.<br />    lda $4016  ; load DOWN button status<br />    and #1     ; AND status with #1<br />    bne DOWNKEYdown<br />    lda $4016  ; load LEFT button status<br />    and #1     ; AND status with #1<br />    bne LEFTKEYdown<br />    lda $4016  ; load RIGHT button status<br />    and #1     ; AND status with #1<br />    bne RIGHTKEYdown<br />    ;ldy $0<br />    jmp NOTHINGdown2  ; if nothing was down, we just jump (no check for conditions)<br />    ; down past the rest of everything.<br />    UPKEYdown:<br />        lda speed1_Down;_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda speed1_Down_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda #1<br />        sta speed1_Up_To_Be<br />        lda #0<br />        sta speed1_Left_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Right_To_Be<br />        sta Sprite1_T<br />        jmp NOTHINGdown2  ; jump over the rest of the handling code<br />    DOWNKEYdown:<br />        lda speed1_Up;_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda speed1_Up_To_Be<br />        and #1<br />        bne NOTHINGdown2<br />        lda #1<br />        sta speed1_Down_To_Be<br />        lda #2<br />        sta Sprite1_T<br />        lda #0<br />        sta speed1_Left_To_Be<br />        sta speed1_Right_To_Be<br />        sta speed1_Up_To_Be<br />        jmp NOTHINGdown ; jump over the rest of handling code.<br />    NOTHINGdown2:<br />        jmp NOTHINGdown<br />    LEFTKEYdown:<br />        lda speed1_Right;_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda speed1_Right_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda #1<br />        sta speed1_Left_To_Be<br />        lda #0<br />        sta speed1_Up_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Right_To_Be<br />        lda #3<br />        sta Sprite1_T<br />        jmp NOTHINGdown<br />    RIGHTKEYdown:<br />        lda speed1_Left;_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda speed1_Left_To_Be<br />        and #1<br />        bne NOTHINGdown<br />        lda #1<br />        sta speed1_Right_To_Be<br />        sta Sprite1_T<br />        lda #0<br />        sta speed1_Up_To_Be<br />        sta speed1_Down_To_Be<br />        sta speed1_Left_To_Be<br />    NOTHINGdown:<br />        rts<br /><br />;; Kind of &quot;function&quot; in assembly style, used to relieve the main loop<br />move_charac1:<br />    lda Sprite1_Y ; load A with Y position<br />    sbc speed1_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite1_Y; store back to memory<br />    lda Sprite1_Y<br />    adc speed1_Down  ; add 1 to A. ADC (Add with Carry)((to A register))<br />    sta Sprite1_Y<br />    lda Sprite1_X<br />    sbc speed1_Left<br />    sta Sprite1_X<br />    lda Sprite1_X<br />    adc speed1_Right<br />    sta Sprite1_X<br />    rts<br />    <br />move_charac2:<br />    lda Sprite2_Y ; load A with Y position<br />    sbc speed2_Up  ; subtract 1 from A. Only can do math on A register. SBC (Subtract with Borrow)<br />    sta Sprite2_Y; store back to memory<br />    lda Sprite2_Y<br />    adc speed2_Down  ; add 1 to A. ADC (Add with Carry)((to A register))<br />    sta Sprite2_Y<br />    lda Sprite2_X<br />    sbc speed2_Left<br />    sta Sprite2_X<br />    lda Sprite2_X<br />    adc speed2_Right<br />    sta Sprite2_X<br />    rts<br /><br />update_speed1:<br />    ldx speed1_Up_To_Be<br />    stx speed1_Up<br />    ldx speed1_Down_To_Be<br />    stx speed1_Down<br />    ldx speed1_Left_To_Be<br />    stx speed1_Left<br />    ldx speed1_Right_To_Be<br />    stx speed1_Right<br />    ldx #0;<br />    ldy #0;<br />    rts<br /><br />disp_Sprites_DMA:<br />    lda #3<br />    sta $4014<br />    lda #0;<br />    rts<br />;; ----------------------------------------------------<br /><br />strobe_keypad1:<br />    lda #$01   ; these<br />    sta $4016  ; lines<br />    lda #$00   ; setup/strobe the<br />    sta $4016  ; keypad.<br />    lda #0;<br />    rts<br /><br />strobe_keypad2:<br />    lda #$01   ; these<br />    sta $4017  ; lines<br />    lda #$00   ; setup/strobe the<br />    sta $4017  ; keypad.$<br />    lda #0;<br />    rts<br /><br /><br />palette: <br />    ; this upper line is used for the background palette<br />    .db $0F,$2D,$20,$20,$0F,$3D,$3D,$3D,$0F,$3D,$3D,$3D,$0F,$3D,$3D,$3D<br />    ; this lower line is used for the sprites palette<br />    .db $0F,$08,$07,$06,$0F,$01,$03,$02,$0F,$3A,$3A,$3A,$0F,$3A,$3A,$3A<br /><br /><br />;; -------------------------------------------------------------------------<br />;; THE FOLLOWING LOOPS ENABLE TO DISPLAY THE BACKGROUND <br />;; -------------------------------------------------------------------------<br />dispBackground: <br />    lda #$20<br />    sta $2006 ; give $2006 both parts of address $2020.<br />    lda #$00<br />    sta $2006<br /><br />    ;; This displays the background using ourMap, defined ways below<br />        ldx #$00<br />    loadNames1:<br />        lda ourMap1, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames1; if not all 64 done, loop and do some more<br />        <br />        ldx #$00<br />    loadNames2:<br />        lda ourMap2, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames2; if not all 64 done, loop and do some more<br />        ldx #$00<br />        <br />    loadNames3:<br />        lda ourMap2, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames3; if not all 64 done, loop and do some more<br />        <br />        ldx #$00<br />    loadNames4:<br />        lda ourMap2, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames4; if not all 64 done, loop and do some more<br />        <br />        ldx #$00<br />    loadNames5:<br />        lda ourMap2, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames5; if not all 64 done, loop and do some more<br /><br />        ldx #$00<br />    loadNames6:<br />        lda ourMap2, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames6; if not all 64 done, loop and do some more<br /><br />        ldx #$00<br />    loadNames7:<br />        lda ourMap3, X ; load A with a byte from address (ourMap + X)<br />        inx<br />        sta $2007<br />        cpx #128 ; map in previous section 64 bytes long<br />        bne loadNames7; if not all 64 done, loop and do some more<br />        <br />    lda #%00011110 ; enable sprites, enable background<br />    sta $2001<br />        <br />    rts<br />;; -------------------------------------------------------------------------<br /><br /><br />ourMap1: <br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />    .db 30,26,15,39,19,32,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,26,15,39,19,32,0,7,0<br />    .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br />ourMap2: <br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />ourMap3: <br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2<br />    .db 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4<br /><br /><br />    .bank 2<br />    .org $0000<br />    .incbin &quot;bkg.nes&quot;<br />    .incbin &quot;sprites.nes&quot;<br />;;--- END OF CODE FILE ---;<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6164">turboninja</a> — Wed Sep 11, 2013 3:42 pm</p><hr />
]]></content>
</entry>
</feed>