<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Procedural level generation on the NES?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Procedural level generation on the NES?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=16716">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=16716</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 5:25 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I can't think of a single game from the commercial NES era that did this. It might be that its occurrence (in roguelikes) was pretty underground up until Diablo, which is post-nes. But i don't know of a single homebrew that does this either. Is there something that's technically difficult with having a, say, schmup, generate a level procedurally on the NES? Or is it just simply because it's generally hard to device procedural level generation that can maintain the players' interest for more than a couple of minutes (in other words, more of a design question rather than a technical one)?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Sumez</b> [ Fri Nov 17, 2017 5:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'm sure you can find quite a few NES games that did it, but it's really hard to think of any. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /> It's probably a lot more common in games with more abstract concepts of &quot;stages&quot;.<br /><br />I'm pretty sure Elite has procedurally generated areas due to the massive scope of the game?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Fri Nov 17, 2017 6:13 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Procedural level generation tends to need more RAM than hardcoded levels, and RAM is one thing that the NES doesn't have much of. The exception is one-way scrolling like that of <em>Super Mario Bros.</em>, where the procedural level generator could conceivably replace the level decompression code. But even in that case, balancing procedural levels to ensure even difficulty progression was not trivial.<br /><br />One pre-NES example: <em>River Raid</em> for Atari 2600 is procedural with a fixed seed as a compression technique.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Pokun</b> [ Fri Nov 17, 2017 6:27 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Closest thing I could think of is those endless Megaman hacks. They are based on the endless mode of Megaman 9 and 10 where you play short stages in random order endlessly. Each stage is designed by hand but they are thrown at you randomly and endlessly.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 6:37 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">RAM</div>Right! That would make a design that allowed for backtracking (ie diablo) extra hard to fit without cutting a lot of corners. A ratchet scroller like gradius or smb1 might be easier, and definitely something like Pokun described.<br /><br />There's also the method used in the &quot;hidden rooms&quot; of Axiom verge where a subset of predefined structures (like in Metroid) are thrown at the screen based on a random seed. Or at least that's what it seems to be.  Keeping such segments short enough might work. <br /><br />Turning this into more of a hardware query:<br />For a hypothetical homebrew that needs to retain work RAM data (like a procedurally generated retrackable world/dungeon), even between sessions, FeRAM / FRAM seems like an option, though probably with the need of a proper 5v-3.3v converter. <br /><br />Fujitsu FeRAM chips aren't that expensive at proper sizes. <br /><br /><!-- m --><a class="postlink" href="https://www.semiconductorstore.com/pages/asp/search.asp?categoryNarrowName=FRAM&amp;categoryNarrow=322&amp;plDesc=Fujitsu&amp;pl=0155&amp;SupplierOnly=True&amp;sortByMenu=best_-_desc&amp;cm_mmc=Email_Promo-_-Fujitsu-_-FRAM-_-General_Interest">https://www.semiconductorstore.com/page ... l_Interest</a><!-- m --><br /><br />Would there be problems using such a chip?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Fri Nov 17, 2017 6:42 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />SPI and/or I2C memory is kind of annoying from the NES's point of view; either you need some external hardware to automatically handle the serial-to-and-fro-parallel conversion, or it's quite slow.<br /><br />Flash might be preferable?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 6:45 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />So one would need to add in the cost of two shift registers, basically?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Flash might be preferable?<br /></div><br />You might expect the flashROM to be worn down a lot quicker if it's constantly poked and prodded by procedural generation.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Fri Nov 17, 2017 6:52 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah, it's approximately a SIPO and a PISO shift register, but ideally you'd just stuff it in a CPLD or something to handle all the rest of the support. <br /><br /><br />For flash, reads are free, you can only write 0s, blocks can be converted from 0 to 1 only (large number of bits) at a time, and each block is limited to ~10k total erase cycles before the data won't be retained for the specified amount of time. (But it will still retain data after that: just for less than the specified amount of time)<br /><br />For FeRAM all reads are also writes, and each cell has a finite (but huge, usually) number of total writes.<br /><br /><br />I would naively assume that a procedurally generated world wouldn't overwrite the same memory over and over? Because then you couldn't backtrack...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 6:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I guess it depends a lot on the design of a game. If the world is highly manipulable (think sim city, minecraft, scorched earth, worms, etc, simulations in general and roguelike/simulation crossovers), you'd overwrite a persistent world. <br /><br />For something that's an endless gauntlet, like a racer or schmup, you'd be constantly overwriting it, but wouldn't need persistence (or as much RAM), so non-volatile work ram isn't called for, really..<br /><br />There are parallel interfaced FeRAM:s, though they seem to be in the 3-4 dollar range each rather than 1-2. I haven't done a thorough comparison, but here's an example:<br /><!-- m --><a class="postlink" href="https://www.semiconductorstore.com/cart/pc/viewPrd.asp?idproduct=48940">https://www.semiconductorstore.com/cart ... duct=48940</a><!-- m --><br /><br />edit: In contrast to FlashROM, it is also faster; much like conventional RAM.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> (But it will still retain data after that: just for less than the specified amount of time)</div><br />Oh... this is a new piece of info for me. So it's not that it goes sour directly, but rather becomes volatile after some time of non-use once it has passed its durability?<br /><br /><br />===<br />A (debatably) good thing is that FeRAM can essentially replace both ROM and RAM on a single board, just as long as you're careful not to overwrite essential code and data.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Fri Nov 17, 2017 7:51 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">FrankenGraphics wrote:</div><div class="quotecontent">I guess it depends a lot on the design of a game. If the world is highly manipulable (think sim city, minecraft, scorched earth, worms, etc, simulations in general and roguelike/simulation crossovers), you'd overwrite a persistent world. <br /></div>Oh, fair enough. Yeah, that's definitely a RAM / FeRAM kind of situation.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Oh... this is a new piece of info for me. So it's not that it goes sour directly, but rather becomes volatile after some time of non-use once it has passed its durability?<br /></div>Yeah. Each time the block is erased (by intentionally causing the floating gates to leak), the floating gates become a little more leaky. The guaranteed durability just means that the floating gates are guaranteed to not become <strong>more</strong> leaky than however many femtocoloumbs per year after however many erasures.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">A (debatably) good thing is that FeRAM can essentially replace both ROM and RAM on a single board, just as long as you're careful not to overwrite essential code and data.<br /></div>That's roughly the same reason that Memblers used with GTROM... don't need to provide PRG RAM for saves if using flash.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 8:37 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Ok, so here's an attempt compiling what<strong> FeRAM might be good for on a technical level:</strong><br /><br />-Speed: Close to conventional RAM speeds; overwrites in a single cycle*. Suitable for frequent and quick access. <br />-Durability/data retention: While there's an upper limit (typically 10^12 times per byte ), it goes many times beyond FlashROM and EEPROM. <br />-Interface: Comes as parallel, though serial seems to be cheaper in general. The parallel ones typically have a SRAM like interface built in. <br />-Price range: 1-5 dollars for reasonable sizes in the 64kB-512kB range<br />-Suitable as RAM? For most applications; it seems so yes. <br />-Suitable as ROM? <s>yes</s> No, if accessed frequently, as reads will cause wear just like rewrites.** <br />-Volatile? no. <br />-Battery requirement? no<br />-Unpowered data retention: typically estimated to last over 200 years below +35C, 95 years at +55C, or 10 years at a temperature of +85C.<br />-Power consumption: low; needs no &quot;charge pump&quot;, and no constant current.<br />-technology: CMOS (<span style="text-decoration: underline">warning</span>: typically max 3.6v) <br />-availability: a few major companies like fujitsu and texas instruments manufacture FeRAM/FRAM; aswell as some relatively smaller companies.<br /> <br />Anything missing?<br /><br /><strong>On a game/application design level:</strong><br />-Good for any sort of world/data that is more or less manipulable, for example a level made of blocks the player can move, destroy and/or create<br />-Simulation-like parameters like &quot;population happiness in this city block&quot;, &quot;temperature&quot;, &quot;minerals left&quot; etc. <br />-Persistent enemy, npc, treasure statuses etc. <br />-Modifiable locations of ID:d items/objects<br />-Fog of war/field of exploration/field of view and other manipulable masks/maps<br />-any sort of complex save file<br />-generated, retrackable worlds/levels<br /><br />*FeRAM doesn't need an erase cycle; nor separate read/write cycles. It operates by a rewrite cycle solely. This allows for very fast rates, especially with a Parallel interface. An SPI type FeRAM is a double bottle-neck, so avoid it. <br /><br />**See tepples' subsequent post for details

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Fri Nov 17, 2017 8:55 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">FrankenGraphics wrote:</div><div class="quotecontent"><div class="quotetitle">lidnariq wrote:</div><div class="quotecontent">For FeRAM all reads are also writes, and each cell has a finite (but huge, usually) number of total writes.</div><br />Ok, so here's an attempt compiling what<strong> FeRAM might be good for on a technical level:</strong><br /><br />[...]<br />-Durability/data retention: While there's an upper limit (typically 10^12 times per byte ), it goes many times beyond FlashROM and EEPROM. <br />[...]<br />-Suitable as ROM? yes</div><br />Because reads count as writes, I don't see how something with a limit of a trillion reads is &quot;Suitable as ROM&quot;.<br /><br />Assume for a moment that a game spends an average of 973,000 cycles per second in a wait for vblank or wait for sprite 0 loop, and the loop is 7 cycles long. This means each byte of this loop is accessed 139,000 times every second. With a limit of a trillion access per byte, that's 7.2 million seconds or 2000 hours of power on time until the FeRAM cells holding this loop are no longer warranted. It's even worse for an all-in-NMI design like that of <em>Super Mario Bros.</em>, whose loop is only 3 bytes long.<br /><br />Emulators would have to warn for too many reads from the same ROM location in one second, and games would have to copy tight loops into the 2K RAM or unroll them.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>FrankenGraphics</b> [ Fri Nov 17, 2017 8:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Thanks, i'll revise the post. The waiting spinlock could be copied to and ran from internal/separate RAM, though? EDIT: I somehow missed you wrote that more or less in your last sentence.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Alp</b> [ Fri Nov 17, 2017 9:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">Procedural level generation tends to need more RAM than hardcoded levels, and RAM is one thing that the NES doesn't have much of. The exception is one-way scrolling like that of <em>Super Mario Bros.</em>, where the procedural level generator could conceivably replace the level decompression code. But even in that case, balancing procedural levels to ensure even difficulty progression was not trivial.<br /><br />One pre-NES example: <em>River Raid</em> for Atari 2600 is procedural with a fixed seed as a compression technique.</div><br />Not necessarily, clever data formatting is always king.<br /><br />Last year, I had prototyped a randomly generated Zelda 1 clone on the NES, and the dungeons only used 64 bytes of RAM, generated from a seed. The Overworlds were a slightly different case, using about double that, to accommodate the extra level of detail.<br /><br />The project was shelved, simply because I ran out of design ideas for monsters! <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br /><br />Coincidentally, my Super Mario Bros. clone &quot;Cotton &amp; Candy&quot; actually features procedural level generation as an easter egg. If you walk through the top of a fake wall in level 1-2, you'll unlock a secret stage on the Overworld named &quot;Minus World&quot; <img src="./images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /><br /><br />My levels have full left/right scrolling though, none of that one-way scrolling crap.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>thefox</b> [ Fri Nov 17, 2017 12:04 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Procedural level generation on the NES?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />This isn't exactly the kind of procedural generation that you're looking for (because it doesn't affect gameplay), but some time I happened to notice that Noah's Ark (E) uses randomization to generate some of its levels' visual content:<br /><div class="attachtitle">Attachment:</div><div class="attachcontent">
			<img src="./download/file.php?id=10814" alt="noahs-ark-ground.gif" /><br />
			<span class="gensmall">noahs-ark-ground.gif [ 11.34 KiB | Viewed 1552 times ]</span>
		

		<br />
	</div>In the GIF is the nametable at the start of the level on two separate occasions. (I seem to recall this also affecting grass, but I couldn't reproduce that easily right now.)<br /><br />SMB3 does something similar when generating the background layer, although that also doesn't affect gameplay in any way.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>