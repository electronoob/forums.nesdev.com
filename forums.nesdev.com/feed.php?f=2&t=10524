<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=10524" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2013-10-01T13:43:17-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=10524</id>
<entry>
<author><name><![CDATA[DRW]]></name></author>
<updated>2013-10-01T13:43:17-07:00</updated>
<published>2013-10-01T13:43:17-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118843#p118843</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118843#p118843"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118843#p118843"><![CDATA[
Alright, the NMI re-entry I understand now. I've written a notice in my todo list to include a check.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6156">DRW</a> — Tue Oct 01, 2013 1:43 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-09-26T17:17:11-07:00</updated>
<published>2013-09-26T17:17:11-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118706#p118706</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118706#p118706"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118706#p118706"><![CDATA[
<div class="quotetitle">lidnariq wrote:</div><div class="quotecontent"><br />NMIs, being not maskable, can't be masked by their own execution.<br /></div><br />Cool, good to get confirmation on that.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><a href="http://wiki.nesdev.com/w/index.php/PPU_registers#Bit_0_bus_conflict" class="postlink">Blocking NMIs by writing to $2000 has its own problems</a>, however.<br /></div><br />Yeah, and it's less versatile too, since you don't have the option to run high priority tasks (such as playing music or drawing a status bar) even during lag frames.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Thu Sep 26, 2013 5:17 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-09-26T17:03:03-07:00</updated>
<published>2013-09-26T17:03:03-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118705#p118705</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118705#p118705"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118705#p118705"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />I must confess I don't remember whether an NMI will interrupt another NMI... It's a possibility, but I'm not sure it will happen. Hopefully someone will know for sure.<br /></div>NMIs, being not maskable, can't be masked by their own execution. Thus the only way to prevent reentry is to either disable the source (by writing to $2000) or to use a flag as this thread is recommending.<br /><br /><a href="http://wiki.nesdev.com/w/index.php/PPU_registers#Bit_0_bus_conflict" class="postlink">Blocking NMIs by writing to $2000 has its own problems</a>, however.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Thu Sep 26, 2013 5:03 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-09-26T16:01:37-07:00</updated>
<published>2013-09-26T16:01:37-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118698#p118698</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118698#p118698"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118698#p118698"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />What I don't understand here: Let's say my game logic is implemented inside NMI and it takes too long. So, the next NMI interrupt is called. Does that mean that there are now basically two instances of NMI running in parallel?<br /></div><br />I must confess I don't remember whether an NMI will interrupt another NMI... It's a possibility, but I'm not sure it will happen. Hopefully someone will know for sure.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />One where I'm right inside my game logic and one that just started? How is this possible?<br /></div><br />If it does happen, it's like all other interrupts: the status flags and the program counter are pushed into the stack, and the NMI code is called. The problem is that all sorts of things can go wrong in this case, since the status of your game is inconsistent because it the previous frame calculations didn't finish, and as more and more NMIs interrupt the previous ones, the stack will eventually overflow.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Now, let's say we're in GameLogicStep5 and it's time for the next NMI. Originally, I thought that the program flow simply jumps from GameLogicStep5 to the function entry, leaving GameLogic6-10 unexecuted for this time.<br />But if you say that the NMI should set a flag, does this mean that two &quot;instances&quot; of NMI are able to execute simulatenously?<br /></div><br />The CPU can only run one program at a time, so they don't run simultaneously. The first NMI is interrupted (it can be resumed once the one that interrupted it returns with RTI) and a new one begins.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />In this case, the NMI is at GameLogic5. Suddenly, the next NMI happens. While the first NMI is now at GameLogic6, the second NMI is at the if check. While the first NMI is at GameLogic7, the second NMI is at the &quot;don't jump into the conditional code&quot; area. While the first NMI is then at GameLogic8, the second NMI is at the &quot;leave function&quot; location.<br /></div><br />No. The first NMI will stop at GameLogic5, and only after the second NMI &quot;leaves the function&quot; GameLogic5 and the rest of the first NMI will continue.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />If it is not as I described and the NMI simply rips the &quot;program pointer&quot; from its current location and places it at the start of NMI, then how does a flag guarantee that the current NMI just quits itself and the program continues from the right location where it has been before the new NMI jumped in?<br /></div><br />A return address is ALWAYS pushed into the stack. So when an interrupt interrupts another interrupt, you can safely return to the code that was interrupted as long as you don't trash registers or the interrupts pile up to the point of overflowing the stack. But the best thing is to avoid the situation altogether with a flag, which also gives you control of what to do and what not to do (like always running the music code so the music doesn't slow down).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The tutorial uses LDA $2002 before copying background, palette and attribute data to the PPU. Is this necessary even though waitvblank is not included here? And would BIT $2002 serve the same purpose in this case again?<br /></div><br />It's not the same purpose. When used before the wait for VBlank loop the purpose is to clear the VBlank flag, so that the wait loop doesn't pick up the middle of a VBlank. When $2002 is read before access to $2006, the purpose is to clear the latch that selects between high and low bytes of $2005/$2006. This is generally unnecessary with well programmed code, because $2005/$2006 are always written in pairs, but some people like to put that $2002 read just to be safe.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Thu Sep 26, 2013 4:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Joe]]></name></author>
<updated>2013-09-26T15:50:59-07:00</updated>
<published>2013-09-26T15:50:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118697#p118697</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118697#p118697"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118697#p118697"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />What I don't understand here: Let's say my game logic is implemented inside NMI and it takes too long. So, the next NMI interrupt is called. Does that mean that there are now basically two instances of NMI running in parallel? One where I'm right inside my game logic and one that just started? How is this possible?<br /></div>There is no parallel processing. When NMI occurs, it &quot;pauses&quot; whatever is currently executing. At the end of your NMI handler, you use the RTI instruction to &quot;unpause&quot;. This means if another NMI happens while the first one is executing, the new NMI pauses the old NMI.<br /><br />In C-like syntax:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void Nmi()<br />{<br />    if (NextNmiCanBeProcessed)<br />    {<br />        NextNmiCanBeProcessed = false;<br /><br />        WriteToPpu();<br />        ReadController();<br />        GameLogic();<br /><br />        NextNmiCanBeProcessed = true;<br />    }<br />}</div><br />When NMI is triggered and there is not another NMI handler currently running, it will write to the PPU, read the controllers, and begin executing the game logic. If another NMI occurs before the first one finishes, the first NMI handler will be paused. But, <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">NextNmiCanBeProcessed</tt> will be false, causing the second NMI handler to exit without doing anything. Once the second NMI handler ends, the first NMI handler will continue from exactly where it was paused. (And once the first NMI handler ends, whatever it interrupted will resume.)<br /><br />It's important to remember that this &quot;pause&quot; analogy is not perfect. The three registers (A, X, and Y) are not saved, so if either NMI routine modifies them without restoring their original values, the &quot;paused&quot; code will not resume properly. The flags are saved, so if you use the BIT instruction to decide if the NMI should run or not, you don't need to worry about accidentally messing up the &quot;paused&quot; code.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5948">Joe</a> — Thu Sep 26, 2013 3:50 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DRW]]></name></author>
<updated>2013-09-26T14:28:52-07:00</updated>
<published>2013-09-26T14:28:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118690#p118690</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118690#p118690"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118690#p118690"><![CDATA[
<div class="quotetitle">3gengames wrote:</div><div class="quotecontent"><br />http://wiki.nesdev.com/w/index.php/PPU_registers<br /></div><br />Thanks. Pretty interesting stuff.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />It's common practice to have a &quot;FrameReady&quot; flag, which you set whenever the frame calculations are ready. You should check this flag at the beginning of your NMI handler (taking care to not trash any registers that might be in use by a possible unfinished frame) to make sure that the previous frame is done before processing a new frame. If the frame isn't done, you just return from the NMI (some like to at least call the music playback routine here, so that music doesn't slow down), which effectively slows down the gameplay.<br /></div><br />What I don't understand here: Let's say my game logic is implemented inside NMI and it takes too long. So, the next NMI interrupt is called. Does that mean that there are now basically two instances of NMI running in parallel? One where I'm right inside my game logic and one that just started? How is this possible?<br /><br />Let's show it with pseudo code (I use a C-like syntax for better understanding):<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void Nmi()<br />{<br />    WriteToPpu();<br />    ReadController();<br />    GameLogicStep1();<br />    GameLogicStep2();<br />    GameLogicStep3();<br />    GameLogicStep4();<br />    GameLogicStep5();<br />    GameLogicStep6();<br />    GameLogicStep7();<br />    GameLogicStep8();<br />    GameLogicStep9();<br />    GameLogicStep10();<br />}</div><br /><br />Now, let's say we're in GameLogicStep5 and it's time for the next NMI. Originally, I thought that the program flow simply jumps from GameLogicStep5 to the function entry, leaving GameLogic6-10 unexecuted for this time.<br />But if you say that the NMI should set a flag, does this mean that two &quot;instances&quot; of NMI are able to execute simulatenously?<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void Nmi()<br />{<br />    if (NextNmiCanBeProcessed)<br />    {<br />        NextNmiCanBeProcessed = false;<br /><br />        WriteToPpu();<br />        ReadController();<br />        GameLogicStep1();<br />        GameLogicStep2();<br />        GameLogicStep3();<br />        GameLogicStep4();<br />        GameLogicStep5();<br />        GameLogicStep6();<br />        GameLogicStep7();<br />        GameLogicStep8();<br />        GameLogicStep9();<br />        GameLogicStep10();<br /><br />        NextNmiCanBeProcessed = true;<br />    }<br />}</div><br />In this case, the NMI is at GameLogic5. Suddenly, the next NMI happens. While the first NMI is now at GameLogic6, the second NMI is at the if check. While the first NMI is at GameLogic7, the second NMI is at the &quot;don't jump into the conditional code&quot; area. While the first NMI is then at GameLogic8, the second NMI is at the &quot;leave function&quot; location.<br /><br />Is this how the NMI interrupts are implemented? Because this looks almost like some kind of multithreading or multitasking.<br /><br />If it is not as I described and the NMI simply rips the &quot;program pointer&quot; from its current location and places it at the start of NMI, then how does a flag guarantee that the current NMI just quits itself and the program continues from the right location where it has been before the new NMI jumped in?<br /><br /><br />Another question about reading the $2002 variable: The tutorial uses LDA $2002 before copying background, palette and attribute data to the PPU. Is this necessary even though waitvblank is not included here? And would BIT $2002 serve the same purpose in this case again?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6156">DRW</a> — Thu Sep 26, 2013 2:28 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2013-09-24T11:20:09-07:00</updated>
<published>2013-09-24T11:20:09-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118618#p118618</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118618#p118618"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118618#p118618"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />What happens when, for some reason, my program takes more time for each frame than usual? Does that mean that the program is simply slowed down (so that for example it only runs at 30 FPS instead of 60 FPS) or does the program immediately jump to the NMI label again, disrupting my program flow because I was just in the middle of the previous NMI call?<br /></div>Your code has approximately 2200 cycles to tell the PPU all the changes to make from the previous time to drew anything. If you haven't finished my then, the display will be incorrect.<br />For example, if you haven't written the correct value to 2005/2006 to specify where the viewport is before this, it will start rendering at the wrong place. If you subsequently read or write from 2007, the display will warp. If you haven't finished uploading sprites, they may all disappear. Even writes to 2000 and 2001 require care, either in timing or the value written.<br />Your code then has another 27000 cycles to do whatever it wants—physics, controller input, play music, preparing for the next screen, &amp;c.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Tue Sep 24, 2013 11:20 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-09-24T08:23:43-07:00</updated>
<published>2013-09-24T08:23:43-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118614#p118614</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118614#p118614"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118614#p118614"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />What do you mean? In how far does JMP working like the reset button and JMP not working like the reset button differ? Isn't JMP just the Assembly equivalent of goto?<br /></div><br />Jumping to the &quot;Reset&quot; label will only work like a hardware reset if you fully initialize everything. For example, if you don't disable interrupts in the reset code counting on the fact that IRQs are disabled on power on, and then simulate a reset by JMP'ing to the &quot;Reset&quot; label after a point in the program where you have used IRQs, IRQs will be enabled after the &quot;reset&quot;.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Every values that were pushed to the stack until now are ignored.<br /></div><br />That's not so. They are written to whatever location the stack pointer is pointing to, you just don't know what that location is for sure unless you initialize the SP.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />That's how I understood it. Instead of popping every remaining stuff from the stack, just set the stack pointer to the starting address.<br /></div><br />Yes, you can &quot;empty&quot; (the values will remain in RAM though, nothing will be actually erased until the old values are overwritten) the stack just by resetting the SP.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />So, would it be wise to disable NMI before every game level, so that we can load all the level data into memory? And then we enable it again to start the level?<br /></div><br />Yes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Same as above: Should we do this before any level?<br /></div><br />Yes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />What happens when, for some reason, my program takes more time for each frame than usual?<br /></div><br />That depends on whether you are prepared for that situation, because the NES doesn't handle this automatically. If PPU updates take too long, the screen glitches (you can't write to the PPU and display a picture at the same time).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Does that mean that the program is simply slowed down (so that for example it only runs at 30 FPS instead of 60 FPS) or does the program immediately jump to the NMI label again, disrupting my program flow because I was just in the middle of the previous NMI call?<br /></div><br />It's not automatically slowed down. It's common practice to have a &quot;FrameReady&quot; flag, which you set whenever the frame calculations are ready. You should check this flag at the beginning of your NMI handler (taking care to not trash any registers that might be in use by a possible unfinished frame) to make sure that the previous frame is done before processing a new frame. If the frame isn't done, you just return from the NMI (some like to at least call the music playback routine here, so that music doesn't slow down), which effectively slows down the gameplay.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />I'd still rather play it safe. So, where do I put another <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">BIT $2002</tt>? Right before the first waitvblank function?<br /></div><br />Yup.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />O.k., I'll do. What about the other stuff?<br /></div><br />$2000 should be updated every frame as well, because it contains part of the scroll information (the name table selection bits), but $2001 only needs to be changed if you actually need to modify the rendering parameters it affects.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Apart from the additional reading of $2002 and the relocation of the scrolling data after every frame, are any other changes necessary? (The game is supposed to be a mapper 0, non scrolling game, so anything that refers to specific mappers can be ignored.)<br /></div><br />As far as I can see, everything is fine.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Tue Sep 24, 2013 8:23 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[3gengames]]></name></author>
<updated>2013-09-24T08:07:43-07:00</updated>
<published>2013-09-24T08:07:43-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118611#p118611</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118611#p118611"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118611#p118611"><![CDATA[
For registers, use the Wiki. Heck, read over the wiki now so you understand the registers real meaning sooner. That's one gripe with the nerdy nights is the comments and some of the descriptions of how the registers work is off, or just flat out suck.<br /><br /><!-- m --><a class="postlink" href="http://wiki.nesdev.com/w/index.php/PPU_registers">http://wiki.nesdev.com/w/index.php/PPU_registers</a><!-- m --><br /><br />And when you see assembly code LDX #$FF and TXS when TXS assigned the stack a new value, yes it's pretty certain to change the stacks status, that's what it's supposed to do.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4311">3gengames</a> — Tue Sep 24, 2013 8:07 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DRW]]></name></author>
<updated>2013-09-24T03:08:02-07:00</updated>
<published>2013-09-24T03:08:02-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118595#p118595</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118595#p118595"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118595#p118595"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />IRQ is disabled whenever the CPU is reset. However, disabling them explicitly allows JMP ($FFFC) to work like the reset button.<br /></div><br />What do you mean? In how far does JMP working like the reset button and JMP not working like the reset button differ? Isn't JMP just the Assembly equivalent of goto?<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDX #$FF<br />  TXS                   ; Put stack pointer at $FF. Does this reset the stack status?</div><br /></div><br />What do you think you mean by &quot;stack status&quot;?</div><br />What I mean is this:<br /><em>Sets the stack pointer to #$FF, its original starting address. Every values that were pushed to the stack until now are ignored. The stack behaves as if it's totally empty, so that new variables can be added and the old ones aren't in the way anymore.</em><br />That's how I understood it. Instead of popping every remaining stuff from the stack, just set the stack pointer to the starting address.<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />Disabling NMI allows the CPU to complete the init code without being bothered by these notifications.<br /></div><br />So, would it be wise to disable NMI before every game level, so that we can load all the level data into memory? And then we enable it again to start the level?<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><div class="codetitle"><b>Code:</b></div><div class="codecontent">  STA $2001             ; Disable rendering???</div><br /></div><br />This blanks the screen so that the CPU can load in a new background.</div><br />Same as above: Should we do this before any level?<br /><br /><div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />The first thing the NMI handler should do is write all needed background and sprite changes to the PPU, as there are only 2200 cycles to do so before the next frame begins.<br /></div><br />What happens when, for some reason, my program takes more time for each frame than usual? Does that mean that the program is simply slowed down (so that for example it only runs at 30 FPS instead of 60 FPS) or does the program immediately jump to the NMI label again, disrupting my program flow because I was just in the middle of the previous NMI call?<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />I don't think you need another $2002 read. The code you have will work fine after power on. On the Famicom and on the top loading NES there could be a situation when those two loops don't wait enough time for the PPU to warm up, but since the PPU isn't reset in that case, it's already warmed up, so it's all good I think.<br /></div><br />I'd still rather play it safe. So, where do I put another <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">BIT $2002</tt>? Right before the first waitvblank function?<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  BIT $2002<br />WaitVBlank:<br />  BIT $2002<br />  BPL WaitVBlank</div><br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />Anyway, resetting the scroll is something that should be done every frame, after you're done with all PPU updates.<br /></div><br />O.k., I'll do. What about the other stuff?<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #%10010000<br />  STA $2000<br />  LDA #%00011110<br />  STA $2001</div><br />Does this need to be updated at every frame as well or is it enough to do it once in the beginning (and whenever I might want to change these values)?<br /><br />Apart from the additional reading of $2002 and the relocation of the scrolling data after every frame, are any other changes necessary? (The game is supposed to be a mapper 0, non scrolling game, so anything that refers to specific mappers can be ignored.)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6156">DRW</a> — Tue Sep 24, 2013 3:08 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-09-23T18:12:14-07:00</updated>
<published>2013-09-23T18:12:14-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118583#p118583</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118583#p118583"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118583#p118583"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />Isn' t it disabled by default?<br /></div><br />Even if it is, sometimes the hardware goes through small revisions and things change... some mappers for example have shown different power on status across different revisions (MMC1A vs. MMC1B, etc.). The PPU and the CPU have gone through a few revisions too, and although we're not sure whether something relevant changed, it doesn't hut to initialize everything to the specific state we want. Also, like tepples said, there's the reset button to consider.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />like the waitvblank stuff: Where and how should I read the value again to be sure everything is fine? And with LDA or again with BIT?<br /></div><br />BIT or LDA (or also LDX, LDY, CMP, and many other instructions) will work just fine for reading $2002, the only advantage of using BIT is that the contents of A remain untouched. Might not seem like a big deal in the initialization code, but if you ever have to read flags in the middle of the game logic, preserving A might be an advantage, so many people make a habit of using BIT for this.<br /><br />I don't think you need another $2002 read. The code you have will work fine after power on. On the Famicom and on the top loading NES there could be a situation when those two loops don't wait enough time for the PPU to warm up, but since the PPU isn't reset in that case, it's already warmed up, so it's all good I think.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #$00              ; Tell the ppu there is no background scrolling???<br />  STA $2005<br />  STA $2005</div><br /></div><br />That comment is a bit misleading... Writing to $2005 tells the PPU which part of the name tables you want to be visible. Writing $00 twice means that the top left corner of the name table will be at the top left corner of the screen. It doesn not mean that &quot;there's no scrolling&quot;, because on the next NMI you might decide to write another value to $2005 and then there will be background scrolling.<br /><br />What I mean is that $00 is just one of the possible values you can write to $2005, and it doesn't necessarily mean the absense of scrolling, becouse you could very well write $80, $00 to $2005 and as long as you never touched that register again there would be no scrolling either, you'd just permanently see another part of the name tables.<br /><br />Scrolling is not something the PPU does automatically, it's the programmer who creates the illusion of scrolling by changing what parts of the name tables are visible a little every frame. If you don't modify anything, there's no scrolling.<br /><br />Anyway, resetting the scroll is something that should be done every frame, after you're done with all PPU updates. That's because writing to the PPU messes up its internal address register, which is also used for rendering the picture. If you don't reset the scroll, you'll get a messed up picture in the following frame. The reason you're getting away with resetting the scroll just once is because you're not doing any PPU updates (the OAM DMA doesn't count, because sprites go to a different memory that doesn't need the PPU address register) in your NMI, but that's not typical. Most games will often rewrite tiles, change the palette, etc., and all of that requires the scroll to be reset afterwards.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #$00<br />  STA $2003             ; Set low byte ($00) of the RAM address.<br />  LDA #$02<br />  STA $4014             ; Set high byte ($02) of the RAM address and start sprite transfer.</div><br /></div><br />The comment here is wrong. $2003 doesn't &quot;set the low byte of the RAM address&quot;, it sets the destination address for the sprites in the OAM, which is 256 bytes long. Sprites can only be copied from addresses that are multiple of 256 ($0000, $0100, $0200, $0300, $0400, and so on, depending on the value written to $4014), it's not possible to change the low byte.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Mon Sep 23, 2013 6:12 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2013-09-23T16:47:34-07:00</updated>
<published>2013-09-23T16:47:34-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118575#p118575</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118575#p118575"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118575#p118575"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />is the whole &quot;disable this, disable that&quot; necessary? Isn' t it disabled by default?<br /></div><br />If the program enabled these things, and the player pressed the Reset button on the Control Deck, then these things will remain enabled. The Reset button doesn't do much except modify the stack pointer, disable interrupts, and cause the CPU to JMP ($FFFC). (On the front-loading NES, it also resets the PPU, but not on any top-loading console.)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">.segment &quot;CODE&quot;<br /><br />Reset:<br />  SEI                   ; Disable IRQ???</div><br /></div><br />IRQ is disabled whenever the CPU is reset. However, disabling them explicitly allows JMP ($FFFC) to work like the reset button.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #$40<br />  STA $4017             ; Disable APU frame IRQ???</div><br /></div><br />APU frame IRQ is a feature of the 2A03 that generates a 60 Hz time base even when no PPU is connected. It's rarely used on the NES; it may be used more often in arcade games that use the 2A03 as a sound processor.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDX #$FF<br />  TXS                   ; Put stack pointer at $FF. Does this reset the stack status?</div><br /></div><br />What do you think you mean by &quot;stack status&quot;?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #$00<br />  STA $2000             ; Disable NMI???</div><br /></div><br />NMI (non-maskable interrupt) is how the PPU tells the CPU that it has completed rendering one frame. Copying the new sprite display list to OAM takes 520 cycles. After NMI, the CPU has about 2200 cycles to send changes to the background and sprites to the PPU. Disabling NMI allows the CPU to complete the init code without being bothered by these notifications.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  STA $2001             ; Disable rendering???</div><br /></div><br />This blanks the screen so that the CPU can load in a new background.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  STA $4010             ; Disable DMC IRQ???</div><br /></div><br />The 2A03 contains hardware to play back compressed sampled sound. DMC IRQ (delta modulation channel interrupt request) is how it tells the CPU that a sound has finished playing.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">FinalInitialization:<br />  LDA #%10010000        ; Enable NMI??? Enable sprites from Pattern Table 0, background from Pattern Table 1.</div><br /></div><br />Now that most of the init code is finished, the CPU is ready to receive notifications that each frame has finished. When the CPU receives this notification, it calls the NMI handler. Some programs are designed to run all the code inside the NMI handler; others just set a flag stating that the notification has been received.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #$00              ; Tell the ppu there is no background scrolling???<br />  STA $2005<br />  STA $2005</div><br /></div><br />Writes to $2005 set the scroll position of the background. The first sets the horizontal position, and the second the vertical.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Should the controller be read before or after the sprite copy function?</div><br /></div><br />The first thing the NMI handler should do is write all needed background and sprite changes to the PPU, as there are only 2200 cycles to do so before the next frame begins. After that, the program should start preparing the next frame, and the first thing to do when preparing the next frame is read the controller. So because it belongs to the following frame the controller should be read after the sprite copy.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Sep 23, 2013 4:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DRW]]></name></author>
<updated>2013-09-23T15:44:20-07:00</updated>
<published>2013-09-23T15:44:20-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118573#p118573</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118573#p118573"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118573#p118573"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />Most of us don't mind reviewing small sections of code, but when someone posts their entire 1 mile long ASM file, that tends to drive people away.<br /></div><br />Yeah, I understand that of course. I will post the parts that are there for hardware-dependent initialization stuff. Please tell me if anything is missing, anything is unnecessary or whatever remarks you have. For example, is the whole &quot;disable this, disable that&quot; necessary? Isn' t it disabled by default?<br />All in all, I understood the general things that you all told me. So, if you could tell me what's wrong with the following code (like the waitvblank stuff: Where and how should I read the value again to be sure everything is fine? And with LDA or again with BIT?), that would be great. Passages with question marks are stuff where I don't really get what is done there from a logical perspective or what it is good for.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">.segment &quot;CODE&quot;<br /><br />Reset:<br />  SEI                   ; Disable IRQ???<br />  CLD                   ; Disable decimal mode.<br />  LDA #$40<br />  STA $4017             ; Disable APU frame IRQ???<br />  LDX #$FF<br />  TXS                   ; Put stack pointer at $FF. Does this reset the stack status?<br />  LDA #$00<br />  STA $2000             ; Disable NMI???<br />  STA $2001             ; Disable rendering???<br />  STA $4010             ; Disable DMC IRQ???<br /><br />WaitVBlank:<br />  BIT $2002<br />  BPL WaitVBlank<br /><br />  LDX #$00<br /><br />ClearRam:               ; Set the RAM at 0, except for the sprites that go outside the screen.<br />  LDA #$00<br />  STA $0000, X<br />  STA $0100, X<br />  STA $0300, X<br />  STA $0400, X<br />  STA $0500, X<br />  STA $0600, X<br />  STA $0700, X<br />  LDA #$F0<br />  STA $0200, X<br />  INX<br />  BNE ClearRam<br /><br />WaitVBlank2:            ; PPU is ready after this.<br />  BIT $2002<br />  BPL WaitVBlank2<br /><br />; SKIPPED CODE: Load palettes into PPU<br />; SKIPPED CODE: Load sprites to $0200<br />; SKIPPED CODE: Load background into PPU<br />; SKIPPED CODE: Load attributes into PPU<br /><br />FinalInitialization:<br />  LDA #%10010000        ; Enable NMI??? Enable sprites from Pattern Table 0, background from Pattern Table 1.<br />  STA $2000<br />  LDA #%00011110        ; Enable sprites, enable background, no clipping on left side<br />  STA $2001<br />  LDA #$00              ; Tell the ppu there is no background scrolling???<br />  STA $2005<br />  STA $2005<br /><br />@Loop:<br />  JMP @Loop             ; Wait until the interrupt puts the program at Nmi.<br /><br />Nmi:                    ; Jumped to once per frame.<br /><br />Dma:                    ; DMA for sprite copying.<br />  LDA #$00<br />  STA $2003             ; Set low byte ($00) of the RAM address.<br />  LDA #$02<br />  STA $4014             ; Set high byte ($02) of the RAM address and start sprite transfer.<br /><br />; SKIPPED CODE: Read controller<br />; SKIPPED CODE: Check for each button<br /><br />; Should the controller be read before or after the sprite copy function?<br /><br />  RTI                   ; NMI is finished.<br /><br /><br />.segment &quot;VECTORS&quot;      ; The interrupts.<br />  .word Nmi<br />  .word Reset<br />  .word $0000           ; IRQ isn't used.</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6156">DRW</a> — Mon Sep 23, 2013 3:44 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2013-09-22T16:37:59-07:00</updated>
<published>2013-09-22T16:37:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118525#p118525</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118525#p118525"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118525#p118525"><![CDATA[
<div class="quotetitle">DRW wrote:</div><div class="quotecontent"><br />Why is this implemented in the following way?<br /></div><br />That's up to the programmer. I like to do the basic initialization stuff (SEI, CLD, stack, etc.), then this:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">   bit $2002<br />-   bit $2002<br />   bpl -<br />-   bit $2002<br />   bpl -</div><br />Then I consider the system &quot;initialized&quot;. I choose not to clear the RAM like many tutorials suggest, because IMO that tends to hide bugs that would normally arise from you forgetting to initialize specific variables (which you should always do, you shouldn't expect any variables to start out as 0).<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />If I post my own program code of my sample program based on that tutorial, could you please check if everything is correct, what can be removed and what is wrong?<br /></div><br />Most of us don't mind reviewing small sections of code, but when someone posts their entire 1 mile long ASM file, that tends to drive people away.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />Is it even good to do this every frame?<br /></div><br />For games that change these parameters during gameplay, it makes sense. For example, games that use a status bar might enable/disable sprites at the split point so that they don't appear in front of the status bar, and that's a setting they'll have to reset every frame.<br /><br />Another reason to have this in the VBlank handler is to make sure that rendering will not be enabled in the middle of the screen, causing a quick but possibly annoying glitched frame before the gameplay starts. Some people let it run every frame even though it's only necessary for the first frame because it's easier that way.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />How about this: If I write this code right before the forever loop:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA #%10010000<br />  STA $2000<br />  LDA #%00011110<br />  STA $2001<br />  LDA #$00<br />  STA $2005<br />  STA $2005</div>and don't do anything as PPU cleanup before returning from the NMI interrupt, wouldn't that be fine as well?<br /></div><br />Yes, as long as you wait for VBlank before doing this, otherwise you'll get that glitched frame I talked about above.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Besides, when is the NMI called?<br /></div><br />As soon as VBlank starts, so you can make use of that time for VRAM/PPU updates.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Before the current frame or after the current frame?<br /></div><br />I guess it makes sense to say that the NMI happens before the frame, because it's in the NMI that you'll set up everything (background updates, sprites, scroll, etc.) for the following frame.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The first time $2002 is read is during the waitvblank function. O.k., technically it is before the first vblank, but how else should he check if the vblank has occured?<br />So, what should be changed in the code?<br /></div><br />The problem with this loop is that if it starts in the middle of VBlank, there will be no waiting at all, the loop will immediately end. Reading $2002 beforehand (outside of the loop) will clear the VBlank flag, making sure that the loop that follows will wait for the NEXT Vblank, regardless of whether it's VBlank now or not.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Isn't there a program to disassemble NES games? This way we could see the source code of some very simple, yet official Nintendo game, like &quot;Donkey Kong&quot;, and see how this one is initialized.<br /></div><br />We have seen how many official games work, and they all differ greatly.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Wouldn't that be more effective than discussing how many frames the PPU might need etc.?<br /></div><br />We know for a fact how much time is needed for the PPU to be ready, what we discuss is the most effective way of waiting that time. Official games didn't always do things the best possible way. If all you want is to be safe and not bother with the hardware details, just do 3 typical VBlank wait loops in a row and you're good to go.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />This way you would have a definite way, demonstrated by the inventors of the NES.<br /></div><br />Don't assume that programmers back then knew more about the system than we do today. The early games were often programmed while the system was still being developed, so the hardware could still be going through changes, meaning that there could be left over code in these games from when the console was not yet final. Also, from what we know, the programmers weren't given particularly good documentation, and didn't have much time to study the system, because of deadlines and such. I know it may sound surprising, but looking at what official games do isn't always be the best way to learn, because programmers back then were often in a hurry and would go with go through a good deal of trial and error to achieve what they wanted.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sun Sep 22, 2013 4:37 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[3gengames]]></name></author>
<updated>2013-09-22T15:46:54-07:00</updated>
<published>2013-09-22T15:46:54-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118522#p118522</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118522#p118522"/>
<title type="html"><![CDATA[Re: Questions about code details in the Nerdy Nights tutoria]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10524&amp;p=118522#p118522"><![CDATA[
1: Because, why make your game inefficient and crap? Wait for the 1st one, do everything that needs done setting up your engines an such, wait 2nd, set up your engine the rest of the way and start rendering video/get ready to, 3rd+ run whatever...loading code, menus, etc. It taks maybe 8-9 frames total, after the 2 waited, to load a screen and get the menu running if you're lucky.<br /><br />3: It's example code, NN is actually very....not shit, but not great written code, it's average...lots of places for improvement in it.<br /><br />4: You set the NMI and time everything off that. The NMI shown above will not work 100% of the time, it's only good for booting. NMI program to run the vblank code and run the main engine is how it works, you get to set NMI enable by the PPU register $2000, and start running it like:<br /><br />(Main process)<br />-ends, and waits for an flag to change that means NMI has run-<br />(NMI)<br />-tells main process NMI has happened.<br /><br />My main code is:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">Frame is a incrementing counter. Each NMI, it goes up 1.<br />Main engine:<br />-vblank code-<br />-main engine-<br />  LDA Frame<br />.WaitForNMI:<br />  CMP Frame<br />  BEQ .WaitForNMI<br />  JMP -to vblank code-<br /><br />NMI:<br />  INC Frame<br />  RTI<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4311">3gengames</a> — Sun Sep 22, 2013 3:46 pm</p><hr />
]]></content>
</entry>
</feed>