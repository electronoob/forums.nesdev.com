<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=5&amp;t=16058" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2017-07-03T16:01:40-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=5&amp;t=16058</id>
<entry>
<author><name><![CDATA[93143]]></name></author>
<updated>2017-07-03T16:01:40-07:00</updated>
<published>2017-07-03T16:01:40-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=199535#p199535</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=199535#p199535"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=199535#p199535"><![CDATA[
<div class="quotetitle">93143 wrote:</div><div class="quotecontent"><br />I guess it's a question of whether banding or dither looks worse at retarded frame rates<br /></div><br />Okay, no.  I just watched a 60fps video of F-Zero X captured from an HDMI-modded N64, and it seems the dither is stationary.  I should have remembered this; there are scenes where it's pretty obvious even in recollections.<br /><br />Actually, according to the manual, there are two types of dither - stationary pattern dither (as in F-Zero X) and pseudorandom noise, which is of course <em>not</em> stationary.<br /><br />So what does the pattern dither look like when scrolled/zoomed/warped with trilinear interpolation and then dithered again?<br /><br />zelda_far_redither.png<br />Hmm...  not terrible, considering the magnitude of the task being attempted.  Perhaps it would look worse in motion, but the easiest way I can think of to test that would take more time than I want to sink into it...<br /><br />I took a 240x180 chunk out of a (lossy) screenshot of the real game, dithered it down to 15-bit with 2x2 pattern dither in cq, blew it up linearly to 244x183, cropped it back to 240x180, and repeated the dither operation.  Then I doubled it with nearest-neighbour for easier viewing.  (I know the actual screen would be bigger, but I wanted a nondescript chunk of distant terrain without alpha clouds, and this was the biggest gap I could find that didn't have Hyrule Castle in it...)<br /><br />In my scheme, the sky would not be prerendered in the backdrops; it would be rendered fresh every frame, so the double dither effect would only happen to the terrain.<br /><br />Using pseudorandom RGB dither on the second pass substantially obscures the original pattern dither (at least in a static image), but it doesn't look that great either (again, in a static image):<br /><br />zelda_far_renoise.png<br />I'm not totally sure I did that right.  I just added uncorrelated RGB noise at a magnitude of 0.03 in GIMP...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6595">93143</a> — Mon Jul 03, 2017 4:01 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[reborn]]></name></author>
<updated>2017-06-22T12:41:29-07:00</updated>
<published>2017-06-22T12:41:29-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198726#p198726</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198726#p198726"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198726#p198726"><![CDATA[
for me Breath of the wild is very good game!<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=8552">reborn</a> — Thu Jun 22, 2017 12:41 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[93143]]></name></author>
<updated>2017-06-17T15:46:20-07:00</updated>
<published>2017-06-17T15:46:20-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198389#p198389</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198389#p198389"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198389#p198389"><![CDATA[
<div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />now all that's left is implementation <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /></div><br />The easy part, eh...<br /><br />It does seem like this method combined with terrain LOD and simpler rendering for distant polygons could get me quite a long draw distance, but I suppose without experiments there's no way to tell <em>how</em> long for a given level of visual acceptability.<br /><br />There's also still the question of whether the perspective distortion between frames would be adequately small or could easily be corrected to be so, but that seems like a complicated question to deal with when idly discussing blue-sky hypotheticals...  I was thinking perhaps vertices on the boundary between layers could be pinned together and serve as reference points for a warp transform, but I didn't get any further than that.<br /><br />...<br /><br />Now, if anybody here knows enough about CPU and RAM issues in open world games to meaningfully speculate about the feasibility of BotW on N64 (not just &quot;in some form&quot;; I mean fundamentally the same game), <em>and</em> is willing to bother doing so, there might still be something to talk about.  Other than that it's just how to do certain special effects, which is a bit premature given that the engine is barely a concept at this point and is unlikely to get a whole lot further...<br /><br />Oh, what the heck...  Anybody have any ideas on how one might go about implementing mowable grass in large quantities on the N64?  I was thinking of using raised texture mapping or fake parallax mapping, possibly exploiting the mipmapping feature to render cut sections, with special handling (billboard? alpha gradient?) for objects seen behind the grass.  But I don't know enough about the N64 to know how much sense this makes; perhaps I should read up on it some more...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6595">93143</a> — Sat Jun 17, 2017 3:46 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[calima]]></name></author>
<updated>2017-06-14T02:58:44-07:00</updated>
<published>2017-06-14T02:58:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198160#p198160</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198160#p198160"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198160#p198160"><![CDATA[
Oh indeed, I was confused with the count, sorry.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Okay, then why do you need to read twice?<br /></div><br />I assumed RGBA32 source, 4 bytes.<br /><br />Anyway, the handwaving shows it possible, now all that's left is implementation <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7237">calima</a> — Wed Jun 14, 2017 2:58 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lidnariq]]></name></author>
<updated>2017-06-13T15:39:57-07:00</updated>
<published>2017-06-13T15:39:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198141#p198141</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198141#p198141"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198141#p198141"><![CDATA[
<div class="quotetitle">93143 wrote:</div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Why would you need to write twice?<br /></div>Read-modify-write cycle.<br /></div>Okay, then why do you need to read twice?  Sounds like double-counting to me.<br /></div>Plain blitting without transparency is just &quot;read from texture, write to memory&quot;; with alpha it's &quot;read from texture, read from memory, do math, write to memory&quot;. &quot;Read from texture&quot; should be pretty cheap...<br /><br />If the memory controller is specifically designed to support a RMW cycle, it's not particularly more expensive. I know plain old FPM/EDO DRAMs do support this (and the time to do a RMW cycle is roughly 1.5x the time to do just a read or write), but I don't know anything about newer technologies.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3512">lidnariq</a> — Tue Jun 13, 2017 3:39 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[93143]]></name></author>
<updated>2017-06-13T15:11:59-07:00</updated>
<published>2017-06-13T15:11:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198140#p198140</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198140#p198140"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198140#p198140"><![CDATA[
<div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />I did count your bytes. You said 16-bit would drop it from 108 to 96, a loss of 12 bytes, which would mean no normals at all (3 floats = 12 bytes)<br /></div><br />No, I said it would drop it from 114 bytes to 96, which is 18 bytes or nine half-floats.  You said there was a normal on each point.<br /><br />In any case it's not really all that important; the ballpark doesn't change all that much.  There's not much point in micro-optimizing this game unless somebody's actually going to make it...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Speaking of sharing common vertices, are there any disadvantages to it?<br /></div>it does cause cache misses.</div><br />Oh.  Yeah, I can see that being an issue on N64...  If the model can be preprocessed to minimize that, great.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Why would you need to write twice?<br /></div>Read-modify-write cycle.</div><br />Okay, then why do you need to read twice?  Sounds like double-counting to me.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">(why would you need Z-buffering for this?)<br /></div>fillrate savings.</div><br />Oh yeah, that.<br /><br />I was disregarding Z-buffering for the near field on the grounds that it's reputed to have itself been a major hit to fill rate, and turning it off is said to have been step 1 for any developer looking to optimize the microcode.  Under those circumstances, drawing the backdrops could be done back-to-front and there'd be no extra ordering load because the arrangement is so simple.<br /><br />I don't know if software ordering/clipping is sufficient to make up for the lack of a Z-buffer in an open-world exploration game, or if the fill rate benefit is comparable across genres.  Obviously one would want to look into this a bit if one were to actually attempt a project like this...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">15-bit RGB texels with one alpha bit<br /></div>Bad choice IMHO, that results in visible banding in gradients, like the sky or around a flashlight.</div><br />I hadn't thought about that.  I guess it's a question of whether banding or dither looks worse at retarded frame rates (the N64 has a hardware dither feature that I think doesn't affect fill rate).<br /><br />Then again, I wouldn't render the sky on one of these backdrops, because the sun/moon and clouds need to move smoothly, and I don't think they're computationally expensive.  Other than that, most light sources in this game that would be susceptible to banding are in the near field, and those that aren't would probably need special handling anyway.<br /><br />...<br /><br />Okay, according to <a href="https://level42.ca/projects/ultra64/Documentation/man/kantan/step1/2-3.html" class="postlink">this</a>, the RDP does in fact have a 32-bit framebuffer mode, and according to <a href="https://level42.ca/projects/ultra64/Documentation/man/pro-man/pro15/15-05.html" class="postlink">this</a> it has exactly the same format as normal 32-bit RGBA, using the top bits of the alpha channel as coverage and ignoring the parity bits.  So it <em>is</em> (probably) technically feasible to use 32-bit mode, presumably at the cost of fill rate when rendering the layers.<br /><br />Time for a bit of <s>handwaving</s> figuring:<br /><br />Worst case:  32-bit RGBA texture, Z-buffered drawing to a 32-bit final output buffer: 16 bytes RAM access, 20 full screens per frame.  Two backdrop layers at most unless you strongly depart from the layer complexity weighting and/or frame rate scaling in the algorithm I sketched.  Double buffering should suffice, so RAM usage is 1.2 MB plus whatever margin is necessary for scroll/zoom/warp (which could be substantial), not counting the actual output framebuffer or any of the game data.<br /><br />Same as above but with a dithered 16-bit output buffer:  12 bytes RAM access, 27 full screens per frame.  Two backdrop layers, or three if you stretch it.  RAM usage for three layers is 1.8 MB plus margin.  You'll also want extra mesh data for the third layer.<br /><br />Best case: 16-bit RGBA texture, custom Copy+ mode drawing in reduced-aliasing mode and no Z-buffer, assuming no RAM latency issues or internal processing delays: 4 bytes RAM access, 81 full screens per frame.  Three or four backdrop layers, RAM usage comparable to the worst case.  Except that in this case, you're storing a fair bit of extra mesh data, both because rendering is faster in 16-bit (or is it?  You'd want fog at least, and that slows down internal processing) and because there are more layers, so there could be as much as a couple of megabytes worth of extra geometry.<br /><br />Definitely looking at an Expansion Pak for this...<br /><br />...I was talking up geometry streaming upthread, but I'm not so sure it would be such a great idea for actual rendering.  The RSP would have to access the cartridge every time it wanted more vertex data, and the throughput and latency would probably be horrible.  Dynamic environment loading/mesh upgrading, on the other hand, is probably a non-issue with a 50 MB/s ceiling...<br /><br />...<br /><br />I just discovered that while the N64 <em>does</em> have an additive-transparency feature, <em>it doesn't clamp the output</em>.  Which explains a lot...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6595">93143</a> — Tue Jun 13, 2017 3:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[calima]]></name></author>
<updated>2017-06-13T02:16:13-07:00</updated>
<published>2017-06-13T02:16:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198102#p198102</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198102#p198102"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198102#p198102"><![CDATA[
@tepples<br />A 16-bit uniform projection might just get away with it. A table like I meant would have weighted them according to the data, a calculable projection has less chance to do so, so it would need testing whether a projection looks good enough.<br /><br /><div class="quotetitle">93143 wrote:</div><div class="quotecontent"><br />But yeah, I meant for each component, not the whole vector.  <span style="font-size: 50%; line-height: normal">Which you could have figured out by counting bytes...</span><br /></div><br />I did count your bytes. You said 16-bit would drop it from 108 to 96, a loss of 12 bytes, which would mean no normals at all (3 floats = 12 bytes) <img src="http://forums.nesdev.com/images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br />Or maybe I misunderstood and you also reduced some other parts.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Also, why do the numbers in that post show more than three times as many vertices as triangles in some cases?  I can see there being exactly three times as many if common mesh points weren't shared, but...  perhaps they designate special point objects?<br /></div><br />Some models are badly made, and include unrenderable vertices that aren't a part of any triangle. Point primitives or quads is another possibility, I don't remember if Blender counts tris correctly in a quad model without the manual triangulate step.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Speaking of sharing common vertices, are there any disadvantages to it?  It seems like it would significantly reduce the memory requirements...<br /></div><br />In most cases it's the way to go, but it does cause cache misses. In special cases you can render tri strips or fans faster than indexed, they're both ways to share some verts without indices. Another old optimization was to reorder the vertices to minimize cache misses.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Why would you need to write twice?<br /></div><br />Read-modify-write cycle.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />(why would you need Z-buffering for this?)<br /></div><br />&quot;Draw the gun first&quot;, if you drew the HUD and player and maybe some other objects first, those cover significant screen area, meaning those pixels can be rejected on the backdrop layers and often achieve significant fillrate savings. (It's fun to remember all these old-style optimizations that hardly apply in the modern world anymore <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";)" title="Wink" />)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />15-bit RGB texels with one alpha bit<br /></div><br />Bad choice IMHO, that results in visible banding in gradients, like the sky or around a flashlight. You're right it would allow more layers.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7237">calima</a> — Tue Jun 13, 2017 2:16 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[93143]]></name></author>
<updated>2017-06-12T16:53:59-07:00</updated>
<published>2017-06-12T16:53:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198066#p198066</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198066#p198066"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198066#p198066"><![CDATA[
<div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />Three 16-bit signed ints? That would work for normals, as would two. Two wouldn't be enough at desktop resolutions, but 640x480 would let you get away with it.<br /></div><br />I wasn't too worried about format.  Since you suggested it might be possible to drop precision on some elements, I just identified an element I didn't think needed 32 bits of precision.  But yeah, I meant for each component, not the whole vector.  <span style="font-size: 50%; line-height: normal">Which you could have figured out by counting bytes...</span><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Those benchmark numbers are made with no culling at all. If you have numbers from a game, then it depends.<br /></div><br />Not even CPU culling of triangles that are completely behind the camera?<br /><br />There were racing games that loaded something like 9000 triangles into RAM at one time, and since they were racing games, the frame rate target was presumably 30 fps.  That's far in excess of what anybody's claimed the RCP can pull off, and these aren't even the games that people usually claim the highest numbers for.<br /><br />Interesting post here: <!-- m --><a class="postlink" href="http://www.neogaf.com/forum/showpost.php?p=228692001&amp;postcount=2014">http://www.neogaf.com/forum/showpost.ph ... count=2014</a><!-- m --><br />Incomplete chart here: <!-- m --><a class="postlink" href="http://www.oocities.org/zeldaadungeon2000/polygonchart.html">http://www.oocities.org/zeldaadungeon20 ... chart.html</a><!-- m --><br /><br />Also, why do the numbers in that post show more than three times as many vertices as triangles in some cases?  I can see there being exactly three times as many if common mesh points weren't shared, but...  perhaps they designate special point objects?<br /><br />Speaking of sharing common vertices, are there any disadvantages to it?  It seems like it would significantly reduce the memory requirements...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Alpha blending a full screen texture is the most fill-rate heavy operation you can do.<br /><br />Reading and writing the entire size two times, plus Z buffer. 320 * 240 * 10, 750kb per such operation. (4 bytes source, 4 bytes dest, 2 bytes Z)<br />Quoting wikipedia, 62.5MP/s with no mipmapping means 250MB/s. At 20 fps, that would mean 17 layers of blending, and that's with nothing else going on.<br /></div><br />Why would you need to write twice?<br /><br />According to <a href="http://n64.icequake.net/doc/n64intro/kantan/step1/index2.html" class="postlink">this</a>, in 1CYCLE mode (62.5 MP/s) &quot;you can generate pixels that are perspective corrected, bilinear filtered, modulate/decal textured, <span style="color: #EFEFEF"><strong>transparent</strong></span>, and <span style="color: #EFEFEF"><strong>z-buffered</strong></span> at a maximum bandwidth of one pixel per cycle&quot;.  There's no need to use mipmapping, and fogging would be baked in during layer rendering, so the more complex processing associated with 2CYCLE mode is unnecessary.  In any case the RAM can certainly do 500 MB/s in sequential access (copy mode can do four two-byte RGBA pixels per cycle), and the source pixels would be preloaded in 4 KB chunks.<br /><br />With Z-buffering and antialiasing turned off for performance (why would you need Z-buffering for this?) and 15-bit RGB texels with one alpha bit, I'm seeing two bytes read and two bytes written per pixel, and if the microcode is written specifically to handle this case, it should be possible to load and draw multiple full scanlines in one contiguous chunk to minimize bus delays (is it really 640 ns for random access?!).  That's about 80 screens worth of pixels per frame, though bus delays could materially impact that - 640 ns is 320 bytes, and if that has to happen once for every 4 KB read or written, we're already down at 75 screens worth with nothing else interfering.  Adding zoom and warp transforms would decrease the chunk size and make this worse, even assuming the internal processing doesn't add dead bus cycles...<br /><br />Antialiasing without Z-buffering is a thing, and presumably improves fill rate over using both, but it <a href="https://level42.ca/projects/ultra64/Documentation/man/pro-man/pro24/24-04.html" class="postlink">seems</a> turning off antialiasing too can roughly double the fill rate on top of that, which implies to me that in this case antialiasing would add two or three bytes of RAM access to the above, for around 50 screens per frame neglecting bus delays.<br /><br />It's possible that reduced-aliasing mode could look good enough for this application (I <em>think</em> it should work on alpha edges), and it doesn't involve a fill rate penalty (other than the increased load from the other end due to VI activity), which brings us back up to 80 minus bus delays.<br /><br />Even with full 32-bit RGBA source textures and alpha blending/antialiasing but no Z-buffer, I think it'd be four bytes per pixel to load, two to read and two to write, for a total bandwidth requirement equal to that of 1CYCLE mode using a static texture - so, 40 screens worth (minus latency) with realistic smoke and mist.  Then again, rendering the layers to 32-bit RGBA in the first place might be unsupported behaviour (though there are mentions of coverage bits in conjunction with &quot;32-bit mode&quot;; maybe I need to read up on this), not to mention a giant RAM hog even if it did work.  The plume over Death Mountain might require special handling...<br /><br />It's cute how the video system stores extra data in the parity bits...  According to <a href="https://level42.ca/projects/ultra64/Documentation/man/pro-man/pro15/15-05.html" class="postlink">this</a> and <a href="https://level42.ca/projects/ultra64/Documentation/man/pro-man/pro12/index12.8.html" class="postlink">this</a>, a framebuffer value will be read as RGBC5551, with the top coverage bit showing up at the bottom of the data.  The 16-bit texel format is RGBA5551, with the bottom bit being alpha.  Sounds to me like the framebuffer can be used directly as 16-bit texture data...<br /><br />...<br /><br />...wait, the Z-buffer is supposed to be in a different bank so you can access both it and the framebuffer quickly with high granularity.  Doesn't this imply that if you <em>weren't</em> using a Z-buffer, you could do the same trick with the source texture and just pipe it straight through with no recurring bus latency?<br /><br />...and now I've started finding references that claim far lower RAM latency than 640 ns, and one reference to a CPU cache miss being measured at 600+ ns.  What's the actual deal?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6595">93143</a> — Mon Jun 12, 2017 4:53 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[FrankenGraphics]]></name></author>
<updated>2017-06-12T12:11:48-07:00</updated>
<published>2017-06-12T12:11:48-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198044#p198044</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198044#p198044"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198044#p198044"><![CDATA[
Yes, there were top-tier graphics cards when quake was released that could display the game in all its lo fi polygon glory. And it didn't take too long before those resolutions became reasonably priced for consumers. You could argue Quake was the seed of explosion for consumer market graphics cards with 3d capabilities.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7508">FrankenGraphics</a> — Mon Jun 12, 2017 12:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[adam_smasher]]></name></author>
<updated>2017-06-12T12:07:25-07:00</updated>
<published>2017-06-12T12:07:25-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198043#p198043</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198043#p198043"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198043#p198043"><![CDATA[
Quake could run at lots of resolutions higher than 320x240 if you wanted it to...and conversely don't most N64 games run at something like 320x240?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4826">adam_smasher</a> — Mon Jun 12, 2017 12:07 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[calima]]></name></author>
<updated>2017-06-12T11:57:13-07:00</updated>
<published>2017-06-12T11:57:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198041#p198041</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198041#p198041"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198041#p198041"><![CDATA[
Quake's resolution was below 320x240, and its environments were quite blocky. That's why it could get away with a table of 162 (!) normals.<br /><!-- m --><a class="postlink" href="http://www.gamers.org/dEngine/quake/spec/quake-spec33/qkspec_b.htm">http://www.gamers.org/dEngine/quake/spe ... spec_b.htm</a><!-- m --><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7237">calima</a> — Mon Jun 12, 2017 11:57 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2017-06-12T07:33:27-07:00</updated>
<published>2017-06-12T07:33:27-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198027#p198027</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198027#p198027"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198027#p198027"><![CDATA[
<div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />16-bit normals? Do you mean a 555x configuration, or a 768kb lookup table (12 bytes * 65536)? The table would have decent precision, but use too much RAM; a 5-bit signed value means only 16 steps per direction, which would produce visible quantization errors. With normalized 2-component normals, using a 88 config, you'd have 128 steps per direction, which is still too little for flawless rendering, I estimate. Even the third component would have a lot of error because of the low precision.<br /></div><br />The first <em>Quake</em> used normals quantized to 8-bit points on a tessellated icosahedron, and it looked OK. That method of quantizing points requires a lookup table for reconstruction. It's also possible to use a tessellated octahedron, whose lookup table isn't nearly as complex to represent because it maps easily onto the unit square using an octahedral mapping (<a href="https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/" class="postlink">source 1</a>; <a href="https://chengtsolin.wordpress.com/2015/03/30/project-cubemap-to-octahedral-map/" class="postlink">source 2</a>; <a href="http://sol.gfxile.net/sphere/" class="postlink">source 3</a>; <a href="http://www.nkozihomes.co.za/poly.html" class="postlink">source 4</a>).<br /><br />Take a square of stretchy material and draw lines connecting the midpoint of each side to the midpoint of each other side.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">+---------------+---------------+<br />|             - | -             |<br />|           -   |   -           |<br />|         -     |     -         |<br />|       -       |       -       |<br />|     -         |         -     |<br />|   -           |           -   |<br />| -             |             - |<br />+---------------+---------------+<br />| -             |             - |<br />|   -           |           -   |<br />|     -         |         -     |<br />|       -       |       -       |<br />|         -     |     -         |<br />|           -   |   -           |<br />|             - | -             |<br />+---------------+---------------+<br /></div><br /><br />Fold inward along the diagonals.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">                +<br />              - | -<br />            -   |   -<br />          -     |     -<br />        -       |       -<br />      -         |         -<br />    -           |           -<br />  -             |             -<br />+---------------+---------------+<br />  -             |             -<br />    -           |           -<br />      -         |         -<br />        -       |       -<br />          -     |     -<br />            -   |   -<br />              - | -<br />                +<br /></div><br />Stretch the center of this upward (toward you), forming a pyramid. Then fold the flaps under, forming an octahedron. Inflate the octahedron until all points on its surface have the same distance from the center. You now have an octahedral geodesic sphere.<br /><br />On the Nintendo DS, you count quads because each scene can hold up to about 6,000 vertices. A quad is 4 vertices, while two triangles count as 6.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Jun 12, 2017 7:33 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[calima]]></name></author>
<updated>2017-06-12T05:39:42-07:00</updated>
<published>2017-06-12T05:39:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198023#p198023</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198023#p198023"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198023#p198023"><![CDATA[
<div class="quotetitle">93143 wrote:</div><div class="quotecontent"><br />I'm not sure what sort of precision the &quot;texcoord&quot; would need.  The only obvious saving I can see is the normal, which gets you down to 96 bytes if you use 16-bit.<br /></div><br />Texcoord precision depends a lot on your art. A quad floor with a single texture, no tiling or wrapping, gets away with 1 bit. A beatiful heroine? That depends on the skill of your artist, but 8 or 16-bit is probably enough at N64 resolutions. But of course, if there's wrapping or tiling, then you need a sign and possibly scaling, reducing the precision. I doubt N64 supports 16-bit floats.<br /><br />16-bit normals? Do you mean a 555x configuration, or a 768kb lookup table (12 bytes * 65536)? The table would have decent precision, but use too much RAM; a 5-bit signed value means only 16 steps per direction, which would produce visible quantization errors. With normalized 2-component normals, using a 88 config, you'd have 128 steps per direction, which is still too little for flawless rendering, I estimate. Even the third component would have a lot of error because of the low precision.<br /><br />Three 16-bit signed ints? That would work for normals, as would two. Two wouldn't be enough at desktop resolutions, but 640x480 would let you get away with it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />No, I mean how much geometry would have to be stored in RAM, before culling.  4500 tris is after culling.<br /><br />Or have I seriously misunderstood what the &quot;polygons per second&quot; number means?<br /></div>Those benchmark numbers are made with no culling at all. If you have numbers from a game, then it depends.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Super Mario 64 doesn't seem to have much trouble with alpha textures.  Maybe the GMA in question just isn't designed for fast alpha blending?<br /><br />...seriously, that's pathetic.  Even if it is in HD.  Isn't the N64 supposed to have a fill rate on the order of about 40 screens worth of pixels in 240p20 with most effects turned on?  Including alpha?<br /><br />I admit I forgot about fill rate in my enthusiasm for the polygons per scene metric, which is embarrassing as fill rate is well known as a major bottleneck on N64.  That does limit things a bit...<br /></div>Alpha blending a full screen texture is the most fill-rate heavy operation you can do.<br /><br />Reading and writing the entire size two times, plus Z buffer. 320 * 240 * 10, 750kb per such operation. (4 bytes source, 4 bytes dest, 2 bytes Z)<br />Quoting wikipedia, 62.5MP/s with no mipmapping means 250MB/s. At 20 fps, that would mean 17 layers of blending, and that's with nothing else going on.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7237">calima</a> — Mon Jun 12, 2017 5:39 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[93143]]></name></author>
<updated>2017-06-12T03:46:26-07:00</updated>
<published>2017-06-12T03:46:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198020#p198020</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198020#p198020"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198020#p198020"><![CDATA[
<div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />Depending on how flexible the gpu is, and what precision you can get away with, you may be able to use fixed-point u16 or u8 integers instead of floats, etc.<br /></div><br />~100 bytes is about what I'd estimated, even though I did it wrong.  If that can be shaved down a bit, great, but you probably still need 32-bit positions at least.  I'm not sure what sort of precision the &quot;texcoord&quot; would need.  The only obvious saving I can see is the normal, which gets you down to 96 bytes if you use 16-bit.  So probably on the order of 10,000 tris per megabyte at best...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I won't bother spoiling anything until I get to play it myself.<br /></div><br />Probably a good idea.  Best to avoid pumping up expectations, then...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">2) how many triangles would a Zelda-like game use in an environment that peaked at 4500 visible polygons per scene?<br /></div><br />That question doesn't make sense. Every game-targeting artist models with tris or quads, and always measures in tris.</div><br />No, I mean how much geometry would have to be stored in RAM, before culling.  4500 tris is after culling.<br /><br />Or have I seriously misunderstood what the &quot;polygons per second&quot; number means?<br /><br /><div class="quotetitle">calima wrote:</div><div class="quotecontent"><br />It will probably work, but maybe not at the scale you expect on a N64. For reference, an Intel GMA is put to its knees when alpha-blending 6 layers at a resolution of 1920x1080.<br /></div><br />Super Mario 64 doesn't seem to have much trouble with alpha textures.  Maybe the GMA in question just isn't designed for fast alpha blending?<br /><br />...seriously, that's pathetic.  Even if it is in HD.  Isn't the N64 supposed to have a fill rate on the order of about 40 screens worth of pixels in 240p20 with most effects turned on?  Including alpha?<br /><br />I admit I forgot about fill rate in my enthusiasm for the polygons per scene metric, which is embarrassing as fill rate is well known as a major bottleneck on N64.  That does limit things a bit...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6595">93143</a> — Mon Jun 12, 2017 3:46 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[calima]]></name></author>
<updated>2017-06-12T02:53:16-07:00</updated>
<published>2017-06-12T02:53:16-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198012#p198012</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198012#p198012"/>
<title type="html"><![CDATA[Re: Breath of the Wild on N64?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=16058&amp;p=198012#p198012"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Nobody has really commented on my backdrop rendering idea yet. Does it seem like the sort of thing that might work? Has it been tried before?<br /></div><br />It will probably work, but maybe not at the scale you expect on a N64. For reference, an Intel GMA is put to its knees when alpha-blending 6 layers at a resolution of 1920x1080.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=7237">calima</a> — Mon Jun 12, 2017 2:53 am</p><hr />
]]></content>
</entry>
</feed>