<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Need Help Compressing Data on the NES.</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Need Help Compressing Data on the NES.</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5908">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5908</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>1</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>NesHackR</b> [ Tue Jan 05, 2010 6:20 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Need Help Compressing Data on the NES.</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hey everyone.  This is going to be my first post on the NesDev website!  Anyways, on to my question, which is in the title.  What method do you guys usually use to compress data in a NES ROM?  I am asking because while I am doing some good progress on making my first interesting Custom NES game for an emulator (Collision system is in place!  Will discuss question about that some other time.), I realized that at the rate I am using memory (32 bytes for each unique row of tiles embedded in ROM, as opposed to storing each tile as a byte in ROM.), I am going to run out of space if I want to make really unique levels without dramatic repetition.  I also have some other questions about programming for the NES, but I will leave them for other topics. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />  Oh yeah, and for any method provided for compressing data, can you post either 1 - if generous, example code or 2 - pseudo code, which will basically be a word-explanation as to how to do it.  The reason for asking for explainations / code is because although I've studied methods of compression, I am yet to grasp it well enough to do it even at high levels.  But perhaps it will not be as hard to pull of on the NES given there are some neat tricks  I am not familiar with yet!  Also, explanations by human beings as opposed to textbooks can make things much easier sometimes.
<br />
<br />Thank you for any input for solving my problem!
<br />
<br />EDIT:  Changed title so it specifies this as a "help me" topic.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Tue Jan 05, 2010 6:33 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hey, and welcome.
<br />
<br />"Metatiles" are the main thing to use for background.  The typical size is 16x16 pixels, which makes good sense because that's the size of the attribute table to select the colors.  That will bring the memory used per screen to 240 bytes, down from 1024.
<br />
<br />You would have 64 possible metatiles (using 6 bits).  The remaining 2 bits can be used for attribute, but unless you plan on palette-swapping a lot of backgrounds, it's may be smarter select the attribute from a table based on the metatile number.  Then you would have those 2 bits free for collision detection, or whatever else you want to define for any particular block.
<br />
<br />The simplest compression code is run-length-encoding.  All it does is replace a "run" of more than 3 identical bytes with the following - special marker byte, byte to repeat, number of times to repeat.  You can combine this with metatiles, and save a whole lot of memory.
<br />
<br />I hope that helps.
<br />
<br />Another important point is that you need decode all this stuff into a buffer, and dump the buffer into VRAM during vblank.  Because decoding may take some time, and vblank time is short.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>NesHackR</b> [ Tue Jan 05, 2010 9:09 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I read your post, and while it actually was a bit of a review of the options, I decided to put some well pondered thought into how to get as much data out of 8 bits as possible, or 1 byte, and thats when I realized that that 8 bits wasn't the answer that looked most promising.  16 bits was.
<br />
<br />What is it I am thinking of that could make use of 16 bits that seems so good?  Well, it is an untested idea that I need to try out, and I will work on testing as soon as I post this, and has an obvious con as I will present later soon, but I will look for a solution later on.
<br />
<br />First of all, the format using 16 bits:
<br />
<br />AA-BB-CCC-D EEEEEEEE.
<br />
<br />Time to explain what each set does, and it is actually quite simple.
<br />
<br />AA represents a pointer to a set of 3 tiles, where if AA equals 00, then it will refer to no tile, and be ignored.
<br />
<br />BB functions the same way, but points to another tile set, and is ignored if BB equals 00.  You will see shortly why AA and BB are separate.
<br />
<br />CCC tells us how many times to repeat the tiles.  If CCC equals 0000, a special case occurs because if either AA or BB is not zero, this will mean "draw one tile", meaning if CCC equals 1111, this will actually draw 16 tiles.  The reason for this is for the minimum theoretical byte usage for one line of tiles will be 8 bytes, otherwise, it would have to be 10 bytes ( I think this would be the case).  Also, an important note:  The only time that CCC will force the system to draw an empty tile, would be if both set AA and set BB are both set to zero.  It doesn't nessesarily FORCE drawing nothing, but it points to drawing a default, preferably "blank" tile.
<br />
<br />D currently has no function.  I want it to have a use, though.  I will explain why it is omitted when I talk out bit set EEEEEEEE next.
<br />
<br />
<br />Now, on to the heart of my idea.  What would we waste a set of 8 bits on?!  Actually, hold on cowbow, because this part is what makes the idea so effecient!  That is because each bit actually has an idividual meaning!
<br />
<br />The magic:  each bit in the "E Byte" ( I will not quote it after this )  tells us the same thing, but it does either 1 thing or the other for a maximum of 8 times (8 bit set, remember?).  
<br />
<br />For example:
<br />
<br />if bit 7 is 0, it draws one tile that is described by set AA.
<br />
<br />if bit 7 is 1, it draws one tile that is described by set BB.
<br />
<br />Sound simple?  It is, and you may have a few questions that I will happily answer.  If you are still wondering why I am omitting bit D in the first byte, it is because with the system I am using, you can only draw up to 8 tiles with the E Byte.  Thus, bit set CCC only needs to go up to 111, and that number (including zero) can exactly fit the maximum repetition number that is supported by the E Byte.
<br />
<br />Now, for the drawbacks:
<br />
<br />Currently, since I have not tested this idea, it has only a few drawbacks I can see.  With this system, you can typically only point to 6 unique tiles, and to make it worse, you can only draw two different ones at a time.  It may be possible to increase the limit, and one thought I have for that is to implement bit D to serve as a "switch" to point to a different tileset that changes both set AA and set BB's tile pointers.
<br />
<br />The other drawback I have noticed with this approach is its applications.  It is only useful if you have a game where you need to often alternate two different tiles in quick succession.
<br />
<br />In summary, I do think I am onto something that could prove to be a possibly useful compression method, and I still need to find a definitive good use for that bit D.  I shall post some more, possibly in a new thread if I produce any more new ideas.
<br />
<br />Oh, and be sure to give me feedback on my idea guys!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>UncleSporky</b> [ Wed Jan 06, 2010 7:29 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />You're right in that the method you outlined wouldn't be terribly useful.  But you are thinking along the right lines!  Use smaller parts of a byte to define what you might normally take a whole byte or more to do.  The best ways to save space include both the graphical consolidation known as metatiles, and a more literal compression that you might think of in terms of zip files.
<br />
<br />As Memblers said, "metatiles" are a great technique that is used pretty much universally on the NES and many other game platforms.  Considering a single 8x8 tile being the smallest piece a NES can think about, a metatile combines several of those so you can refer to them as one logical piece.  Here are three examples of ways to represent your tiles:
<br />
<br /><img src="http://img218.imageshack.us/img218/2370/exampleh.png" alt="Image" />
<br />
<br />The first is probably what you are doing now, literally storing the ID number of every single tile, 32 across by 30 down.  Very wasteful.
<br />
<br />The second combines each block of four tiles into a metatile.  The graphics are all the same, but the way you store the data changes.  With this method you have a table that records what tiles make up each tile - you're saying "tile 1 = 1, 2, 5, 6" etc.  You have to write a routine to decode this and store the literal tiles in the NES memory as before, obviously.
<br />
<br />The third example is something you might see in Super Mario Bros.  You can compress your data as much as you want, and if you have a lot of large chunks of blocks that always go together you might just want to record that a single ID number results in one huge background object.  Or another way to look at it is, having multiple levels of metatiles.  In the picture, we've already said that "tile 1 = 1, 2, 5, 6" and so forth; then we go to the next level and say that "big tile 1 = 1, 2, 3, 2, 4."  It can get quite complicated to decode, depending on how far you take it.
<br />
<br />Me, I stopped at the second level this time.  Here is the table I have for my current test ROM:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">metadata:<br />.db $00,$00,$00,$00&nbsp; &nbsp;;00 - empty<br />.db $E3,$E6,$E6,$E3&nbsp; &nbsp;;01 - solid center<br />.db $F2,$F3,$F4,$F5&nbsp; &nbsp;;02 - solid variant &#40;big bubble&#41;<br />.db $F6,$F7,$F8,$F9&nbsp; &nbsp;;03 - solid variant &#40;medium bubbles&#41;<br />.db $E8,$E6,$E2,$E3&nbsp; &nbsp;;04 - right wall<br />.db $E3,$EB,$E6,$E7&nbsp; &nbsp;;05 - left wall<br />.db $E4,$E1,$E6,$E3&nbsp; &nbsp;;06 - floor<br />.db $E3,$E6,$EC,$EA&nbsp; &nbsp;;07 - ceiling<br />.db $E0,$E1,$E2,$E3&nbsp; &nbsp;;08 - top left corner<br />.db $E4,$E5,$E6,$E7&nbsp; &nbsp;;09 - top right corner<br />.db $E8,$E6,$E9,$EA&nbsp; &nbsp;;10 - lower left corner<br />.db $E3,$EB,$EC,$ED&nbsp; &nbsp;;11 - lower right corner<br />.db $E3,$E6,$E6,$EE&nbsp; &nbsp;;12 - top left bend<br />.db $E3,$E6,$EF,$E3&nbsp; &nbsp;;13 - top right bend<br />.db $E3,$F0,$E6,$E3&nbsp; &nbsp;;14 - lower left bend<br />.db $F1,$E6,$E6,$E3&nbsp; &nbsp;;15 - lower right bend</div><br /><br />And having recorded that, here is an example of a map screen taking advantage of it:<br /><br /><img src="http://img215.imageshack.us/img215/9580/testmap.png" alt="Image" /><br /><br />The next type of compression I apply is called RLE compression, or Run Length Encoding.  It's very simple.  See all the zeroes in a row up there?  Rather than storing "0, 0, 0, 0, 0, 0" etc., you can just store "16, 0" - that is, just saying "there are 16 zeroes in a row here."<br /><br />Now obviously this does not make sense if you have a lot of individual tiles.  You are wasting space if you have to say "1, 4, 1, 2, 1, 5" (there is 1 four, 1 two, 1 five...)  That is why you program in special cases that let you say "there are 16 zeroes in a row" when you need to, but otherwise you can just store the IDs literally.<br /><br />My own rule that I have coded is this: if the current byte is less than 128, then that is simply the next tile in the sequence.  if the current byte is greater than 128, subtract 128 from it and repeat the next byte that many times.<br /><br />In other words, I am using the highest bit as a flag to tell the program how to treat this byte.  If a byte is in the format %0xxxxxxx, that means the ID number is just whatever the byte is, which in compression terms is called a "literal."  Since I'm using less than a hundred metatiles this isn't a problem.  If however it is in the format %1xxxxxxx, then ignore that 1 and use the rest of the byte as a loop counter for the following byte.  As an example, %10000101 means repeat the next byte 5 times.<br /><br />So knowing that, here is what the above map looks like compressed:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">bg:<br />;simple RLE compressed background using 2x2 metatiles<br />.db 131,0,4,2,5,0,0,4,3,1,1,2,1,3,2<br />.db 131,0,10,7,11,0,0,4,1,2,3,1,2,1,1<br />.db 136,0,10,131,7,13,1,1,2<br />.db 140,0,10,131,7<br />.db 144,0<br />.db 6,9,142,0<br />.db 1,5,0,0,8,9,138,0<br />.db 2,5,0,0,4,5,138,0<br />.db 3,14,6,6,15,5,138,0<br />.db 1,2,2,1,1,14,6,6,9,132,0,8,6,6<br />.db 12,131,7,13,3,1,2,14,9,131,0,4,3,1<br />.db 5,131,0,10,132,7,11,131,0,4,2,1<br />.db 5,140,0,4,1,2<br />.db 5,140,0,4,3,3<br />.db 14,140,6,15,2,1</div><br /><br />You should be able to visibly compare the two and see how it works.<br /><br />So with these two systems working together, we went from 32x30 tiles, which is 960 bytes to store one screen, down to 134 bytes for the screen and 64 bytes for the table that helps define it.  That doesn't include the size of the subroutines that interpret the data but it definitely saves us a lot of space.<br /><br />Just for good measure, here is the subroutine I use to unpack the above RLE-compressed map into RAM:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">unpack_screen:&nbsp; &nbsp;&nbsp; &nbsp;;unpack an RLE compressed screen into RAM &#40;2x2 metatiles&#41;<br /><br />;tmpada = address of compressed screen data<br />;tmp8y = index of compressed screen data<br />;SCREEN = constant address in RAM where data is unpacked<br />;tmp8x = index of RAM location<br />;x = loop counter for RLE runs<br />;a = tile data being loaded and stored<br /><br />&nbsp; &nbsp;;*** make section to detect current screen and get address from table<br />&nbsp; &nbsp;;*** for now, load a single temporary bg<br /><br />&nbsp; &nbsp;lda #&lt;bg<br />&nbsp; &nbsp;sta tmpada&nbsp; &nbsp;;store address of screen data in tmpada<br />&nbsp; &nbsp;lda #&gt;bg<br />&nbsp; &nbsp;sta tmpada+1<br />&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;sty tmp8x&nbsp; &nbsp;;index of how many metatiles have been unpacked<br />--&nbsp; &nbsp;ldx #1&nbsp; &nbsp;&nbsp; &nbsp;;used to handle RLE bits<br />&nbsp; &nbsp;lda &#40;tmpada&#41;,y<br />&nbsp; &nbsp;bpl +&nbsp; &nbsp;&nbsp; &nbsp;;if last bit not set, it's a literal<br />&nbsp; &nbsp;and #%01111111&nbsp; &nbsp;;clear last bit<br />&nbsp; &nbsp;tax&nbsp; &nbsp;&nbsp; &nbsp;;x becomes the loop counter<br />&nbsp; &nbsp;iny<br />&nbsp; &nbsp;lda &#40;tmpada&#41;,y&nbsp; &nbsp;;load tile to be repeated<br />+&nbsp; &nbsp;sty tmp8y&nbsp; &nbsp;;back up data index<br />-&nbsp; &nbsp;ldy tmp8x<br />&nbsp; &nbsp;sta &#40;SCREEN&#41;,y&nbsp; &nbsp;;store tile in screen RAM<br />&nbsp; &nbsp;inc tmp8x&nbsp; &nbsp;;increment RAM index<br />&nbsp; &nbsp;dex<br />&nbsp; &nbsp;bne -&nbsp; &nbsp;&nbsp; &nbsp;;loop if we're in an RLE run<br />&nbsp; &nbsp;ldy tmp8y&nbsp; &nbsp;;restore data index<br />&nbsp; &nbsp;iny<br />&nbsp; &nbsp;ldx tmp8x<br />&nbsp; &nbsp;bne --&nbsp; &nbsp;&nbsp; &nbsp;;we are done copying data when RAM index wraps<br />&nbsp; &nbsp;rts<br /></div>
<br />
<br />If this can be written more efficiently, I am all for hearing it, by the way. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />  I can get stuff to work but I am not very confident in my finesse.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Wed Jan 06, 2010 9:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Well depending on how your level are, it might be good to use 2 layers of metatiles - I do that in the game I'm making. The screen is made of 32x32 big metatiles which are made of 4 16x16 smaller metatiles.
<br />And like you said, it's good to put all bits to good use. For example I have 32 big metatiles available, and I use the upper 3 bits to say if they how many times they're repeated (1-8). It ended up being quite efficient.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>NesHackR</b> [ Thu Jan 07, 2010 7:52 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Well thanks for the input!  You actually clarified what the meta tiles are very much for me!  
<br />
<br />Now, I am currently using a compression method, which I am squeezing a minimum of 4 bytes per "row", and it is working perfectly.  However, I am having a problem that probably everyone has had at some point programming anything for the NES.  I am getting artifacts after writing up to address $2303 in the PPU.  I am suspecting that the problem is that I am running out of time to load the background into memory.  I am loading it only once, which is right out of start-up.  I have read that GBA-guys tutorial is very bad, and it is from his tutorial that I made my VBlank subroutine.  Now, the artifacts will appear, and more specifically, I see no tiles drawn after $2303.  I checked the debugger I am using, and it will show the PPU address resetting to $2000.  This leads me to my question...Am I running out of VBlank time in this case?  Because if the PPU is resetting, I think this is why, because I read somewhere that the PPU registers reset ( I think ) after VBlank.
<br />
<br />I also need someone to help me here.  If time is the problem, how can I extend the time I can take to draw?  Does that mean drawing more than one VBlank, and if so, how can I do this successfully?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Thu Jan 07, 2010 8:28 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If your game doesn't scroll the screen at all, the easiest solution is by far to just disable rendering and have unrestricted PPU access, and once the screen is done you turn rendering back on. But if you plan on scrolling, read on.
<br />
<br />VBlank time is very short. You shouldn't have much logic running during that time, you should use it just to dump data to VRAM. This means, among other things, that you shouldn't be decompressing data during VBlank. Compressed things that have to be sent to VRAM must be decompressed beforehand and buffered, and during Vblank you transfer that buffer to VRAM. If you aren't doing it like this already, this is the first thing to do.
<br />
<br />Note however that even the fastest possible code can't update the tiles and attributes of a full screen in a single VBlank. Most games draw the full initial screen either while rendering is off (which means PPU access is unrestricted) or across several VBlanks while a black palette or the alternate name table (the one that is not being drawn) is displayed. Once gameplay starts and the screen has to scroll, only the tiles that just scroll into the picture need to be drawn, in the form of columns (horizontal scroll) or rows (vertical scroll).
<br />
<br />The VBlank time is enough to update a row and/or a column of tiles, as well as the palette and the sprites, which is enough for most games. If your program works under those requirements, you should do things as I described above without needing any special tricks.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Celius</b> [ Fri Jan 08, 2010 2:13 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Most games draw the full initial screen either while rendering is off (which means PPU access is unrestricted) or across several VBlanks while a black palette or the alternate name table (the one that is not being drawn) is displayed.</div>
<br />
<br />Sorry if this is kind of off-topic, but exactly what advantage would you have of updating across multiple Vblanks with a black palette over just turning the screen off and doing it all at once? The only thing I could think of would be if you used the same updating code that you use in real-time to draw the whole screen. Actually, now that I think of it, in my project I turn the screen off and use the same updating code drawing the first screen the player sees one column at a time, but I do it all in one frame (and disable NMIs)...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Fri Jan 08, 2010 11:48 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Celius wrote:</div><div class="quotecontent">Sorry if this is kind of off-topic, but exactly what advantage would you have of updating across multiple Vblanks with a black palette over just turning the screen off and doing it all at once? The only thing I could think of would be if you used the same updating code that you use in real-time to draw the whole screen.</div><br />Yeah, I guess this is the most obvious advantage. I don't really know if any games aver used the "black palette" approach, but displaying the alternate name table with useful information while a level is loading sure is an interesting option.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Actually, now that I think of it, in my project I turn the screen off and use the same updating code drawing the first screen the player sees one column at a time, but I do it all in one frame (and disable NMIs)...</div>
<br />I used to do it like this too, but there were complications because in my game objects can write to the background as well (background objects check which row/column is being rendered and overwrite the buffer with their own tiles if it they overlap), so I had to simulate the gameplay environment so that objects would work like normal in case they needed to draw to the background.
<br />
<br />Recently I had a different idea, and instead of fooling the objects I decided to jump straight into the gameplay loop and draw the initial screen inside the regular game loop. A few special objects animate the title card sequence while drawing the initial screen 1 column at a time.
<br />
<br />With this I don't need a separate loop before the main loop just to draw the first screen, I just need some special case handling in the main loop, so there isn't any repeated code. I guess this could be enough reason to do it a column per VBlank instead of the whole thing with rendering turned off.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>NesHackR</b> [ Fri Jan 08, 2010 9:03 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Alrighty, partly from reading the responses here, and reading another topic about how to create a proper NES loop, I have now solved my problem with drawing the whole background.
<br />
<br />It turned out that I was making a huge mistake - Drawing the background outside of VBlank.  After noticing that I started drawing in VBlank - sending 128 byte blocks of tile data in at a time, which is about as much as I could squeeze into a single VBlank.  So, I am drawing my whole background in roughly 7 1/2 VBlank cycles, and I am quite happy with the result, with no glitches other than unused sprites on the screen.  I think I'm going to do more searches to remember how to get rid of the phantom sprites.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Celius</b> [ Fri Jan 08, 2010 9:46 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Assuming you're using $4014 with a page in RAM, the simple solution: Set all of the sprites' Y coordinates to $FF.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>1</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>