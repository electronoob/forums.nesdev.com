<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - 6502 ASM trick</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">6502 ASM trick</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=3682">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=3682</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>7</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Nov 11, 2007 12:08 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>6502 ASM trick</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Has it occurred to anyone that it might be useful to have a page of ROM filled with values 0 through 255, so that you can perform operations between the accumulator and the index registers?
<br />
<br />Instructions like ADC, SBC, AND, ORA and EOR all have "Absolute, X" and "Absolute, Y" modes, so if you point to the table with the values and use one of the index registers, the value fetched will be the same as the one in the index register, making it seem like the operation used the values of both registers as operands.
<br />
<br />I guess I have used this trick before, but just for a small subset of the numbers, but now that I think of it, having the full table seems very useful, specially for avoiding temporary variables.
<br />
<br />I don't know exactly why I started this topic, but I'm sure we can discuss other useful 6502 ASM tricks. I also like very much the one where you push an address (minus 1) to the stack and then use the RTS instruction to jump to that address. This can be useful for implementing jump tables, and I'm using this a lot in my game.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sun Nov 11, 2007 1:34 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Great idea! It makes up for the 65xx's general lack of operations that combine A and X directly. Here's an asm summary in case not everyone gets it:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Original code<br />stx temp<br />eor temp ; A = A EOR X<br /><br />; New solution<br />eor table,x ; A = A EOR X<br /><br />table:<br />.byte $00,$01,$02...$0F<br />.byte $10,$11,$12...$1F<br />...<br />.byte $F0,$F1,$F2...$FF</div>
<br />On the other hand, this only saves 2 clocks and 1 byte, so it'd have to be used more than 256 times or in a time-critical area to pay off.
<br />
<br /><strong>EDIT:</strong> corrected clock count and major inefficiency in original code (tax?!? thanks tepples)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun Nov 11, 2007 2:11 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: 6502 ASM trick</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">Has it occurred to anyone that it might be useful to have a page of ROM filled with values 0 through 255, so that you can perform operations between the accumulator and the index registers?</div><br />If you have the ROM space for such a table, and it's aligned, it saves a byte and two cycles over the temporary variable way:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">A:<br />&nbsp; stx $FF&nbsp; ; 2b 3c<br />&nbsp; ora $FF&nbsp; ; 2b 3c<br />B:<br />&nbsp; ora table,x&nbsp; ; 3b 4c<br /></div><br />EDIT: thanks tokumaru<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I also like very much the one where you push an address (minus 1) to the stack and then use the RTS instruction to jump to that address. This can be useful for implementing jump tables, and I'm using this a lot in my game.</div><br />It saves about four bytes off the temporary variable way to implement jump tables but is one cycle slower:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">A:<br />&nbsp; lda hi<br />&nbsp; pha&nbsp; ; 1b 3c<br />&nbsp; lda lo<br />&nbsp; pha&nbsp; ; 1b 3c<br />&nbsp; rts&nbsp; ; 1b 6c<br />B:<br />&nbsp; lda hi<br />&nbsp; sta $01&nbsp; ; 2b 3c<br />&nbsp; lda lo<br />&nbsp; sta $00&nbsp; ; 2b 3c<br />&nbsp; jmp &#40;$0000&#41;&nbsp; ; 3b 5c<br /></div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Nov 11, 2007 3:08 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />You guys are right, the savings are not that incredible. But I always feel bad about using temp variables (because the code looks messy), and it's very hard not to do so with the 6502, that has very few work registers. I liked the illusion that it's possible to have these few operations between the accumulator and index registers.
<br />
<br />256 bytes out of a whole game ROM is not such a high price to pay for cleaner code and slightly more speed. And this can be used for other things too, such as mapper writes on boards with bus conflicts.
<br />
<br />And tepples, as far as I know, "ora table,x" takes 4 cycles to execute, not 5, as long as the table is perfectly aligned to a memory page. Or am I wrong?
<br />
<br />About the jump tables, yeah, it depends if you're aiming at speed or size.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sun Nov 11, 2007 6:02 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">But I always feel bad about using temp variables (because the code looks messy), and it's very hard not to do so with the 6502, that has very few work registers.</div>
<br />Change your idea of messy. The main problem with zero page variables is when two routines try to use one at once. The best way to avoid this is to have temp variables that aren't used across subroutine calls, and aren't used by more than one thread at once (like main code and interrupt handler). But the 6502 has a ton of extended registers: 256 of them. That's why X and Y can't be used directly by arithmetic, only for indexing and counting. Embrace zero page!
<br />
<br />Try coding for the Z80/8085/GB-Z80 for a while and you'll appreciate the elegance of the 65xx. Sure, you can do lots of register to register operations, but everything has a layer of bloat on it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Sun Nov 11, 2007 10:17 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">The best way to avoid this is to have temp variables that aren't used across subroutine calls, and aren't used by more than one thread at once (like main code and interrupt handler).</div><br />OK, but how do you do that and still keep things looking nice? Saying that a byte can only be used by one subroutine is a waste of space, as that byte will probably be unused most of the time. And reusing bytes is not easy when you have many nested subroutines. For routines that need a few bytes of work RAM, you can have a few groups of bytes, each dedicated to a different depth, but then you can't go very deep. And recursion is out of the question. What do you guys do about this?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">But the 6502 has a ton of extended registers: 256 of them.</div><br />Fair enough. I've heard the argument that the 6502 has 256 bytes worth of registers, and I guess this is mostly right.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Try coding for the Z80/8085/GB-Z80 for a while and you'll appreciate the elegance of the 65xx. Sure, you can do lots of register to register operations, but everything has a layer of bloat on it.</div>
<br />I've done very little Z80 work, but enjoyed the fact that I could perform some fairly complicated work without having to touch a byte of RAM. And those shadow registers... that feature has to be useful! I know that instructions take  more CPU cycles than on a 6502 though, probably even more than equivalent 6502 code using zero page RAM.
<br />
<br />By the way, <a href="http://www.atariage.com/forums/index.php?showtopic=71120&amp;st=0" class="postlink">this</a> is a very interesting topic about tricks on the 6502.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Mon Nov 12, 2007 10:57 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I must say I absolutely love the 6502 way to do thing, for me it largely beats PIC, 8080 and Atmel so far, baybe some other CPUs/MUCs I haven't tried yet.
<br />
<br />I have never trought of having such a table of constants, I guess it's only for use if you're short of temp variables and/or if speed is very important. I think wasting 256 bytes is significant on the NES. (unless you have maybe more than 256 KB of PRGROM). This thing could go if you know the number is small enough (something like 0-16) and that a such table is needed anyway (on a cart with bus conflicts). I have encountered a few temporary variable problems so far, I did a whole game engine with only 4 "Temp" variables, and 4 "NMITemp" variables (used in and outside NMI code separately, to avoid pushing the Temp variables or a stupid time-wasting thing like this in the NMI handler). I have encountered problem when I wrote a routine that for example uses Temp1 and Temp2, which calls a routine that uses Temp3 and Temp4, and that itself calls a routine which also uses Temp2 (and exept it to be fully available), this is a real pain to debug. Pushing Temp2 before calling the second routine is the way to go (or do it another way). Eventually it's better to give explicit names to variables. The best way could be to have an assembler which can undefine zero page variables to re-use them, so that the same adress can be used by two pieces of code if the programmer safely says they will never call eachother and that the routine does not expect a particular value to be in when called.
<br />
<br />I also never trought of the push-push-rts way to do indirect jump, I always use the jmp []. The main problem is that the rts adress is not the real adress, and I never know how many it should be added/removed to work. However, it becomes interesting if you use this a lot, as saves a lot time four bytes may become significant. Plus the code looks more messy (this can also add to the geek factor in the other side).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Mon Nov 12, 2007 5:16 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent">OK, but how do you do that and still keep things looking nice? Saying that a byte can only be used by one subroutine is a waste of space, as that byte will probably be unused most of the time. And reusing bytes is not easy when you have many nested subroutines.</div><br />Note my limitation of "that <em>aren't</em> used across subroutine calls". This rules out using them for loop counters, for example (if the loop makes a subroutine call). I admit setting up local variables on the stack is cumbersome and inefficient.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I've done very little Z80 work, but enjoyed the fact that I could perform some fairly complicated work without having to touch a byte of RAM.</div><br />What's so bad about touching RAM? You're constantly reading it anyway for the opcodes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">And those shadow registers... that feature has to be useful!</div><br />I think it's mainly to allow extremely quick interrupt response, where the handler just exchanges registers then processes the interrupt. It doesn't have to save the previous values, <em>and</em> it can keep values in the shadow registers across interrupt handlings. For normal code, it doesn't seem very useful because it swaps so much.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I know that instructions take more CPU cycles than on a 6502 though, probably even more than equivalent 6502 code using zero page RAM.</div><br />That's one problem, always paying for those extras even when the 6502's lean register set would be sufficient. My main gripe is the inconsistencies that you constantly run into. I actually like the SPC-700 sound processor in the SNES a bit better than the 6502. It's like a 6502 with fewer limitations on X and Y, and many instructions to really treat direct (zero) page variables as first-class registers. Most arithmetic and move instructions can use a direct page variable just as easily as A.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">The main problem is that the rts adress is not the real adress, and I never know how many it should be added/removed to work.</div>
<br />Use RTI then:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda #&gt;addr<br />pha<br />lda #&lt;addr<br />pha<br />php&nbsp; &nbsp;; RTI will restore status, so push it now<br />rti</div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Celius</b> [ Mon Nov 12, 2007 9:17 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />That's actually a really clever idea about the table thing. I never really thought about it. One thing that I do that I'm very glad I thought about is my NMI routine can do anything whenever it wants:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">nmi:<br />&nbsp; &nbsp;jmp &#40;$00&#41;<br />&nbsp; &nbsp;jmp &#40;$02&#41;<br />&nbsp; &nbsp;jmp &#40;$04&#41;<br />&nbsp; &nbsp;jmp &#40;$06&#41;<br />&nbsp; &nbsp;jmp &#40;$08&#41;<br />&nbsp; &nbsp;jmp &#40;$0A&#41;<br />&nbsp; &nbsp;jmp &#40;$0C&#41;<br />&nbsp; &nbsp;jmp &#40;$0E&#41;<br />&nbsp; &nbsp;jmp &#40;$10&#41;<br />&nbsp; &nbsp;jmp &#40;$12&#41;<br />&nbsp; &nbsp;jmp &#40;$14&#41;<br />&nbsp; &nbsp;jmp &#40;$16&#41;<br />&nbsp; &nbsp;jmp &#40;$18&#41;<br />&nbsp; &nbsp;jmp &#40;$1A&#41;<br />&nbsp; &nbsp;jmp &#40;$1C&#41;<br />&nbsp; &nbsp;jmp &#40;$1E&#41;<br />&nbsp; &nbsp;lda #$00<br />&nbsp; &nbsp;sta $20<br />&nbsp; &nbsp;rti<br />Return:<br />&nbsp; &nbsp;inc $20<br />&nbsp; &nbsp;inc $20<br />&nbsp; &nbsp;inc $20<br />&nbsp; &nbsp;jmp &#40;$20&#41;<br /></div>
<br />
<br />There may be a slight delay at the end of every routine, but I think it's worth it. There's nothing more I hate than doing a bunch of comparisons to have the NMI figure out what to do and when. Bytes 0-$21 are used up in Zero Page, and $0-$1F start out containing the High and Low parts of the "Return" address. $20/$21 contain the High/Low parts of wherever you are in the NMI routine. I personally am very very happy with it. I almost considered it a trick, or cheating when I first thought about it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Mon Nov 12, 2007 10:31 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />My solution to have a bunch of different NMI routines is this:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">NMI:<br />&nbsp; &nbsp;jmp &#40;NMIAddress&#41;</div><br />That is all there is to the actual NMI routine indicated by the vector at the end of the ROM. The label "NMIAddress" points to a zero page location, and depending on where in the game we are, that location points to one of many different NMI routines:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">NMITitleScreen:<br />&nbsp; &nbsp;&#40;...&#41;<br />&nbsp; &nbsp;rti<br /><br />NMIPlayerSelect:<br />&nbsp; &nbsp;&#40;...&#41;<br />&nbsp; &nbsp;rti<br /><br />NMIMainGame:<br />&nbsp; &nbsp;&#40;...&#41;<br />&nbsp; &nbsp;rti<br /><br />NMIEndingSequence:<br />&nbsp; &nbsp;&#40;...&#41;<br />&nbsp; &nbsp;rti</div>
<br />I'm defining lots of "program modes" for my game, where each section (title screen, player select, title card screen, main game, bonus stage, etc) is represented by a program mode, that when initialized sets the address of the NMI routine it uses. All modes have triggers that enable the transition to other modes.
<br />
<br />This way does not waste RAM (only 2 bytes are used to hold the address of the current NMI routine), and there is no speed penalty besides the time taken by the JMP instruction.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Tue Nov 13, 2007 12:18 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Why not just have the main code wait in a loop until NMI fires and sets a global flag? Then you don't have to worry about taking too long before the next NMI and having it interrupt a previous invocation. Or maybe you are saying you do this, you just also have a settable NMI routine that does things that <em>must</em> be done every frame, even if that frame appears the same as the previous.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Tue Nov 13, 2007 9:17 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">Why not just have the main code wait in a loop until NMI fires and sets a global flag?</div><br />I have other projects that require constant calculation in order to avoid severe slowdown. Waiting for the NMI would be a waste of time when you could already be preparing data for the next frame. Not in my current project though.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Or maybe you are saying you do this, you just also have a settable NMI routine that does things that <em>must</em> be done every frame, even if that frame appears the same as the previous.</div>
<br />That is certainly true for the music routine, for example. And since I also enable rendering late in the frame, I need NMI's to always use the same ammount of time. I can't ignore a single VBlank, or else the screen will jump.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Tue Nov 13, 2007 9:38 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Blargg, the method you describe is close to the one used in Final Fantasy, where the NMI just returns doing absolutely nothing. The game is free to call an NMI when it want without problems. The only true problem is that's it's possible to completely miss an NMI.
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">That is certainly true for the music routine, for example. And since I also enable rendering late in the frame, I need NMI's to always use the same ammount of time. I can't ignore a single VBlank, or else the screen will jump.</div> In theory, Final Fantasy's music would also lag if the game does, but it does never lag anyways. You can however hear this in Final Fantasy II when you change rooms, the music don't change (like in Final Fantasy) and the music seriously lags (the game also seems to silent all channels for some reason, so the music will stop and restart a bit late on the next note), this also applies when entering/exiting menu.
<br />I also remember Zelda and SMB happens to lag, with the music too. This looks extremely bad.
<br />
<br />Final Fantasy III does exactly what Tokumary says, it has a "variable NMI vector", wich is slightly better, instead of wasting a jmp [xxx] instruction, the NMI vector directly points to RAM where a jmp instruction is stored (takes less time). This instruction is also ocasionally changed to a rti to completely ignore NMIs.
<br />
<br />Celuis : I don't undersand anything to the method you described to us. It looks interesting however. Could you try to clarify it a little please ?
<br />
<br />By the way I personally went the way of defining NMI the standard way (in ROM), and have it do the main graphics update and sound. That way, the music never lags, and even if the game lags, the NMI will still update the screen as fast as it can. It's even possible on the main program to synchronise on the graphic update flag (instead of the NMI flag) so if you want to update lots of graphics at once it takes more than a frame and causes no problem.
<br />This just sounds sort of logical, and as long as different parts of the game use the same format of graphic buffers, the same NMI handler can be used for the whole game. That would be unoptimal for really big games, I think. (games with lots of unrelated minigames or such, which all have independant use of the screen, or a RPG where battle/field/menus, etc could be separated because they manage their screen completely differently in each case).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Celius</b> [ Tue Nov 13, 2007 10:10 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent"><br />Celuis : I don't undersand anything to the method you described to us. It looks interesting however. Could you try to clarify it a little please ?<br /><br /></div>
<br />
<br />Oh, sorry about that. Let's pretend that there was an Indirect Absolute JSR instruction:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">nmi:<br />&nbsp;jsr &#40;$00&#41;<br />&nbsp;jsr &#40;$02&#41;<br />&nbsp;jsr &#40;$04&#41;<br />&nbsp;...<br />&nbsp;jsr &#40;$1E&#41;<br />&nbsp;rti<br /></div><br /><br />That's pretty much what my routine would do. It has the Low/High parts of the addresses you want to go to in RAM. So if I want to do a screen updating routine at the beggining of the NMI, somewhere in the code, I'll store the Low/High parts of the address that points to wherever the screen updating routine is in $00 and $01, because at the beggining of the NMI, you see that it jumps to whatever address is stored in $00/$01. After the routine is done, we return to the NMI routine, and it goes onto the next address, which is stored at $02/$03. So if Indirect Absolute JSR was possible, it would look like this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">nmi:<br />&nbsp;jsr&#40;$00&#41;&nbsp; &nbsp; ;The Low/High parts the lable &quot;ScreenUpdate&quot; are stored in $0/$01<br />&nbsp;jsr&#40;$02&#41;&nbsp; &nbsp; ;The Low/High parts of the lable &quot;Control&quot; are stored in $02/$03.<br />&nbsp;...<br />&nbsp;jsr &#40;$1E&#41;&nbsp; &nbsp;;The Low/High parts of the lable &quot;Nothing&quot; are stored in $04/$05.<br />&nbsp;rti<br /><br />ScreenUpdate:<br />&nbsp; ....&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;We come here at the beggining of the NMI routine.<br />&nbsp;rts<br /><br />Control:<br />&nbsp;....&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;We come here after ScreenUpdate<br />&nbsp;rts<br /><br />Nothing:<br />&nbsp;rts&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This is a blank routine we come to if we have nothing to do<br /></div>
<br />
<br />That's basically what my routine does, except there's no such JSR($xx), so I have to use JMP($xx). Instead of doing RTS at the end of every routine I go to, I jump to a lable called "Return". At the Return lable, I tell it to jump back into the NMI routine, but instead of jumping back to where it was before, it'll jump to that + 3 bytes, so it will move on to the next JMP($xx) instruction. If I'm not using all 16 addresses, I make the ones that I'm not using to point to the address of the Return lable. It's just like what I showed above with the JSR($xx), except I just manipulated jump instructions to have the same effect. If I still didn't explain that very well, I can try again if you want... I'm not very good at explaining things.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Tue Nov 13, 2007 1:04 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Oh, your idea looks quite good ! Maybe a little TOO flexible, but this can come in usefull.
<br />I guess there is plenty way to improve it, have the NMI point in a ROM adress wich does jmp($00), then the code at $00 would automatically do jmp($02) when it's done, etc... The problem is that the order cannot be nested, and I guess you don't want to have this limitation. You can also have a big jsr xxxx jsr xxxx jsr xxxx table in RAM, have the NMI point to it, and just change the adress as you wish. You can replace the jsr by a cmp or something to skip the routine without wasting time, you can change the first jsr by rti to completely ignore the NMI, or you can just replace the adress after the last jsr by a rti, making a variable-lenght NMI routine (but still have a maximum of course).
<br />You'd still want to push the registers on the stack before the first jsr.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>7</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>