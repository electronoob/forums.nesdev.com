<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - How hard is it to write an emulator ?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">How hard is it to write an emulator ?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10785">http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10785</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>3</strong> of <strong>4</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sat Dec 14, 2013 10:17 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />There's nothing wrong with making a phone with some buttons on it. But everyone had to copy the iPhone.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Zelex</b> [ Sun Dec 15, 2013 1:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'd actually say that writing a NES emulator should be required for being a programmer. It teaches your how computers work at such a level that is unmatched by anything taught in most schools today.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Sun Dec 15, 2013 2:33 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Zelex wrote:</div><div class="quotecontent">I'd actually say that writing a NES emulator should be required for being a programmer. It teaches your how computers work at such a level that is unmatched by anything taught in most schools today.</div><br /><br />A while back, I was in a community college intro to programming course. I showed the teacher my NES emulator, and she was interested in it and played a game of Super Mario Bros... but when I was explaining how it works and showing her the code, she just plain couldn't seem to understand it at all. Not even the basic concepts. I even wrote up a fairly in-depth 5-page document explaining the basic operation and design in sections, she was still completely lost. I thought it was kind of funny and sad at the same time. Not sure how she got her job. She was only teaching rather simple classes like basic Java and designing some GUIs in VB .NET, but she still had a degree of some sort in computer programming.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Dec 15, 2013 3:02 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Zelex wrote:</div><div class="quotecontent">I'd actually say that writing a NES emulator should be required for being a programmer. It teaches your how computers work at such a level that is unmatched by anything taught in most schools today.</div><br />Well this is a dumb statement. I didn't write no emulator, and I still know perfectly well how computers works at low level (in fact you could say this is my job). A huge part of it (DRAM controllers, caches, pipelines, multi-master buses, ...) is not part of the NES either, because it's too old.<br /><br />Sure making a NES emulator could be one way among other to educate someone about this stuff.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> Not sure how she got her job. She was only teaching rather simple classes like basic Java and designing some GUIs in VB .NET, but she still had a degree of some sort in computer programming.</div><br />Well I don't know how it works for other countries, but for my personal experience, many teachers at college are somewhat incompetent. Those who are competent becomes director or something and don't teach anymore. Teachers are uni are very competent and there's like a huge gap between the two. This doesn't apply to ALL techers either (in both cases), just the general consensus.<br /><br />It's already great you could do actual computer science at college. In my country, real CS is not taught at all before uni, but many guys (like me) starts at 12-ish to do it during their free time. The only CS which is taught is Word, Excel, etc.. which isn't any CS at all.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Sun Dec 15, 2013 3:07 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Zelex wrote:</div><div class="quotecontent">I'd actually say that writing a NES emulator should be required for being a programmer. It teaches your how computers work at such a level that is unmatched by anything taught in most schools today.</div><br />I would (respectfully, not argumentatively) disagree with this.  I would instead advocate that to &quot;be a programmer&quot; the individual learn assembly language.  Aside from microcode, this is about as low-level as you can get interfacing with a processor (and thus bits/pieces of a computer), which teaches you what the actual processor works with (data-wise) and how to accomplish tasks with it.  You don't have to learn how the CPU actually works (silicon level or microcode a la Pentium and later era) to write assembly.<br /><br />I still to this day believe that if more programmers today grasped assembly that they would write their software with those sorts of design choices in mind. (Yes the CPU architecture matters, but not so much as the base concepts of knowing what opcodes do, how registers work, indirect addressing, etc.).  The example I give people all the time is &quot;objects&quot; and how they're just a complete waste of time on numerous levels, solely because the processor itself has no concept of what an &quot;object&quot; is.  Processors <strong>do not</strong> work with &quot;objects&quot;, they work with very specific types of data, with very strict and specific limitations and operations.  Any abstraction or &quot;magic happy cloud widget&quot; is something that has to involve CPU time at some level, and the benefits of it I have never seen justified in any way.  All the processors I've used and coded for understand the concept of a subroutine (a function if you will), and that's it.  Not classes, not namespaces, not ambiguous magical types where T_LELE_X behaves in some mundane manner.<br /><br />KISS principle should be taught heavily in anyone who wishes to be a programmer.  And while I will never, EVER be a &quot;programmer&quot; (by profession nor self-proclaimed), I can apply what I've learned programming in assembly on those processors to anything else I do in any other language, even all the way down to shell scripting.  It's a thought process that stays with you forever -- and it's a thought process that isn't being taught in school, or even socially amongst PL advocacy groups.  It's very sad.  We're a dying breed of people.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Dec 15, 2013 3:18 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I toally agree with you Koitsu. Even if you end up not using assembly most of the time (because this is really counter productive in the 1st sense of &quot;producive&quot; - that is you're not proficient in programming), knowing what's happen at low level will help to make good choices at high level. The reverse is not true clearly.<br /><br />No matter how often people say &quot;compilers will be able to make something optimal out of it&quot;, it's simply plain wrong, or true only for the really advanced compilers and not applicable to gcc which is used by most people.<br /><br />Computers don't work with objects, ever, but you'll have to admit they're very useful when you're dealing with things like resizeable arrays, matrices and vectors and stuff like that. Basically they're idioms for structures + a set of functions which deals with those structures. They're just a tool to be more proficient in programming and organizing the code better. Whenever it actually make sense to use this tool or not depends on the context. Anything which is &quot;pure object oriented&quot; or anything in the like pisses me off. There is no point in this. Why would you limit yourself to use only objects when you can also use something else ?<br /><br />Anyways I think we're getting completely off topic here.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>thefox</b> [ Sun Dec 15, 2013 3:44 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well I don't know how it works for other countries, but for my personal experience, many teachers at college are somewhat incompetent. Those who are competent becomes director or something and don't teach anymore. Teachers are uni are very competent and there's like a huge gap between the two. This doesn't apply to ALL techers either (in both cases), just the general consensus.<br /><br />It's already great you could do actual computer science at college. In my country, real CS is not taught at all before uni, but many guys (like me) starts at 12-ish to do it during their free time. The only CS which is taught is Word, Excel, etc.. which isn't any CS at all.</div><br />In the U.S. the word <em>college </em>is used synonymously with <em>university</em>.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Dec 15, 2013 3:58 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Really ? For me college is where you're at between 12 and 15 years old.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Sun Dec 15, 2013 4:24 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Zelex wrote:</div><div class="quotecontent">I'd actually say that writing a NES emulator should be required for being a programmer. It teaches your how computers work at such a level that is unmatched by anything taught in most schools today.</div><br /><br />Doubt it. Knowing how to write an NES emulator has made me familiar with the general workings of processors (instruction set, addressing modes, registers, flags), but nothing more. The other components vary too much from system to system. All the things you can learn by making an NES emulator, you can learn by knowing some NES-specific 6502 assembly IMO. Spending so much time on an emulator for a very similar result which can be achieved in much less time is counterproductive.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well I don't know how it works for other countries, but for my personal experience, many teachers at college are somewhat incompetent. Those who are competent becomes director or something and don't teach anymore. Teachers are uni are very competent and there's like a huge gap between the two. This doesn't apply to ALL techers either (in both cases), just the general consensus.</div><br /><br />There's a lot of confusion about the word college I think. In the US, community colleges are a lower-level college where you get a lower degree, while normal colleges and universities are the same (I think). In my country we have a different system from both the US and Switzerland. These educational systems are not universal.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Anything which is &quot;pure object oriented&quot; or anything in the like pisses me off.</div><br /><br />Objects are just a very simple concept to grasp and use. I don't know why anyone would ever go against objects. They're an amazing tool. Sure, they're far away from the lower-level happenings of computers, but so what? They make jobs a lot easier. I'm programming my emu in Java... and objects are definitely being used <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Anyways I think we're getting completely off topic here.</div><br /><br />Well yeah... but hasn't everything been said already about this topic, or is there more info required?<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Really ? For me college is where you're at between 12 and 15 years old.</div><br /><br />That explains why you think college teachers are incompetent. Why would a teacher for 12 - 15 year old &quot;kids&quot; know how to program an emulator?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sun Dec 15, 2013 6:05 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; I'd actually say that writing a NES emulator should be required for being a programmer.<br /><br />Learning how to write an NES emulator by reading documentation and copying other emulator source code doesn't teach you much more than copying.<br /><br />Give someone a bunch of NES ROM images, and maybe an official 6502 manual, and absolutely ensure no internet access to research the problem. If they manage to make progress, they're going to learn reverse engineering skills.<br /><br />That's what emulator development really boils down to: reverse engineering, and copying others' reverse engineering.<br /><br />Does a great programmer need to be able to reverse engineer? I think it's a very useful skill to know, like electrical engineering, but not applicable to many types of programming.<br /><br />&gt; Processors do not work with &quot;objects&quot;, they work with very specific types of data, with very strict and specific limitations and operations. ... We're a dying breed of people.<br /><br />I understand the allure of working as low-level as possible. The lowest I've gotten down to was building a booth multiplier out of NAND gates for fun.<br /><br />I've definitely rewritten video operations (scale blit, alpha blending, etc) in x86 assembler and seen at least a doubling of performance compared to very well written C versions.<br /><br />I also completely agree that it's very, very beneficial to understand how processors actually operate. Much moreso than even reverse engineering and electrical engineering skills.<br /><br />But you really can't dismiss higher-level programming out of hand simply because processors don't actually work that way. This is the whole basis of foundation / building-blocks / abstraction.<br /><br />Scripting languages work on native functions, which work on assembly instructions compiled from native languages, which work on processors designed from logic gates, which work from electrical engineering principles, which work on physics principles. But virtually no programmer is going to benefit from understanding how quarks and gluons interact.<br /><br />Assembly language is fun at a very small scale of highly optimized programming. But this does not scale. The bigger your project gets, the harder it is to keep track of everything. We write objects to abstract important concepts like vectors that auto-resize, and text-edit widgets that do incredible amounts of work under the hood.<br /><br />We are able to build truly complex applications only through abstracting away lower levels. It's easy to micro-optimize a tiny function and crush a C compiler, but try writing your own 3D renderer that outperforms what you could do with Direct3D or OpenGL's hardware acceleration made possible only through abstraction.<br /><br />It's also not at all portable, which is a really big problem these days now that x86 is losing substantial ground. Many are moving to amd64, and many are moving to ARM. Projects like ZSNES and nocash's emulators are never going to run on ARM targets short of emulating the emulators.<br /><br />In the real world, writing an entire application in assembly is just wasting time. Profile your code and offer hand-tuned assembly versions for any critical functions. But trying to beat the compiler at a function that consumes 0.01% of CPU time? That's silly, and I'd rather have vastly more readable C++ code than a big blob of unstructured assembly code to read through and debug.<br /><br />There is definitely a problem with abstraction being taken too far, with the likes of eg Javascript. I find it absolutely hilarious that it's a major bragging point for browser vendors that my i7 can now just barely run a Nesticle-class NES emulator at fullspeed (maybe even with sound!), when I did that same feat on a 25MHz 486SX. I know why this is, dynamic languages are absolute hell to optimize, and looking up a function or variable at O(log n) while a program runs compared to compiled to O(1) makes a world of difference that no amount of fancy Javascript engine naming will ever overcome.<br /><br />Python, Ruby, Javascript etc are insanely slow. I think they have their uses in small scales, but the term &quot;programmer&quot; has become far too catch-all. The difference between an EE and an assembly/C programmer is probably less severe than the latter to a Javascript programmer. You pretty much move from implementing things to gluing existing things together. Great for business, poor for data center performance. You can bet your ass Google's never going to power its core search algorithms used by billions of people to scour the entire internet on a scripting language, no matter how incredibly efficient they become in the future.<br /><br />Yet when it comes to a business worker whose boss just wants a web form interface to search a SQL DB and return 10 results, a scripting language is just fine for that.<br /><br />But it's really silly to compare writing a while-loop and calling an odbc_fetch_rows API to someone implementing the actual engine that runs a database driver. Yet for some reason, we call both of them programmers, as if it's even remotely similar. So I think this is what leads those who understand algorithms (merge sort, red-black trees, fast fourier transform, etc) to take a dismissive stance against the higher and higher level languages that completely abstract this stuff away.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Dec 15, 2013 6:24 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Well yeah... but hasn't everything been said already about this topic, or is there more info required?</div><br />Yeah, almost everything has been said I guess, I just wanted to know how much parallelism was exploited in current emus.<br /><br />Also I guess for NES emulators it's easy to cache the ROM in the host system's RAM since it'll never be bigger than ~1MB, but what about larger systems (like the ones with CD-ROMs for instance) ?<br />How does emulating a storage with a large char array scale ?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sun Dec 15, 2013 6:44 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; Yeah, almost everything has been said I guess, I just wanted to know how much parallelism was exploited in current emus.<br /><br />Modern processors cannot do synchronization between cores at a rate of more than ~100,000 syncs per second, even with the lowest-level atomic operations. Try it yourself and see.<br /><br />My SNES emulator has to switch between the CPU/SA-1 and CPU/PPU at a rate of up to 10,000,000 times per second to keep perfect timing accuracy to the real hardware (I avoid synchronization whenever possible, but the SA-1 shares RAM, which is impossible to predict when one might access the same RAM byte at near the same time.)<br /><br />Parallelism isn't helpful for older generation consoles with strict timing. It's only when you start getting to modern systems where you can render entire scanlines or frames with no impact on any games that it becomes increasingly viable. The less timing sensitive a system, the more you can parallelize it safely. But even if it doesn't matter, your emulator becomes less accurate for it.<br /><br />Atari 2600 is probably a 10.0 on timing sensitivity, NES a 9.5, SNES an 8.5, PS1 a 5.5, PS2 a 4.0, PS3 a 3.0, etc. (very rough numbers as an example, I don't actually know much about the PS systems.) I'm sure some of these modern emulators can offload an entire frame render without synchronizing at all to the CPU.<br /><br />&gt; How does emulating a storage with a large char array scale ?<br /><br />When you emulate a CD/DVD/BD-ROM drive, you do your disk fetching when the emulated disk drive would seek and read. The disk drives emulated are usually really slow anyway so this is fine, but an emulator can suspend emulated system time anyway.<br /><br />Already there are GBA games that pause my system for a second or two on load to pull in 32MB into RAM.<br /><br />When it comes to NDS games (up to 2GB), or maybe CD-ROM only, you <em>can</em> start using mmap instead of fread. Basically, you reserve the size of the file in memory but don't actually load it in. When you access an area for the first time, a tiny block of it (4KB or 4MB or whatever) is loaded in from disk on the spot. Subsequent fetches will have that data already in memory. Downside is that initial fetch can take a while (it becomes an access violation, which enters ring 0 to load the data from disk and resume), upside is your emulator doesn't freeze completely for 2-5 minutes when opening a game. Also, when your system gets low on memory, mmap can start releasing cold pages. It's all handled by the OS, so it's really spiffy to an end user.<br /><br />But yeah, you can scale a char array all you want, provided you have the RAM available for it. The whole thing will never fit into the faster cache, but hot sections of emulated code that's constantly accessing a particular area will get pulled into lower and lower cache levels, so in practice it's going to continue to beat fetching from disk.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Sun Dec 15, 2013 7:02 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Great, thank you.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Modern processors cannot do synchronization between cores at a rate of more than ~100,000 syncs per second, even with the lowest-level atomic operations. Try it yourself and see.</div><br />This explains that. 100k sync per second would be about 1666 I/O operations per frame, is there this much ? Any ways, in the case of a game for example polling $2002, then the answer is yes. So you have to do a cycle-accurate emultion for those cases anyways. Trying to short-circuit that is sure possible but it'd be very complicated and not worth the trouble, right ?<br /><br />So basically MMap can read a file and automatically cache parts that are used in RAM ? Sounds like a great feature.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sun Dec 15, 2013 7:39 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; 100k sync per second would be about 1666 I/O operations per frame, is there this much ?<br /><br />There can be. I have a trick with my CPU/PPU where I keep a copy of the H/V counters inside the CPU (it's extremely predictable with perfect accuracy), even though real hardware only goes off the PPU H/V pins. This lets me run the CPU ahead when querying for Hblank, Vblank, IRQ, NMI. So I only have to sync on other register accesses.<br /><br />The SA-1 is much more pathological. Both the CPU and SA1 can access the same block of work RAM at the same time. If the CPU is ahead of the SA1, and it tries to access memory, it has to wait for the SA1 to catch up, because the SA1 might access that same address. The reverse is equally true. So any RAM access at all, read or write, requires synchronization. This easily hits millions of syncs a second in the average case.<br /><br />Sure, I could fake it and sync once per opcode, and cut 75% of syncs out, and I bet all SA1 games would still run, but their timing would be somewhat off.<br /><br />(Even more fun, technically the SA1 memory controller will stall its CPU if it detects the SNES CPU is accessing the same bus at the same time. Nobody emulates this yet. The requirements would be astronomical.)<br /><br />&gt; Trying to short-circuit that is sure possible but it'd be very complicated and not worth the trouble, right ?<br /><br />It's possible to keep a write buffer on a chip running ahead, and the chip behind pulls values from that buffer with a timestamp (implement as a binary min-heap priority queue.) But you can't do that with reads when a chip is ahead (the value is not yet known.) The overhead of this buffering may well be worse than the synchronization, especially with an optimized cooperative threaded model.<br /><br />The only other option is even more extreme. Allow the CPU to run ahead and read and write to RAM freely, but if you detect the SA1 accesses the same region when it catches up, perform a rewind (basically load an older save state) and increase your granularity for that section. This is extremely complex, and has substantial performance impact. Nemesis did this for his Genesis emulator, Exodus. And while it works, it's pegging out a quad-core Intel processor now. My cooperative model pegs out a Core processor too, but only one core on it. So why require four cores when you can do it with one?<br /><br />The bigger question is if Nemesis' model will scale to even more powerful systems, but I believe rewinding state will also scale in complexity and resource requirements.<br /><br />Still, what he's doing is awesome. My absolute favorite part of emulation is researching the synchronization problem, so I love seeing new ideas in actual implementations.<br /><br />&gt; So basically MMap can read a file and automatically cache parts that are used in RAM ?<br /><br />Yep. It's not terribly efficient, but it's fun to be able to use it just like a regular char* array. Writing works, too.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun Dec 15, 2013 9:08 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How hard is it to write an emulator ?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">koitsu wrote:</div><div class="quotecontent">Any abstraction or &quot;magic happy cloud widget&quot; is something that has to involve CPU time at some level, and the benefits of it I have never seen justified in any way.</div><br />The benefit of language features is rapid development, so that Microsoft or Mozilla or Google can finish a web browser that lets you post on forums.nesdev.com before you die.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">All the processors I've used and coded for understand the concept of a subroutine (a function if you will), and that's it.</div><br />A method is a subroutine associated to a particular data type. Virtual functions are just a jump table, a way to choose the right function to operate on a particular data type whose memory is organized similarly to related types.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Why would you limit yourself to use only objects when you can also use something else ?</div><br />Programming with a type system allows compile-time checking of certain program correctness axioms associated with each type.<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">For me college is where you're at between 12 and 15 years old.</div><br />Then it must be the same as <em>colegio</em> in Spanish-speaking countries, which corresponds to &quot;high school&quot; in the United States. In the USA, college means university.<br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">When it comes to NDS games (up to 2GB), or maybe CD-ROM only, you can start using mmap instead of fread.</div><br />So what would you do when you emulate a 4 GB CF-like or SD-like card, such as the 3DS or PS Vita Game Card? It's too big for RAM on 32-bit machines and too fast for HDD. Even a 2 GB ROM is too big for 32-bit systems without 3 GB support.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>3</strong> of <strong>4</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>