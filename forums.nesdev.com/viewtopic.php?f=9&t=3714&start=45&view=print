<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Reverse engineering help - Reward$$</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Reverse engineering help - Reward$$</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=9&amp;t=3714">http://forums.nesdev.com/viewtopic.php?f=9&amp;t=3714</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>4</strong> of <strong>6</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Sat Dec 08, 2007 3:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Here's some more data with the higher bits.<br /><!-- m --><a class="postlink" href="http://neviksti.com/blackbox/ID004DC_high2.csv">http://neviksti.com/blackbox/ID004DC_high2.csv</a><!-- m --></div>
<br />Still nothing.  By cross-comparing this with 4d0, it can be seen that 4dc produce less clear tables (the "standard deviation" of the data is lower, to say it that way); i'm guessing this is simply due to the effect of the different subkeys in the inner rounds; 4d0 seems to correspond to a "weaker" case.
<br />
<br />I'm not so interested by now on 4dc so as to insist on this; it would probably better to try it with 72 by the reasons you said.
<br />
<br />
<br />EDIT: Ooops, forget what i said; i had mixed things from the previous test with 72 in this. After correcting the problem, it's clear what happens in the upper nibbles of 4dc: S1 is applied to all the nibbles (from #0 up to #7). So simple.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Lord Nightmare</b> [ Sat Dec 08, 2007 5:41 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />offtopic but important info about decapping stuff:
<br /><!-- m --><a class="postlink" href="http://www.stockly.com/forums/showthread.php?s=d32acabba2a8cca894b56b08e05c0537&amp;t=20">http://www.stockly.com/forums/showthrea ... c0537&amp;t=20</a><!-- m -->

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Sat Dec 08, 2007 6:25 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />OK. I have given this a thought. Effectively, i wasn't taking the easy path. Indeed, i don't need to study the relation of 1st round outputs with 2nd round inputs. Having only three rounds left, and knowing the output bits of the last round's sboxes, i should be able to exactly reconstruct the sboxes for the last round. Then, after having only 2 rounds left, it will be trivial to discover how the bits are grouped in the 2nd and 3rd rounds.
<br />
<br />So, by now, unless you have started it, don't do that test i asked above (the one with all the combinations of nibbles #0, #2, #4 and #7).
<br />
<br />I will try to put this in practice tomorrow or the monday, depending on real life circumstances.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Sun Dec 09, 2007 7:15 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I had already started it running, so while it sounds like it won't be of much use now, here it is in case you need it in the future:
<br /><!-- m --><a class="postlink" href="http://neviksti.com/blackbox/ID004D0_nibble0247.csv">http://neviksti.com/blackbox/ID004D0_nibble0247.csv</a><!-- m -->

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Sun Dec 09, 2007 11:05 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I have completed the attack against the fourth round; the sboxes i obtained with this method had a different look , but it was soon clear they were equivalent to the 2 we know (because they had the same "invariants"). After some work (and a lot of debugging <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /> ) i have discovered how to transform ones in the others.
<br />
<br />In the process, i have seen that i will better chose this other "equivant" sboxes instead of the previous 2:
<br />
<br />S0 =  {9,15,2,8,14,3,5,6,10,4,7,11,0,13,12,1};
<br />S1 = {14,8,9,7,4,11,2,13,3,15,0,12,10,1,5,6};
<br />
<br />(they are simply the previous ones with their outputs XORed with 9 and 14, respectively).
<br />
<br />That two s-boxes, besides the first round, are present in the fourth. To make the bit-order of the output match, i will redefine the order of the A-H output blocks for the fourth round i gave some posts above:
<br />
<br />    int new_blocks[8][4] = {
<br />        {19,6,15,20},
<br />        {3,10,21,24},
<br />        {23,7,1,13},
<br />        {2,26,31,8},
<br />        {9,30,4,17},
<br />        {29,12,18,5},
<br />        {22,14,0,25},
<br />        {27,11,28,16}
<br />    };
<br />
<br />Now, unless i have messed something up when recalculating these blocks, you can "undo" the last round by taking into account that these 8 blocks use, respectively, S1,S1,S1,S1,S0,S1,S1 and S1 as his corresponding s-boxes in the 4d0 case.
<br />
<br />Now it's time to research the blocks in the second and third round.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Sun Dec 09, 2007 6:20 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Wow! You are my hero.
<br />
<br />I'm not sure I follow all what you did here.  So to help me understand a bit more, I'd like to take a step back and look at what has happenned so far.  Many things were tried, but so far the successful path appears to be something like this:
<br />
<br />1] You did this: <em>i calculated the "mutual information" coefficients associated to the changes of every pair of output bits when changing a certain input bit (i did this using 4d0_counting and 4d0_high). In this way i obtained 32 tables 32*32 in size.</em>
<br />
<br />From which the 8 nibble groupings in the output were obtained, and these were assumed to be outputs of individual s-boxes.
<br />
<br />2] Then you did this: <em>After selecting one of the "nibbles", we take 0&lt;=A,B&lt;=15, construct a 16*16 table by doing this: for every pair A,B, calculate, for every block of output bits, the entropy of the joint distribution for those bits, use them to make a overall estimator (taking the arithmetic mean or, more probably, dropping the maximum and minimum values and promediating the medium ones) and putting that value in the table in the (A,B) position.</em> 
<br />
<br />To make sure, by "entropy of the joint distribution" do you mean this:
<br />H(x,y) = - Sum p(x,y) log_2 p(x,y)
<br />Where p(x,y) is the joint probability of x,y and the sum is over all pairs of values x and y can have.
<br />
<br />It sounded like there was a problem at one point with some p(x,y) being zero.  Or was it something else?  Was it just a code debugging issue, or did you need to slightly modify/extend the definition above in some way?
<br />
<br />
<br />I'm also not sure what the exact mechanics are here.  Is this correct?
<br />- choose an input block (a nibble)
<br />- choose an output block (the nibbles found in part one)
<br />- make a table(A,B) of the following:
<br />---- for any single value of all the other nibbles, see what the output block is when choosing A or B for the input block. these outputs are the x and y
<br />---- do this for all values of the other nibbles that we can, obtaining p(x,y) and hence H(x,y)
<br />
<br />- now repeat this for every output block, and average the tables to obtain one 16x16 table for each input block.
<br />
<br />- this gives information on the Hamming distance between the outputs of the s-box.  And thus the s-box can now be constructed (xor an unknown value at least).  The order of the bits is also unknown, but we can fix the order to whatever we want, and absorb this unknown permutation into the permutation between rounds.
<br />
<br />
<br />Is this correct so far?  Does it matter much how you choose to average the tables (did you just add them together)?
<br />
<br />Anyway, the result was you found there were only two kinds of s-boxes.
<br />
<br />3] The next step, it sounds like you applied the method from step 2 in reverse -- treating the output blocks as inputs now, and vice versa.
<br />
<br />I am probably misunderstanding here, as I doubt we have much data in which two outputs match except one nibble.  How did you do this?
<br />
<br />But regardless, you obtained the s-boxes for the last round.
<br />
<br />4] You then compared the s-boxes from the first and last round.  You mentioned: <em>it was soon clear they were equivalent to the 2 we know (because they had the same "invariants").</em>
<br />
<br />I'm not sure what you mean by this.  I'm also not sure what you mean by the topology of the s-box.
<br />
<br />After thinking about it some, my best guess is this:
<br />If we consider the operations which reorder the bits in an s-box (inputs and outputs with the same permutation) and also an xor operation with some constant (again on inputs and outputs), I'm not sure what would remain invariant.  Trying to visualize some kind of "topology" (I'm probably misusing that word), if we put the s-box in feedback (output becomes the next input) and iterate it, there would be some loops that would form.  The number and length of these loops should be invariant to permutation.  And now that I think of it, it would be invariant to the xor as well (right?).  Is that what you mean by invariants?
<br />
<br />It is not clear to me that, even if that property is invariant, that the property is also unique between different equivalent classes.  Is it?  Or did you just use it as an indication that they <em>might</em> be the same s-box and worked till you found how they were related?
<br />
<br />Anyway, it sounds like you eventually learned how to relate the s-boxes found from step 2 to those in step 4.
<br />
<br />5] I got a bit lost on step 3, but I really don't understand the next couple of comments:
<br />
<br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">To make the bit-order of the output match, i will redefine the order of the A-H output blocks for the fourth round i gave some posts above:<br /><br />    int new_blocks[8][4] = {<br />        {19,6,15,20},<br />        {3,10,21,24},<br />        {23,7,1,13},<br />        {2,26,31,8},<br />        {9,30,4,17},<br />        {29,12,18,5},<br />        {22,14,0,25},<br />        {27,11,28,16}<br />    };</div><br />I'm not really understanding what you matched up here.  You also commented:<br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">In the process, i have seen that i will better chose this other "equivant" sboxes instead of the previous 2:<br /><br />S0 =  {9,15,2,8,14,3,5,6,10,4,7,11,0,13,12,1};<br />S1 = {14,8,9,7,4,11,2,13,3,15,0,12,10,1,5,6};</div>
<br />
<br />Are you saying that by using the knowledge that the s-boxes of the first and last round could be written as the same set of s-boxes, that if you force this choice (make the s-boxes the same) that this fixes some previously unknown properties (of the permutations, or the absolute value of the s-boxes)?
<br />So what is and is not fixed now?
<br />
<br />
<br />I'm sorry for all the questions, but this is all very new to me and I find it fascinating.  I would love to learn more about it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Sun Dec 09, 2007 11:30 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I hooked up the old device so I could get some more ID00072 data.
<br />
<br /><!-- m --><a class="postlink" href="http://neviksti.com/blackbox/ID00072_high.csv">http://neviksti.com/blackbox/ID00072_high.csv</a><!-- m -->
<br />Hopefully that is enough to get the round 1 s-boxes for the high nibbles.  Then maybe I can use this knowledge to figure out how to determine which s-boxes are used from the current measurements, and I can them off for each round.  It may not be possible, but there is enough conditional code in there that it is worth a try.
<br />
<br />
<br />Anyway, I have to leave town tonight, so I won't be able to run anymore data for a few days (but I should still be able to communicate here).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Mon Dec 10, 2007 2:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I hooked up the old device so I could get some more ID00072 data.<br /></div><br /><br />Ummm, why for the high bits? I was expecting more data for the low ones (i was unable to obtain the low-bits sboxes for this one). Or do you think the high bits would be better to match with the measurements for whatever reason?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Anyway, I have to leave town tonight, so I won't be able to run anymore data for a few days (but I should still be able to communicate here).<br /></div><br /><br />Don't worry; i'm not expecting to need more data. <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To make sure, by "entropy of the joint distribution" do you mean this:<br />H(x,y) = - Sum p(x,y) log_2 p(x,y)<br /></div><br /><br />Yes, but the joint-distribution here has 4 variables (the four bits in the output blocks), so p=p(x1,x2,x3,x4).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">It sounded like there was a problem at one point with some p(x,y) being zero. Or was it something else? Was it just a code debugging issue, or did you need to slightly modify/extend the definition above in some way?<br /></div><br /><br />Just a code debugging issue.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">---- for any single value of all the other nibbles, see what the output block is when choosing A or B for the input block. these outputs are the x and y<br />---- do this for all values of the other nibbles that we can, obtaining p(x,y) and hence H(x,y)<br /></div><br />Not exactly. Effectively, we chose a couple of inputs with the input blocks A and B, but then, the entropy is calculated not over the pairs of values for the output block, but over the changes of that values (x XOR y) and, as before, this is a 4-variables joint-distribution (as the output block has 4 bits). The point here is that this latter data (the changes of the output values) is less dependent of the values for the other input blocks than the output values itself.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Is this correct so far? Does it matter much how you choose to average the tables (did you just add them together)?<br /></div><br />With the indications above, yes. As for averating the tables, i sorted the list of 8 entropies, dropped the 2 bigger and 2 smaller ones and promediated the other 4 values (that is to obtain a "robust" estimator, that is, to avoid the effect of very inusual values). I'm not sure if this improved this or not against a simple averating (as this work, i didn't do more with other estimator).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">3] The next step, it sounds like you applied the method from step 2 in reverse -- treating the output blocks as inputs now, and vice versa.<br /><br />I am probably misunderstanding here, as I doubt we have much data in which two outputs match except one nibble. How did you do this?<br /></div><br /><br />No, as you say, i didn't have data to apply the same method in the reverse direction. This attack was different, this is the idea: once i have "undo" the first round, i'm left with only three round, the input is not the input for the original second round. OK?<br /><br />Well, when you change only a bit in the input of the second round, you will get at most 4 changes as the input of the third round, and at most 16 changes as the input of the third round. As you have 32 bits of inputs for the fourth round, that means than at most only half the inputs bits of the fourth round will vary. Now consider a given fourth-round block; for every input bit we change, we expect that probably some bits will never vary, while some others will do. By example, let's suppose than by considering all inputs pairs for the second round with bit #0 different, the input #3 for the "A"  fourth round block doesn't vary, while all the other combinations are present. Of couse, if we chose a different pair of inputs , the bit #0 could change (because it also depends of the values of the other input bits, but the point is that we will never see a pair with differents inputs bit#0 for the 4th round block; they will be both 0 or both 1. Now, of couse, we don't know how are the inputs bits for the 4th round blocks, but, here is the crucial point, as that s-box is a permutation, we will obtain a equivalent separation in two blocks in the output of the fourth round (so that, by example, we will never observe a pair of values (7,14), meaning sbox's inputs for the outputs 7 and 14 differ in that bit. <br /><br />In this way, doing a table for all the [0,15] values, this will give you a separation of two sets of eight elements correponding to the outputs for the inputs with that "fixed bit" different (this is supposing there is only one bit affected in the input of the s-box; if there are two, you will obtain 4 sets of 4 elements each; if there are three, 8 sets of 2 elements each).<br /><br />Now, you obtain such a clean separation for every bit, so you have enough information to reconstruct the s-box (fixating some degrees of freedom as in the ones for the first round). I did this yesterday using the first 2^20 data for 4d0, so i get 20 such separations, but that is way more than needed; probably with 12 or less it can be done too.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I'm also not sure what you mean by the topology of the s-box.<br /></div><br />The way in which the outputs of a round are connected with the inputs of the next one.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The number and length of these loops should be invariant to permutation<br /></div><br />Yes, but that was not what i used. Let's see, i was interested in invariants under the supposition of 4 operations applied to the sbox: a permutation of the input bits, a permutation of the output bits, a XOR mask applied at the input bits, and a XOR mask applied to the output bits.<br />One possible one is this: calculate the frequency of the parity of the weight of of the outputs when you chose inputs with weight odd, and order them (both S1 and S2 show (4,4) here in this, so if i had obtaind, by example, (3,5) i would we facing a distinct one). Now, if you do the same but by masking out one bit of the output, chose the 4 pairs obtained in this way for the different bits masked and order lexicografically these pairs, you obtain another invariant. A bunch of other invariants can be obtained in this way by masking input and/or output bits).<br /><br />So i did this for the first sbox i isolated and i saw it showed the same invariants than S1, i was able then to find the xor_mask and permutations that convert one in the other by hand. After checking all was right, i created a small program to do that automatically for the other ones. That is how i knowed i had to XOR the 2 know s-boxes with 9 and 14 respectively.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">5] I got a bit lost on step 3, but I really don't understand the next couple of comments:<br /><br />Andreas Naive escribió:<br />To make the bit-order of the output match, i will redefine the order of the A-H output blocks for the fourth round i gave some posts above:<br /><br />int new_blocks[8][4] = {<br />{19,6,15,20},<br />{3,10,21,24},<br />{23,7,1,13},<br />{2,26,31,8},<br />{9,30,4,17},<br />{29,12,18,5},<br />{22,14,0,25},<br />{27,11,28,16}<br />};<br /></div><br /><br />Sorry, i should have explained this better. I mean that i have reordered the bits in every block so as to match the LSb to MSb order of the outputs of the sboxes as we have them defined (so, in the first block, by example, after taking the output of the sbox, you send LSb to the output bit #19, MSb to #20, and so on...).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Are you saying that by using the knowledge that the s-boxes of the first and last round could be written as the same set of s-boxes, that if you force this choice (make the s-boxes the same) that this fixes some previously unknown properties (of the permutations, or the absolute value of the s-boxes)?<br /></div><br /><br />Explained above.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So what is and is not fixed now?<br /></div><br />The xor mask applied to the outputs bit is now fixed. The order of the output bits is still arbitrary.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I'm sorry for all the questions, but this is all very new to me and I find it fascinating. I would love to learn more about it.<br /></div>
<br />Don't be afraid for asking. Over the years, i have come to the conclusion that communicating your ideas and mental processes to others is probably the most important thing when trying to become a successful team, more important even than the individual capabilities of the individual members. So i like to give and receive explanations when team-working. Feedback is always welcomed. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Mon Dec 10, 2007 3:00 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />OK. the output blocks for the third round have been unveiled. After isolating them, it seemed clear (again by studying invariants <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" /> ) that indeed the permutation that joined the output of the third round and the input of the fourth was the same that was joining the output of the fourth with the final output of the algorithm.
<br />
<br />To make them equal, i have had to fix another degrees of freedom; concretely, the order of the A-H groups have now changed (i won't continue referring them in that way due to that):
<br />
<br />This is the "natural" order:
<br />int blocks[8][4] = {
<br />{19,6,15,20},
<br />{3,10,21,24},
<br />{23,7,1,13},
<br />{2,26,31,8},
<br />{9,30,4,17},
<br />{29,12,18,5},
<br />{22,14,0,25},
<br />{27,11,28,16}
<br />};
<br />
<br />By "natural" i mean that if, in every round, you take the number that have come from the previous round (the "challenge" in the case of the first round), divide them in natural nibble boundaries, pass them by their corresponding s-boxes (depending of the subkeys) and send the outputs to the bits of the corresponding block above (so nibble #n uses blocks[n]), you obtain the input for the next round (the "response" in the case of the fourth round).
<br />
<br />Well, indeed i have only verify this for the third and fourth round, but i'm guessing that is going to be the right answer. <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Mon Dec 10, 2007 7:38 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I hooked up the old device so I could get some more ID00072 data.<br /></div><br /><br />Ummm, why for the high bits? I was expecting more data for the low ones (i was unable to obtain the low-bits sboxes for this one). Or do you think the high bits would be better to match with the measurements for whatever reason?</div><br />I thought I saw some distinct changes in the processing of the high nibbles, and wanted to compare to which of the two s-boxes were used.  On closer inspection, I'm not so sure anymore... this code appears to be riddled with conditional jumps, it is making things very difficult to follow with only one current measurement to go by.<br /><br /><br /><br />Also, thank you again for your explanations, they are very useful.<br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">One possible one is this: calculate the frequency of the parity of the weight of of the outputs when you chose inputs with weight odd, and order them (both S1 and S2 show (4,4) here in this, so if i had obtaind, by example, (3,5) i would we facing a distinct one). Now, if you do the same but by masking out one bit of the output, chose the 4 pairs obtained in this way for the different bits masked and order lexicografically these pairs, you obtain another invariant. A bunch of other invariants can be obtained in this way by masking input and/or output bits).</div><br />To make sure I understand, for the first example of an invariant you are saying something like this: consider all the inputs containing an odd number of bits set to 1.  Now look at the outputs obtained from these inputs, and count how many of those outputs have even or odd number of bits set to 1.  Take these two numbers obtained, and put them in increasing order.  This two number object is an invariant.<br /><br />I worked this out for S0,S1 to get a better feel for it, and it makes sense now that it is an invariant, but I never would have thought of that myself.<br /><br /><br />However, for the second invariant you list, I'm not sure what you mean. If I try to work it out for S0<br /><br />S0 odd parity inputs yield the following outputs<br />F=1111<br />2=0010<br />E=1110<br />6=0110<br />A=1010<br />B=1011<br />D=1101<br />C=1100<br /><br />Now I mask a bit in the output (let's try bit0), but I don't know what you mean by pairs.  5 of the numbers had bit0=0, while 3 had it =1, so I don't see what makes 4 pairs.  Can you explain this one a bit more to me?<br /><br /><br /><br />I think I understand the big picture a bit better now though.<br />So the idea is that we <em>know</em> the correct inputs for the s-boxes from round 1, and we <em>know</em> the correct outputs for the s-boxes from round 4, and therefore finding how the similar s-boxes are related and making them the same necesarily fixes the "xor value".  Or is that simplifying it too much (am I missing something important)?<br /><br /><br />Previously you wrote:<br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">int new_blocks[8][4] = {<br />{19,6,15,20},<br />{3,10,21,24},<br />{23,7,1,13},<br />{2,26,31,8},<br />{9,30,4,17},<br />{29,12,18,5},<br />{22,14,0,25},<br />{27,11,28,16}<br />};<br /></div><br />Now you wrote:<br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">To make them equal, i have had to fix another degrees of freedom; concretely, the order of the A-H groups have now changed (i won't continue referring them in that way due to that): <br /><br />This is the "natural" order: <br />int blocks[8][4] = { <br />{19,6,15,20}, <br />{3,10,21,24}, <br />{23,7,1,13}, <br />{2,26,31,8}, <br />{9,30,4,17}, <br />{29,12,18,5}, <br />{22,14,0,25}, <br />{27,11,28,16} <br />}; <br /></div>
<br />
<br />Which is exactly the same and not reordered at all.  Did you accidentally copy the old result, or is it just that you happenned to guess correctly the first time?
<br />
<br />
<br />Anyway, at this point it sounds like there is probably a fixed permutation each round, and each bit of a 32bit "key" selects between two s-boxes for each nibble.  I tried brute forcing ID004DC, and none worked.  So while my code may be wrong, I'm hoping that I'm just using the incorrect (old) permutation.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Tue Dec 11, 2007 2:04 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">F=1111<br />2=0010<br />E=1110<br />6=0110<br />A=1010<br />B=1011<br />D=1101<br />C=1100<br /><br />Now I mask a bit in the output (let's try bit0), but I don't know what you mean by pairs. 5 of the numbers had bit0=0, while 3 had it =1, so I don't see what makes 4 pairs. Can you explain this one a bit more to me? </div><br /><br />You are almost there, you have obtained a pair (3,5) for bit #0; now you can obtain other three pairs for bits #1 and #3; if you order those pairs, you have another invariant.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Which is exactly the same and not reordered at all. Did you accidentally copy the old result, or is it just that you happenned to guess correctly the first time? </div><br /><br />Ouch, i copied the old one. <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /> I will correct it this night.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Anyway, at this point it sounds like there is probably a fixed permutation each round, and each bit of a 32bit "key" selects between two s-boxes for each nibble. I tried brute forcing ID004DC, and none worked. So while my code may be wrong, I'm hoping that I'm just using the incorrect (old) permutation.</div><br /><br />Well, you obviously didn't use the good permutation <img src="./images/smilies/icon_wink.gif" alt=";)" title="Wink" /> ,  but there is still something more. I tried to brute force it yesterday just in the way you have done and failed too; after looking at it, it seems than, when undoing the third round, there is a problem with nibble #6. All the others work fine (using S0 and S1), but there is something strange with #6. At this point, i'm supposing that it could be due to 2 possibles causes: i have incorrectly fixed any degree of freedom somewhere, or there is something not contemplated in my model (by example, a XOR mask applied before the input of the algorithm or after the ouput). I will research the problem tonight by reconstructing the s-box that nibble seems to be using.<br /><br />EDITED:<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So the idea is that we know the correct inputs for the s-boxes from round 1, and we know the correct outputs for the s-boxes from round 4, and therefore finding how the similar s-boxes are related and making them the same necesarily fixes the "xor value". Or is that simplifying it too much (am I missing something important)? </div>
<br />
<br />No, that's the idea. Though i have to wait to research that problem mentioned above to see how that is affected

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Tue Dec 11, 2007 5:29 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">You are almost there, you have obtained a pair (3,5) for bit #0; now you can obtain other three pairs for bits #1 and #3; if you order those pairs, you have another invariant.</div><br />Oh, okay.  I misunderstood and thought I was supposed to make 4 pairs from those 8 values I listed.  I see now, I get one pair for each bit masked -- four pairs total.<br /><br />Again in hindsight it is clear that this is an invariant, but I would not have thought of it myself... I'm worried that this is an indication that I'm missing something.  How did you come across these invariants?  Is this something you read about, or have you worked with this stuff long enough that at this point what is invariant just seems obvious?<br /><br />The other thing I was wondering about is, how many of these invariants are necessary to absolutely identify two s-boxes as equivalent (and how many unique classes are there?)<br /><br />Let's see, there are 16! possible one-to-one s-boxes.  There are 4! permutations on input bits, and 2^4 possible xor values on input bits.  I can do that to the output bits as well.  So for a rough estimate, there are:<br />16! / (4! 4! 2^8 ) equivalent classes under these operations.<br />I know this can't be the exact number because if I start with the mapping 0--&gt;0, 1--&gt;1, etc. then any permutation on both inputs and outputs, or any xor on both, will yield the same map.  So I guess that number is a lower bound?<br /><br /><br /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">At this point, i'm supposing that it could be due to 2 possibles causes: i have incorrectly fixed any degree of freedom somewhere, or there is something not contemplated in my model (by example, a XOR mask applied before the input of the algorithm or after the ouput). I will research the problem tonight by reconstructing the s-box that nibble seems to be using.</div>
<br />I can't say anything for certainty as I only have one current measurement to go by, but in that measurement, something different happens at the beginning of the third round.  So maybe it looks like:
<br />
<br />input -&gt; round 1 -&gt; round 2 -&gt; xor (or add) something -&gt; round 3 -&gt; round 4 -&gt; output

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Tue Dec 11, 2007 5:59 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Again in hindsight it is clear that this is an invariant, but I would not have thought of it myself... I'm worried that this is an indication that I'm missing something. How did you come across these invariants? Is this something you read about, or have you worked with this stuff long enough that at this point what is invariant just seems obvious? </div><br /><br />I don't remember having read about this in any place, but i have the vague sensation of having worked in that line time ago. However, i see this ideas pretty natural: taking weights give you invariance against applying xor masks (EDITED: xor masks of even weight; you need to sort the results to have invariance with odd-weighted masks too); sorting the values give you invariance against bit reorderings. This is only a combination of simple ideas.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The other thing I was wondering about is, how many of these invariants are necessary to absolutely identify two s-boxes as equivalent (and how many unique classes are there?) </div><br /><br />Ummm, not sure, but my feel is that the 16 invariants you can take in that way completely determine the equivalence classes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So I guess that number is a lower bound? </div><br />Yes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">input -&gt; round 1 -&gt; round 2 -&gt; xor (or add) something -&gt; round 3 -&gt; round 4 -&gt; output</div><br /><br />I thought on it, but discarded that possibility as i hadn't noticed any strangeness after undoing the third round because the xor had canceled out when taking pairs (i checked the tables changes in input vs. changes in output); that's what i was wondering if could exist such thing at the beginning or end (that had fooled me when fixing the degrees of freedom). Whatever the case, reconstructing the table for that s-box is the way to go to exactly know what is happening there (at this point, i'm not expecting we will get a third sbox, so i guess i will discover what has happened by looking how to transform it in the corresponding "canonical" one).<br /><br />EDITED:<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I can't say anything for certainty as I only have one current measurement to go by, but in that measurement, something different happens at the beginning of the third round. </div>
<br />
<br />Ummm, thinking on it, maybe a P-box between the 2nd and 3rd round could explain that behaviour. Are you completely convinced than something different is done at the beginning of the third round?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>neviksti</b> [ Tue Dec 11, 2007 8:05 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Andreas Naive wrote:</div><div class="quotecontent">Ummm, thinking on it, maybe a P-box between the 2nd and 3rd round could explain that behaviour. Are you completely convinced than something different is done at the beginning of the third round?</div>
<br />The problem is that I only have one current measurement of the device calculating the response, and there appears to be conditional code everywhere.  So without more measurements (which I need to borrow a better oscilloscope to do), I can't say for sure <em>what</em> the conditional code is testing.
<br />
<br />So let me be as precise as possible.  I see the following...
<br />
<br />let's call one round:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">code block A<br /><br />code block B<br />then a bunch of conditional code I haven't been able to disentangle<br /><br />code block B<br />then &quot;conditional code&quot;<br /><br />code block B<br />then &quot;conditional code&quot;<br /><br />code block B<br />then &quot;conditional code&quot;<br /><br />code block C</div>
<br />I see that repeated 4 times.
<br />
<br />I cannot say for certain where the actual loop starts/ends as the setup code right before the loop may have some cycles at the end which have the same signature as the end of the looped code.  But here is the largest values they can be (largest contiguous matching current measurements before running into the next block):
<br />
<br />code block A = 34 instruction cycles
<br />code block B = 43 instruction cycles (all but the nineth occurrance of this match up to 52 cycles... this is why I say something appears to be different at the beginning of the third round)
<br />
<br />conditional code = varies greatly in length, ~ 260 +/- 60 cycles 
<br />For the same reason figuring out the exact cycle a loop occurs, figuring out the exact branching points are difficult, making tracing the code through this even harder.  It is probably futile until I can get at least a couple measurements of it doing other calculations.
<br />
<br />code block C = 48 instruction cycles, there is a one cycle gap between this and the start of block A of the next round.  This cycle matches in all rounds except the last ... so I believe this is just showing us the conditional jump at the end of the loop (and showing us exitting the loop after the last round).  For this reason, I am pretty confident I know the cycle where each round starts.  I have not been so lucky in finding the similar signature in the loop over the nibbles, so I can't be as sure where block A ends / block B starts -- but that doesn't have much importance at the moment.
<br />
<br />So, at least for this case, something special happens in the processing at the beginning of the third round.  Whether this is just something peculiar to this calculation (the other 15 block B's just happen to take that jump while the ninth block B did not), or whether this is significant, I cannot say without more measurements.
<br />
<br />
<br />EDIT:
<br />If the code processes the high nibbles first, then nibble #6 would be processed in the block that differs.  So maybe it is literally something special done with that high byte.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Andreas Naive</b> [ Tue Dec 11, 2007 8:40 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Thanks for the details. I have a better understanding on that now.
<br />
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">EDIT:<br />If the code processes the high nibbles first, then nibble #6 would be processed in the block that differs. So maybe it is literally something special done with that high byte.</div>
<br />
<br />Interesting. I will take it in mind.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>4</strong> of <strong>6</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>