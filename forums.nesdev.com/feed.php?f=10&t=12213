<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=10&amp;t=12213" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2015-01-06T22:56:47-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=10&amp;t=12213</id>
<entry>
<author><name><![CDATA[Tsutarja]]></name></author>
<updated>2015-01-06T22:56:47-07:00</updated>
<published>2015-01-06T22:56:47-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138811#p138811</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138811#p138811"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138811#p138811"><![CDATA[
Also, I noticed that you are reading each button individually and doing all the checks related to that button right after it. Better way is to update all buttons once per frame (all buttons at once) and then see if the desired buttons are pressed somewhere else.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">Joy1Read:<br /> LDA #$01              ; Latch controllers<br /> STA Joy1<br /> LDA #$00<br /> STA Joy1<br /> LDX #$08<br />Joy1Loop:<br /> PHA<br /> LDA Joy1<br /> AND #$03            ; AND off anything unnecessary<br /> CMP #$01            ; See if button was pressed (sets carry flag if it was)<br /> PLA<br /> ROR A                 ; Rotate right (puts carry flag to the leftmost bit whether it was set or not)<br /> DEX<br /> BNE Joy1Loop<br /> RTS<br /></div><br /><br />NOTE: <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">Joy1</tt> refers to the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">$4016</tt> register. You can set one by writing <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">Joy1 = $4016</tt> (or <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">PPUMask = $2001</tt> as another example) after the ines header but before the first <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">.bank</tt> (to the same area you define your variables in with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">.rsset</tt>).<br /><br />NOTE 2: Notice how I'm not storing the controller readings anywhere? That's because I store them outside this subroutine. It allows me to use this same subroutine to read the buttons again and compare the two readings to verify that the inputs were not corrupted by DMC sample (if used).<br /><br />Now, if you held down A and B you would have <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">%00000011</tt>. If you want to see if A button is pressed, you can do something like this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">CheckA:<br /> LDA joy1_reading<br /> AND #%00000001<br /> CMP #%00000001<br /> BNE ANotHeld<br /><br />; What you want to do if A is held<br /><br />ANotHeld:<br /><br />; Whatever happens in your code after this<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6724">Tsutarja</a> — Tue Jan 06, 2015 10:56 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Pokun]]></name></author>
<updated>2015-01-06T19:27:30-07:00</updated>
<published>2015-01-06T19:27:30-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138800#p138800</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138800#p138800"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138800#p138800"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />I would imagine that the majority of people who read tutorials in the English language have no easy access to a Famicom with which to test.<br /></div><br />It doesn't need to be tested since it's already well known to work (I can confirm it too). It's standard practice for commercial games to read both bits and recommended in the wiki, so there's really no reason to not include it when teaching this.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6013">Pokun</a> — Tue Jan 06, 2015 7:27 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Tsutarja]]></name></author>
<updated>2015-01-06T12:27:32-07:00</updated>
<published>2015-01-06T12:27:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138777#p138777</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138777#p138777"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138777#p138777"><![CDATA[
<div class="quotetitle">lazerbeat wrote:</div><div class="quotecontent"><br />1 - how do I make sprite movement continuous without the user constantly holding down a direction. I am guessing at BNE rather than BEQ while reading controllers but I cant work out how to implement it.<br /></div><br /><br />I would set a flag when the button is pressed. The object checks if the flag is set. If it is, the object moves as you want. The flag gets cleared when you want the object to stop, not when the button is released.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6724">Tsutarja</a> — Tue Jan 06, 2015 12:27 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2015-01-06T11:26:42-07:00</updated>
<published>2015-01-06T11:26:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138771#p138771</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138771#p138771"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138771#p138771"><![CDATA[
<div class="quotetitle">mikaelmoizt wrote:</div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"> <br />  LDA $0204       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  ADC #$02        ; A = A + 1<br />  STA $0204       ; save sprite X position<br /><br />(...) </div><br /></div><br /><br />I think the SEC is supposed to be CLC in this code snippet.<br /><br />I also recommend not going the route of hard coding sprite movement; the only sprite you should directly update is sprite #0 if you're doing any effects with it. Like tokumaru explained, developing an abstract &quot;game world&quot; where you have objects moving within it, and then updating the entire sprite page based on object positions is ideal in most cases.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Tue Jan 06, 2015 11:26 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mikaelmoizt]]></name></author>
<updated>2015-01-06T03:26:02-07:00</updated>
<published>2015-01-06T03:26:02-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138765#p138765</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138765#p138765"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138765#p138765"><![CDATA[
If you want <strong>just</strong> the sprites moving like you have done in your program without any form of interactivity, for whatever reason (why?) you could do something like moving parts like<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA $0200       ; load sprite Y position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$01        ; A = A + 1<br />  STA $0200       ; save sprite Y position<br /><br />  LDA $0204       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  ADC #$02        ; A = A + 1<br />  STA $0204       ; save sprite X position<br /><br />(...) </div><br /><br />into your nmi and cut everything related to controller reading. Are you by any chance using NESASM3 to assemble with? You have a 32k rom with first 16k block empty.<br /><br />EDIT: This method is not endorsed by me, but it is pretty much how to do what the OP is asking if I am not mistaken.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6478">mikaelmoizt</a> — Tue Jan 06, 2015 3:26 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2015-01-05T20:12:21-07:00</updated>
<published>2015-01-05T20:12:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138751#p138751</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138751#p138751"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138751#p138751"><![CDATA[
I would imagine that the majority of people who read tutorials in the English language have no easy access to a Famicom with which to test.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Jan 05, 2015 8:12 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Pokun]]></name></author>
<updated>2015-01-05T19:19:31-07:00</updated>
<published>2015-01-05T19:19:31-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138749#p138749</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138749#p138749"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138749#p138749"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />I can see that the tutorial you're using is doing something that's not recommended, which is taking action in the middle of reading the controller.<br /></div><br />It gets better later in the tutorial. Early on it just teaches to do things manually without looping and stuff which is a great way to teach how it works. But of course there things it never teaches how to do properly.<br /><br /><div class="quotetitle">lazerbeat wrote:</div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">LDA $4016       ; player 1 - A<br />AND #%00000001  ; only look at bit 0</div><br /></div><br />This is another bad code in the Nerdy Nights tutorial. I don't see why Nerdy Nights don't teach you to read both bit 0 and bit 1 in $4016 (and $4017 if two player). We don't need homebrewers that learn to make games that doesn't work with Famicom external controllers.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6013">Pokun</a> — Mon Jan 05, 2015 7:19 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2015-01-05T11:35:26-07:00</updated>
<published>2015-01-05T11:35:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138723#p138723</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138723#p138723"/>
<title type="html"><![CDATA[Re: Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138723#p138723"><![CDATA[
<div class="quotetitle">lazerbeat wrote:</div><div class="quotecontent"><br />1 - how do I make sprite movement continuous without the user constantly holding down a direction. I am guessing at BNE rather than BEQ while reading controllers but I cant work out how to implement it.<br /></div><br />It's a bit more complex than that. The basic idea behind an action game (as opposed to a puzzle game or a turn-based game) is that the game world is constantly updating, regardless of user input. To accomplish this, each object or group of objects has to have their own AI routine, which dictates their behavior. AI routines can take various factors into consideration when deciding what to do to the objects, including input from the controller, in the case of the player object.<br /><br />The program in the tutorial you're following is an oversimplification of what a game actually is, where certain sprites are hardcoded to controller input.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />2 - How do I make the sprites start moving from the moment the rom is started rather than waiting for user input?<br /></div><br />By implementing AI. You have to give your objects some rules they can follow. It doesn't have to be anything complex, but if you want your game objects to act on their own you have to make them capable of taking simple decisions, even if it's just &quot;keep moving right no matter what&quot;.<br /><br />To keep things simple for now, you could make a different AI routine (which you can JSR to and RTS from, to keep the code organized) for each object you have on screen, and call all the routines every frame. Inside the routines, just write whatever behavior you expect each object follow. If the object is supposed to move right forever, just add 1 to its X coordinate and you're done. If you want it to bounce up and down the screen, use a &quot;direction&quot; variable to control whether it's going up or down, move it in the current direction (add or subtract 1 from the Y coordinate based on the value &quot;direction&quot; variable) and switch directions whenever the sprite touches the top or the bottom of the screen (Y coordinate equals 0 or 232).<br /><br />You can keep one or more objects reacting to input, but you can take other factors of the game world into consideration if you want. In a platformer for example, characters are supposed to fall when there's no ground below them because of gravity. That is one movement that happens regardless of what buttons are pressed on the controller. The important thing is to think in terms of rules. What rules does each object follow? How does the environment affect its decisions? How do other objects affect its decisions? Once you have that figured out, you have to translate those rules into code. You will surely need to use many variables to define the state of the objects, because then you'll have to keep track of a lot more than just their coordinates, like direction, speed, health... all of that can affect how an object moves and what it does each frame.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I was assuming something like<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA $0200       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$01        ; A = A - 1<br />  STA $0200       ; save sprite X position</div><br /><br />Before reading controllers would do the trick but I couldn't work out where to put it!<br /></div><br />This is just the actual hardware sprite being moved, and could be the simplest form of AI where the object only does 1 thing (move left) no matter what.<br /><br />As for where to place it, I can see that the tutorial you're using is doing something that's not recommended, which is taking action in the middle of reading the controller. This is bad for a number of reason, the main one being it mixes game logic with hardware interfacing, which in the long run will make your code hell to maintain. Another bad reason is that may actually have actions that depend on more than one button being pressed (such as holding a button to run faster in SMB), and if you only have a big block of code for each button you can't do that.<br /><br />The correct thing to do would be to read all the controller bits and store them in a variable (coincidentally or not, the NES controller has 8 buttons, the same number of bits in a byte), which can be consulted later by any object that needs to know the state of the controller.<br /><br />So, the ideal thing to do would be to modify the controller reading to just save the status of all the buttons but doesn't make any decisions right away. After that, call all the object AI routines (where the sprite movement code should be) one by one. If they do need to peek at the controller status, great, the variable will be sitting there for them to read.<br /><br />I know that this will cause a lot of changes in your code, but I guess that's what happens when you try to turn tutorial code into something closer to a game. If you think this is too much, maybe it would be better to stick with the tutorial for now, and maybe it will come to a point where these changes feel more natural. Just keep in mind that AI is the answer to what you're looking for.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Mon Jan 05, 2015 11:35 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lazerbeat]]></name></author>
<updated>2015-01-05T08:12:16-07:00</updated>
<published>2015-01-05T08:12:16-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138716#p138716</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138716#p138716"/>
<title type="html"><![CDATA[Sprite movement without continuous user input.]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=12213&amp;p=138716#p138716"><![CDATA[
I am making a very very simple sprite movement program based on the Nerdy Night tutorial. and I am a bit stuck. I have 4 little bubble moving around the screen at different speeds when the user pressed up / down / left / right. I have 2 questions<br /><br />1 - how do I make sprite movement continuous without the user constantly holding down a direction. I am guessing at BNE rather than BEQ while reading controllers but I cant work out how to implement it.<br /><br />2 - How do I make the sprites start moving from the moment the rom is started rather than waiting for user input? I was assuming something like <br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  LDA $0200       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$01        ; A = A - 1<br />  STA $0200       ; save sprite X position</div><br /><br />Before reading controllers would do the trick but I couldn't work out where to put it!<br /><br />Here is the code I have for movement so far. I attached the .nes as well is anyone wanted to have a look at it.<br /><br />thanks everyone!<br /><br /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">LatchController:<br />  LDA #$01<br />  STA $4016<br />  LDA #$00<br />  STA $4016       ; tell both the controllers to latch buttons<br /><br /><br />ReadA: <br />  LDA $4016       ; player 1 - A<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadADone   ; branch to ReadADone if button is NOT pressed (0)<br />ReadADone:        ; handling this button is done<br />  <br /><br />ReadB: <br />  LDA $4016       ; player 1 - B<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadBDone   ; branch to ReadBDone if button is NOT pressed (0)<br />ReadBDone:        ; handling this button is done<br /><br /><br />Readselect: <br />  LDA $4016       ; player 1 - select<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadselectDone   ; branch to Readselect Done if button is NOT pressed (0)<br />ReadselectDone:        ; handling this button is done<br /><br />Readstart: <br />  LDA $4016       ; player 1 - select<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadstartDone   ; branch to Readstart Done if button is NOT pressed (0)<br />ReadstartDone:        ; handling this button is done<br /><br /><br />Readup: <br />  LDA $4016       ; player 1 - up<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadupDone  ; branch to Readup Done if button is NOT pressed (0)<br />                  ; add instructions here to do something when button IS pressed (1)<br />  LDA $0200       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$01        ; A = A - 1<br />  STA $0200       ; save sprite X position<br /><br />  LDA $0204       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$02        ; A = A - 1<br />  STA $0204       ; save sprite X position<br /><br />  LDA $0208       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$03        ; A = A - 1<br />  STA $0208       ; save sprite X position<br /><br />  LDA $020C       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$04        ; A = A - 1<br />  STA $020C       ; save sprite X position<br />ReadupDone:        ; handling this button is done<br /><br /><br />Readdown: <br />  LDA $4016       ; player 1 + down<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReaddownDone   ; branch to Readdown Done if button is NOT pressed (0)<br />                  ; add instructions here to do something when button IS pressed (1)<br />  LDA $0200       ; load sprite Y position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$01        ; A = A + 1<br />  STA $0200       ; save sprite Y position<br /><br />  LDA $0204       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  ADC #$02        ; A = A + 1<br />  STA $0204       ; save sprite X position<br /><br />  LDA $0208       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  ADC #$03        ; A = A + 1<br />  STA $0208       ; save sprite X position<br /><br />  LDA $020C       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  ADC #$04        ; A = A + 1<br />  STA $020C       ; save sprite X position<br />ReaddownDone:        ; handling this button is done<br /><br /><br /><br />Readleft: <br />  LDA $4016       ; player 1 - select<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadleftDone   ; branch to Readleft Done if button is NOT pressed (0)<br />                  ; add instructions here to do something when button IS pressed (1)<br />  LDA $0203       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$01        ; A = A - 1<br />  STA $0203       ; save sprite X position<br /><br />  LDA $0207       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$02        ; A = A - 1<br />  STA $0207       ; save sprite X position<br /><br />  LDA $020B       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$03        ; A = A - 1<br />  STA $020B       ; save sprite X position<br /><br />  LDA $020F       ; load sprite X position<br />  SEC             ; make sure the carry flag is clear<br />  SBC #$04        ; A = A - 1<br />  STA $020F       ; save sprite X position<br />ReadleftDone:        ; handling this button is done<br /><br /><br />Readright: <br />  LDA $4016       ; player 1 - select<br />  AND #%00000001  ; only look at bit 0<br />  BEQ ReadrightDone   ; branch to Readright Done if button is NOT pressed (0)<br />                  ; add instructions here to do something when button IS pressed (1)<br />  LDA $0203       ; load sprite X position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$01        ; A = A + 1<br />  STA $0203       ; save sprite X position<br /><br />  LDA $0207       ; load sprite X position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$02        ; A = A + 1<br />  STA $0207       ; save sprite X position<br /><br />  LDA $020b       ; load sprite X position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$03        ; A = A + 1<br />  STA $020b       ; save sprite X position<br /><br />  LDA $020f       ; load sprite X position<br />  CLC             ; make sure the carry flag is clear<br />  ADC #$04        ; A = A + 1<br />  STA $020f       ; save sprite X position<br />ReadrightDone:        ; handling this button is done</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=6063">lazerbeat</a> — Mon Jan 05, 2015 8:12 am</p><hr />
]]></content>
</entry>
</feed>