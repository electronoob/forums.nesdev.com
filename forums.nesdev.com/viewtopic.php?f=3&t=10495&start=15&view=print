<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10495">http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10495</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Tue Sep 17, 2013 9:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Joe wrote:</div><div class="quotecontent"><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent">Also, I may be wrong since I've never used 65816, but I would bet the 8086 spanks it when it comes to block moves and string operations using rep prefixes.</div>Block moves are pretty fast, but <a href="http://trixter.oldskool.org/2013/01/18/optimizing-for-the-8088-and-8086-cpu-part-3-a-case-study-in-speed/" class="postlink">decompressing RLE is faster</a>. <img src="./images/smilies/icon_lol.gif" alt=":lol:" title="Laughing" /> (Scroll down to the &quot;results&quot; section.)</div><br /><br />That number looks bad, but Trixter is measuring an RLE bitmap RE-compressed with LZ4 and PK, and then decompresing that! <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /> It would be awful slow on any CPU really.<br /><br />Decompressing a true RLE sequence directly would be <em><strong>lightning</strong></em> on an 8086. For each byte run, put the byte value in AL and the run length in CX, then issue a REP STOSB operation. Very, very fast. If it's an even-length sequence you could even have the value in both AH and AL, shift CX right by one and issue a REP STOSW instead. It then can write two bytes in the same number of clock cycles. Come to think of it, you can do it with odd-length sequences too as long as you check the carry flag after the right shift and add a single byte extra into the output when it's set, after the REP STOSW.<br /><br />Consider this code. Assume the byte value is in AL, and the run length is in CX:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">mov ah, al<br />shr cx, 1<br />rep stosw<br />jnc done<br />stosb<br />done:<br /></div><br /><br />The 8086 can be very efficient for a lot of workloads.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>3gengames</b> [ Tue Sep 17, 2013 10:10 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />But when you factor in the HORRID cycle-per-cycle performance compared, is it really faster at all? Not really.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Tue Sep 17, 2013 10:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I think if running at the same clock speeds, it would depend on the workload. In a lot of cases, no probably not. In others (say RLE decompression) I think it can, especially when 16-bit memory operations are in heavy use. It would actually be pretty interesting to see numbers. Can anybody write a good, optimized equivalent of the code I gave for the 65816? Then we can check some timing tables and do the math. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />Other workloads would be fun to check out too, no doubt there are cases where the 65816 would win... it wouldn't fare too well against the 8086 for division or multiplication, heh. Again though, I've never coded 65816 so these are my guesses. I'm just going by what I've read on it. I could be proven wrong.<br /><br />(Remember, I'm talking 8086 here.. not 8088! The 8088 just sucks.)<br /><br />The 8086 may take more cycles to read opcodes and fetch memory data, but it has some more complex instructions that can be taken advantage of in some situations that can take care of things all at once where the 65xxx needs multiple instructions. My guess is on average, things may work out around the same. I didn't go into this trying to say x86 is a clock-per-clock monster, just was arguing that writing in it's assembly code isn't too bad.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Tue Sep 17, 2013 10:34 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Is <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> even used today?  Most things I see use MMX extensions or SSE or higher, since they tend to operate on 64 (or is it 128?)-bit values and thus can push data around faster.  Hell if I know, once the extensions started coming in is where I jumped ship (and am glad I did so).<br /><br />Regarding the equivalent on the 65816: you're thinking of <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> (for &quot;big chunks of data&quot;) or <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">pei / pea</tt> (stack-based) for copying data around.  No, these are not particularly fast, but as with everything in computing, it's conditional -- particularly how much data you're moving, from and where to, and so on.  In many cases <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> are slower than writing the loop yourself, but there are cases where they're faster.  Have I ever used these opcodes in real-world stuff?  <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">pei / pea</tt> yes, <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> no (manual loops in the code I was writing were faster the easy majority of the time).  This was back when I was <a href="http://www.ninjaforce.com/html/special_demoscene_dexmas.html" class="postlink">part of a demo and utility group</a>.<br /><br />Moving tons of data around is not particularly what any member of the 65xxx family is designed for.  The processor was not designed for this kind of task, because during the era it was designed in, copying craploads of data around was not commonplace; in many cases a program designed with that method in mind was considered sloppy or badly-designed by the programmer.  Yes every situation is different, yadda yadda, so please (I'm looking at you Tepples) don't get nitpicky over what I say.  Any old 65xxx programmer knows what I say is true/fair in this regard.  Usually this was rectified by using a DMA chip of sorts (hint: PCs had these too you know).<br /><br />And for what it's worth, native x86 (meaning without extensions) is not particularly impressive either in this regard.  Yes, 386 and above have instructions that can iterate or repeat something on a series of bytes, often useful for things like Pascal-style strings (where you know the length in advance) or C-style strings (if you know the length ahead of time), but they're &quot;generic&quot; operations -- meaning they're not intended for strings specifically, for example.<br /><br />For things like string manipulation, go look at some of IBM's mainframe processors like the IBM 360/370 -- the bloody thing <a href="http://en.wikibooks.org/wiki/360_Assembly/360_Instructions" class="postlink">has an opcode</a> called <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">CUUTF</tt> which converts a string somewhere from Unicode (this would mean UTF-16 I believe) to UTF-8, amongst other things.<br /><br />If you want to split hairs and compare x86 cycle counts to 65816 cycle counts, please do -- I used to do this all the time back in the very early 90s while developing stuff for both my IIGS as well as my PC -- and in a lot of cases the 65816 cycle-count-wise blew the x86 out of the water.  But some iterative operations the x86 performed better.  After I went pure PC I stopped caring, but x86 opcodes like <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">imul / idiv</tt> were a dream come true to a 65xxx person.<br /><br />I also can't really stand x86 assembly because of it's variable-length opcodes (meaning they're not all 3 characters in length); code just gets ugly and hard to read.  Didn't like 68K for the same reason.  I know that's a trivial argument, but for me, it was always a pain in the ass to read x86 because of this.  Don't tell me &quot;so just indent/add spaces so it looks good&quot; -- maybe for code you're writing, but for disassemblers or any kind of real-time work, nope, nobody cares.  Just dump a bunch of text at you, enjoy parsing it with your eyeballs.  And don't even get me started about Intel vs. AT&amp;T syntax (FYI: I <strong>hate</strong> AT&amp;T syntax, utter backwards nonsense).  We had none of this syntactical-difference nonsense on the 65xxx (nor the 68K from what I understand).<br /><br />But -- none of this really matters now because the 65xxx series at this point is no longer a mainstream processor.  So really we're just bitching/crying over shit that doesn't matter at the end of the day.  *makes jacking-off motions*  :-)  I have no experience with ARM so I don't know how it compares, but it's at least a contender against x86, so that might make a more fair present-day comparison.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Tue Sep 17, 2013 10:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah, but we (or at least I) were talking about 65816 and 8086, not modern x86 with a 65816. It's not that big a deal to me either. I'm not going to go cry myself to sleep if we don't count clock ticks. 3gengames just brought up cycle timing and I thought it would be interesting. I'm not nerd-raging or anything here. BTW, when you say &quot;386 and above have instructions that can iterate or repeat something on a series of bytes&quot; ... if you were talking about REP STOSW, etc. that was actually present in the original 8086.<br /><br />Maybe none of this DOES matter at the end of the day either, but hey this is a NES emudev forum. We talk about nothing but ancient technology so it fits right in. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />EDIT: Wow, this thread got off-topic... mostly my fault.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Tue Sep 17, 2013 11:02 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I didn't spend much time with the original 8086 or 8088.  The first x86 CPU I began programming for was the 386, where I spent 90% of my time pissing and moaning about the segmented memory model.  It wasn't I was introduced to protected mode and DOS extenders that I really started &quot;enjoying&quot; x86 due to the linear memory model and 32-bit registers with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">int 10h</tt> hooks (dos32 extender FTW!).<br /><br />Proof of this fact is you correcting me -- specifically that the REP(etition) prefix on STOxx ops were available dating back to the original 8086.  See, I just assumed they were introduced with the 386, because every programmer I worked with at the time was like &quot;ugh no you don't want to use 286 or 8086 and especially not 8088&quot;, so I never bothered.<br /><br />I can do the cycle counting for your loop (65816 vs. 8086) tomorrow, or maybe one the non-US folks on the forum can do so in the interim.<br /><br />The code you pasted is kind of half-ass anyway.  No offence, I'll explain:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">mov ah, al<br />shr cx, 1<br />rep stosw<br />jnc done<br />stosb<br />done:<br /></div><br /><br /><ul><li>I don't see what the point of the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov</tt> is here, other than to initialise AH from whatever AL is.  Why not just <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov ax,1234h</tt> or something literal?</li><li><tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> stores the 16-bit contents of AX at [ES:DI], but there's no setting of ES nor DI anywhere.  It matters if we're comparing cycles, since setting ES and DI should be included in the total number of cycles.  If you feel this doesn't matter, no problem -- then really all we need to compare is the cycle count of <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> followed by a <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosb</tt>.  Which leads me to...</li><li><tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> repeats the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> operation CX number of times, decrementing DI by 2 every iteration.  But <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">shr cx, 1</tt> shifts-right the CX register by 1, i.e. divides whatever CX is by 2 (65xxx equivalent is <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">lsr</tt>).  We don't know what CX is initially so the number of times the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> runs is undefined.  It matters because as I said earlier, sometimes mvn/mvp can be faster than manual loops.</li><li>I can't find docs quickly that say anything about what the state of the carry is with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stoXX</tt>, so I don't know what the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">jnc</tt> does; is it to help handle even vs. odd counts of data moves?  That's all I can think of</li></ul>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Tue Sep 17, 2013 11:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">koitsu wrote:</div><div class="quotecontent"><div class="codetitle"><b>Code:</b></div><div class="codecontent">mov ah, al<br />shr cx, 1<br />rep stosw<br />jnc done<br />stosb<br />done:<br /></div><br /><br /><ul><li>I don't see what the point of the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov</tt> is here, other than to initialise AH from whatever AL is.  Why not just <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov ax,1234h</tt> or something literal?</li><li><tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> stores the 16-bit contents of AX at [ES:DI], but there's no setting of ES nor DI anywhere.  It matters if we're comparing cycles, since setting ES and DI should be included in the total number of cycles.  If you feel this doesn't matter, no problem -- then really all we need to compare is the cycle count of <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> followed by a <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosb</tt>.  Which leads me to...</li><li><tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> repeats the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> operation CX number of times, decrementing DI by 2 every iteration.  But <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">shr cx, 1</tt> shifts-right the CX register by 1, i.e. divides whatever CX is by 2 (65xxx equivalent is <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">lsr</tt>).  We don't know what CX is initially so the number of times the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">rep stosw</tt> runs is undefined.  It matters because as I said earlier, sometimes mvn/mvp can be faster than manual loops.</li><li>I can't find docs quickly that say anything about what the state of the carry is with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stoXX</tt>, so I don't know what the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">jnc</tt> does; is it to help handle even vs. odd counts of data moves?  That's all I can think of</li></ul></div><br /><br />It's half-ass because it's not a whole program. Of course CX, ES:DI need to be set. I was only trying to show joe the meat of it, but that was before I suggested cycle counting so I didn't write an entire program. BTW, I really don't care if we count cycles. It was just a thought. I wasn't clear though, I know. I was imagining an arbitrary RLE compressed data stream to just look like this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">XY XY XY XY ............ &lt;end of file&gt;</div><br /><br />Where in each XY pair, X = byte value of run, Y = length of run. Like I said in that post, the byte value goes (X) into AL and then the run length (Y) goes into CX. I would have copied AL into AH just because it wouldn't have made sense to duplicate a byte in the stream itself for no reason if you're attempting to compress something. Then shift CX right by one since we're writing the output run two bytes at a time. If the run we decompressed was even in length, carry is now clear after the shift and we're done... otherwise if it was set, the run length was odd so we need to append that remaining byte to the end with the single STOSB.<br /><br />I did explain in the original post what AL and CX are going into it, but not what I was imagining as an input stream.<br /><br />Also, the STOxx ops don't affect flags. STOSW is equivalent in function to: MOV ES:[DI], AX ... but then after that yes if the direction flag is set it decrements SI by 2... or increments by 2 if the flag is clear. (which of course it should be for decompressing this. it can be forced with a CLD at the start of the program.)<br /><br /><br /><br />JNC is Jump when Not Carry.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Wed Sep 18, 2013 12:34 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Found a <a href="http://www.mathemainzel.info/files/x86asmref.html" class="postlink">better opcode list</a> (thank you people who actually document how opcodes affect CPU flags, sheesh).  So:<br /><br />* The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mov ah,al</tt> now make sense because you're essentially just wanting to fill memory with a value (16 bits at a time).  Got it.<br /><br />* The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">jnc done</tt> is indeed to deal with even/odd number of bytes, and in the case of an odd number, to store the last byte (since <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">stosw</tt> copies 16 bits at a time).  The carry being set or clear comes from the preceding <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">shr cx, 1</tt>.  So okay, got it.  Easy enough to do in 65816, but again the length (number in CX) actually matters because of the whole mvn/mvp vs. manual loop situation.<br /><br />For shits and giggles lets just say we're trying to fill 513 bytes of data (an odd number) with the value $ffff, but only a byte is specified ($ff).  Cycle counts per opcode are in brackets (<tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">[]</tt>).<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; sep #$30&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; Set A/X/Y to 8-bit size <br />&nbsp; lda #$ff&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;2&#93; $ff = upper and lower half of the 16-bit value we want to fill<br />&nbsp; tay&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; Copy A ($ff) into Y<br />&nbsp; xba&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;3&#93; Swap upper and lower bytes of A (yes you can do this when A size is 8-bit!)<br />&nbsp; tya&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; Copy Y ($ff) into lower byte of A; 16-bit A now contains $ffff<br />&nbsp; rep #$30&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; Set A/X/Y to 16-bit size<br />&nbsp; tay&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; Y=$ffff<br />&nbsp; lda #513&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; 513 bytes to transfer (odd number)<br />&nbsp; lsr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; Divide by 2, A will now contain 256 ($100) with carry set to 1<br />&nbsp; bcs OddNum&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;!&#93; If carry set, then lsr had a leftover (i.e. odd number)<br />&nbsp; tax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; X = number of words (16-bits) to write<br />&nbsp; tya&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; A=$ffff<br />- sta &gt;ESDILocation,x&nbsp; ; &#91;6&#93; Write $ffff to ESDILocation+X offset (full 24-bit address) -- LOOP<br />&nbsp; dex&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; ...repeat -- LOOP<br />&nbsp; bne -&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;!&#93; ....until X=0 -- LOOP<br />&nbsp; sep #$30&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; Set A/X/Y to 8-bit<br />&nbsp; bra Done&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; GTFO<br />OddNum:<br />&nbsp; tax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; X = number of words (16-bits) to write<br />&nbsp; tya&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; A=$ffff<br />- sta &gt;ESDILocation,x&nbsp; ; &#91;6&#93; Write $ffff to ESDILocation+X offset (full 24-bit address) -- LOOP<br />&nbsp; dex&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;2&#93; ...repeat -- LOOP<br />&nbsp; bne -&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &#91;!&#93; ....until X=0 -- LOOP<br />&nbsp; sep #$30&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &#91;3&#93; Set A/X/Y to 8-bit -- LOOP<br />&nbsp; sta &gt;ESDILocation&nbsp; &nbsp; ; &#91;6&#93; Write that odd byte ($ff) to ESDILocation (same as ESDILocation,x in this case) -- LOOP<br />Done:<br /></div><br /><br />The cycle count labelled <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">[!]</tt> is 2 cycles if the branch IS NOT taken, otherwise is 3 cycles.  In most cases in the above code, it will be taken.<br /><br />Is this optimised?  No.  More on that in a moment.<br /><br />Is it ugly and long?  Yes, because most of the work stems from the &quot;setup&quot; -- first the need to take an 8-bit accumulator value and copy the value into the high byte of the accumulator, and then dealing with the number of bytes and so on.  If I had made this in a &quot;general subroutine&quot; where you'd simply push the byte you wanted filled onto the stack, followed by another push of the length (in bytes), the routine would be a lot shorter and maybe use less cycles.  Not sure.<br /><br />The reason the code looks doubled (more or less) is because I did not care to elegantly handle the situation where the number of bytes being transferred was odd vs. even (i.e. storing something in a temporary variable to indicate such, etc.).  My focus was not on code length but a bit more on cycles.  It's totally possible to make this routine shorter and handle the odd vs. even thing in a more sane manner.<br /><br /><span style="font-size: 150%; line-height: normal"><strong>ANYWAY...  ;-)</strong></span><br /><br />The most important part here is the cycle counts within the loops (I've labelled them with <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">-- LOOP</tt>, including the odd-byte count where the sep #$30 is actually needed (to write an 8-bit value vs. 16-bit) and the actual write itself).<br /><br />So let's do the math of the loops, given the number of iterations within the loops that we know:<br /><br />513 bytes = $100 (256) loop iterations + 9 extra cycles (sep + sta at the end)<br /><br />Loop itself: 6 cycles for the sta + 2 cycles for the dex + 3 cycles for the bne (except the last iteration which will be 2 cycles)<br /><br />So: 255 * (6 + 2 + 3) = 2805 cycles<br />2805 cycles + 2 cycles for the non-branch-taken bne = 2807 cycles<br />2807 cycles + the 9 extra cycles (sep + sta at the end) = 2816 cycles<br /><br />To repeat: is it possible to optimise this routine?  Absolutely.  Getting rid of the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta &gt;ESDILocation,x</tt> (24-bit addressing, STA Absolute Long Indexed X) and turning it into <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta ESDILocation,x</tt> (16-bit addressing, STA Absolute Indexed X) is the best choice, since you save 1 cycle per every <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">sta</tt> in that case.  The catch is that you have to know in advance what the bank of the 24-bit address ESDILocation is, and that's doable in lots of ways (again: how a programmer chooses to design things).<br /><br />The reason I chose to use a 24-bit addressing STA is because [ES:DI] -- it's been a while, so if I get this wrong, I apologise -- allows you to write to any segment (ES) starting at offset DI, up to 65536 bytes.  I wanted to make this &quot;easy&quot;, so I just went with a linear 24-bit addressing store.  More realistically though, as I said, setting B (bank) to the destination followed by a 16-bit store would save a cycle per every loop iteration, and is &quot;more akin&quot; to the segmented memory model (hard to explain what I mean by this, sorry, it's late and I'm tired (see below)) in this way, along with the &quot;up to 65536 byte&quot; limitation too.<br /><br />Another optimisation possibility is to do self-modifying code.  I'm not sure how much time this would save so this is speculative.  I've written such code, but I really don't enjoy it and try to stay away from it on the 65816.  On 6502, with only 64K of addressing space (and often even less RAM and ROM) it's more common.<br /><br />There is also the possibility of using a stack-based copying method, which may save other cycles.  I will admit it has been a long time since I've used <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">pea/pei</tt> to do this, so my familiarity there is a bit rusty, but I'm sure I could figure it out.  Note: I used this methodology in the aforementioned link (re: demo/utility group) to do some text scrolling.  There's a point where the stack-based method is faster than the manual loop.<br /><br />So I imagine it is very possible to get the cycle count down to the low-2000s for the same number of bytes (words) transferred.<br /><br />Now let's bring <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> into the picture (rather than a manual loop), but speaking on a general level because I took diphenhydramine and melatonin earlier and I'm really getting dozy (plus angry that I've spent time doing this rather than reading my awesome scifi book in comfy bed, but hey that's my own fault not anyone elses):<br /><br />The <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">mvn / mvp</tt> opcodes take a whopping <strong>7 cycles <span style="text-decoration: underline">PER BYTE</span> moved</strong>.  Not per word (16-bit), but per byte.  The CPU does the move itself (entire CPU blocks/waits until the opcode is done, obviously).  Whether it operates internally on a per-byte basis or per-word, I do not know, but I bet you it's per-byte given the nature of how it works.  Yeah, it's expensive.<br /><br />I hope someone else here (probably byuu) comes along and says &quot;holy shit dude, that routine is crap, you are REALLY out of practise&quot; and optimises the hell out of it.  That's how the guys at MIT did things on the old PDPs -- they would literally revamp or optimise each other's code to shave off cycles or bytes here and there.  Hell, Bill Gates did this too.<br /><br />Now you see why a little inexpensive DMA chip alongside the 65816 for memory transfers really, really helps.<br /><br />P.S. -- Despite my sort of annoyed/irritated tone (just how I am, nothing personal), this is probably the most thorough 65816 I've done since working on the SNES/SFC many years ago and my days in the IIGS scene.  <strong>BIG</strong> nostalgia for me here.  Really brought back memories -- especially since my IIGS is sitting in a storage bin behind me.  I also had to bust out ActiveGS (didn't have KEGS laying around) to run the IIGS mini-assembler (<tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">call -151 ; !</tt>) to write some code to test some of my theories about certain opcodes behaving certain ways in 8-bit vs. 16-bit mode.  So thank you, miker00lz, for the trip back in time.  I do appreciate it.<br /><br />P.P.S. -- I edited the initial code at the start to remove use of a temporary DP variable because I realised I could safely use other registers for it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Wed Sep 18, 2013 1:21 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent"><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent"><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent">Writing your first CPU emulator is one hell of a learning experience for sure. My first was the 8086. That was.... taxing.</div><br /><br />Haha I have to give it to you, you've got some guts to do that as your first emulator. I think I would've thrown away my laptop and lived in the woods after becoming permanently paranoid if I had to do that with the knowledge I had prior to making the 6502. Even now, I think the 8086 would be a major, several-month challenge to me that would have a pretty big chance of failure to be honest. I do, however, plan to emulate one at some point. The NES is just a start in my journey (hopefully) <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /></div><br /><br />Well, if you can do the 6502 you can definitely do the 8086. The most confusing thing on the 8086 is understanding the addressing mode byte (aka mod/reg/rm byte)... once you get that it's really not much harder. There are more opcodes and more addressing modes, so it will take more time. There are also &quot;group&quot; opcodes where the first instruction byte indicates which group, then it has a modregrm byte where one of it's fields indicates the exact operation. It can get pretty weird. Oh and there are segments to worry about too, but that's not so bad. Yeah, it DID take a few months before I was able to boot DOS.<br /><br />If you get around to doing it, let me know if you want a little help. Once you understand the couple confusing aspects, it does become about as easy as the 6502. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div><br /><br />The thing that scares me about the 8086 is the huge and more complex x86 architecture. The few dozen 6502 opcodes compared to a washing list of instructions seems like hell to me, and all the terminology you're using while arguing with the other guys is like a foreign language. I had literally no experience with lower level stuff like I mentioned before, so to get to the point of knowledge you guys have would take me many years, and that's how long I'm guessing it would take me to get an 8086 running, let alone have it run DOS (which is actually a long-term goal I have for emulation). Another thing, doesn't the 8086 have an FPU? I can only assume that for the mathematical dimwits like myself, it's a hell to implement. Of course, I'm assuming this, maybe the FPU isn't hard at all to implement. <br /><br />Another thing would be the graphics. If I actually wanted to RUN DOS like DosBox does (running actual games as well), I'd have to implement some kind of complex graphics card (relative to the NES or SNES). Did you manage to do that too?<br /><br />PS: I will definitely take you up on that. The moment I start on an 8086 is the moment you might receive 200 messages a day of me flipping out because I can't get another opcode right. Watch your spambox my friend.<br /><br />PPS: Just kidding, but seriously, if I ever get started on that I might ask you some questions if that's ok <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Wed Sep 18, 2013 1:51 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent">Another thing, doesn't the 8086 have an FPU? I can only assume that for the mathematical dimwits like myself, it's a hell to implement. Of course, I'm assuming this, maybe the FPU isn't hard at all to implement.</div><br /><!-- m --><a class="postlink" href="http://en.wikipedia.org/wiki/Intel_8086#Floating_point">http://en.wikipedia.org/wiki/Intel_8086#Floating_point</a><!-- m --><br /><br />TL;DR -- 8086 has support for an FPU add-on chip (mainboards would have sockets for it), usually the Intel 8087 (but some others made their own), which you'd buy, plug in, and <a href="http://www.csee.umbc.edu/courses/undergraduate/CMSC313/fall07/burt/CMSC313_lectures/Floating%20Point/floatingPoint.html" class="postlink">get a bunch more opcodes and FPU-specific registers</a>.  I imagine emulating this really isn't that bad, considering that any present-day language you'd use (C, etc.) could &quot;emulate&quot; this using standard mathematical operations within the programming language itself, along with some limitations you'd have to write in/code in yourself.  I wouldn't imagine it'd be all that bad.<br /><br />Just reviewing that page, particularly all the <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">qword ptr [edi+ebx]</tt> crap, is just further stuff that makes me hate x86.  It's so easy to get lost in the syntax and &quot;addon words&quot; to the assembly language portion.  I swear, when/when not to use things like <tt style="margin-left: 2px; margin-right: 2px; padding:3px; background-color: #3355aa; color: white;">dword ptr</tt> and brackets for certain addressing modes/methods, was such a pain in the ass.  I remember doing 320x200 graphics (segment A000 (or A0000 in protected mode)) and was saying things like &quot;Why the hell do I have to use brackets here?  I don't get it, I'm not wanting indirect addressing... or am I?  GRAAAHHHH!!!&quot; and &quot;Why can't I just hard-code the value of the address I want to use in the instruction?  Why must I use a register?&quot;<br /><br />Sorry, 65xxx just makes all this stuff really bloody obvious when you look at it.  Not to a newbie, no, but there's a lot LESS to grasp overall.  I find the syntax to be easier to understand.  Friends of mine who have tried repeatedly to learn 65xxx (I think 6502 in particular) but fail, for example, have no problem learning LISP.  This still baffles my mind to no end, from a syntactical standpoint anyway.  It's one of those things where if I could sit down with them for a week and step them through basic assembly programming I think they'd understand it, but languages that add tons of crap on top -- or abstraction of any sort -- make it harder for the person to actually know what's going on under the hood.  Off-topic big time, but this is exactly why I loathe things like Java.  Too many layers of crap that can go wrong between you and the CPU.  :-)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>miker00lz</b> [ Wed Sep 18, 2013 1:54 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />koitsu - I'm dead tired and typing this from my laptop in bed, but good work. That was fast. I'll check it out in more detail tomorrow.<br /><br />ArsonIzer - Nope, the 8086 on it's own has no FPU at all fortunately. What you're thinking of is the 8087 co-processor (edit: koitsu beat me to it) which is required by virtually no software out there. I don't really understand the FPU stuff in detail either. As for graphics, emulating CGA and 320x200 256-color MCGA is dead simple to emulate compared to the NES. Not even close, really. They're simple bitmaps (CGA is interlaced, but it's still simple) mapped in the CPU's address space. Couldn't be any easier. If you really want to be super-accurate there is scanline timing involved, but for 99.999% of programs it doesn't matter.<br /><br />Yes, I implemented the graphics in my emu. (everything except EGA and 640x480 4-color VGA, but I'll get to that eventually)<br /><br />There are some screenshots from it here: <!-- m --><a class="postlink" href="http://sourceforge.net/projects/fake86/">http://sourceforge.net/projects/fake86/</a><!-- m -->

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Wed Sep 18, 2013 6:03 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Now attempting a segue back to topic.<br /><br />We've been discussing aspects of an emulated CPU that can help determine whether an emulator is fast or slow:<br /><ul><li>how complex the emulated CPU is </li><li>instructions per clock (higher can sometimes be emulated faster) </li><li>clock speed (higher usually means emulated slower) </li></ul>Instructions in the 8080 family (8080, Z80, Game Boy, 8086) tend to take far more cycles than instructions on a 6502. This makes a 6502 as fast as an 8080 family CPU at a much higher clock rate. This is how the NES and Atari 800 got away with a 1.8 MHz 6502 when the ColecoVision, MSX, Master System, and Game Gear were using a 3.6 MHz Z80: the higher IPC cancels out the lower clock rate. The same is true of 65816 in the Super NES and the 68000 in the Genesis, much to the chagrin of Sega &quot;blast processing&quot; fanboys. But an emulator is mostly concerned with the externally visible behavior: 1. how many instructions it can run, and 2. whether the reads, writes, and interrupts happen on the correct cycle relative to the other devices on the bus.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Thu Oct 03, 2013 1:55 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">miker00lz wrote:</div><div class="quotecontent">ArsonIzer - Nope, the 8086 on it's own has no FPU at all fortunately. What you're thinking of is the 8087 co-processor (edit: koitsu beat me to it) which is required by virtually no software out there. I don't really understand the FPU stuff in detail either. As for graphics, emulating CGA and 320x200 256-color MCGA is dead simple to emulate compared to the NES. Not even close, really. They're simple bitmaps (CGA is interlaced, but it's still simple) mapped in the CPU's address space. Couldn't be any easier. If you really want to be super-accurate there is scanline timing involved, but for 99.999% of programs it doesn't matter.<br /><br />Yes, I implemented the graphics in my emu. (everything except EGA and 640x480 4-color VGA, but I'll get to that eventually)<br /><br />There are some screenshots from it here: <!-- m --><a class="postlink" href="http://sourceforge.net/projects/fake86/">http://sourceforge.net/projects/fake86/</a><!-- m --></div><br /><br />Damn, I'm impressed, but I have a somewhat newb-ish question. What determines the memory map of an 8086 combined with, for instance, a CGA? Let's say I want to emulate them like I'm emulating the NES: I know that the NES has the NMI, RESET and IRQ vectors at $FFFA-$FFFF (in that order), the PPU registers in $2000-$20007, controller registers in $4016 and $4017, and so on. Obviously, the 8086 doesn't work exclusively with CGA or MCGA or whatever, so what determines where the locations of, for instance, the CGA's registers are (if it has any). I've tried finding documents about it but there's nothing but a mediocre description on Wikipedia of the CGA. Let's say you run MS-DOS, and DOS writes to a certain memory address expecting a CGA register, but instead an MCGA card is present, what happens? While I understand the basic premise of hardware and emulation, I don't yet understand how various pieces of hardware with different specifications can just work together like that. <br /><br />PS: Sorry for asking this so late, but I just today remembered your reply.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>lidnariq</b> [ Thu Oct 03, 2013 2:22 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ArsonIzer wrote:</div><div class="quotecontent">Obviously, the 8086 doesn't work exclusively with CGA or MCGA or whatever, so what determines where the locations of, for instance, the CGA's registers are (if it has any). I've tried finding documents about it but there's nothing but a mediocre description on Wikipedia of the CGA.<br /></div>Fortunately, IBM actually released a set of incredibly complete documents for the IBM PC—the &quot;IBM Personal Computer XT Technical Reference manual&quot;—and thus also the CGA. These documents explain exactly what and how everything is. It's basically the equivalent of Disch's documentation for nintendo mappers, but written in schematics and datasheets instead of prose and tables.<span style="font-size: 75%; line-height: normal"> (Also consider looking for &quot;Ralf Brown's Interrupt List&quot;.)<br /><br />(For reference, the CGA has the MC6845 at I/O addresses 0x3D4 and 0x3D5, mirrored across 0x3D0-0x3D7. Later compatible things didn't mirror that full range. It also has a bunch of other control registers from 0x3D8-0x3DC.)</span><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Let's say you run MS-DOS, and DOS writes to a certain memory address expecting a CGA register, but instead an MCGA card is present, what happens?<br /></div>The same badness that happens if you're (trying to) using the video driver for an ATI video card but you actually have an Intel card instead. Some certain features are completely compatible (e.g. &quot;VGA compatible&quot;), many aren't. In the bad old days, you'd sometimes have quite a dance of moving things around to get everything to play together.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ArsonIzer</b> [ Thu Oct 03, 2013 5:06 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: What determines whether an emulator is &quot;fast&quot; or &quot;slow&quot;?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">lidnariq wrote:</div><div class="quotecontent">Fortunately, IBM actually released a set of incredibly complete documents for the IBM PC—the &quot;IBM Personal Computer XT Technical Reference manual&quot;—and thus also the CGA. These documents explain exactly what and how everything is. It's basically the equivalent of Disch's documentation for nintendo mappers, but written in schematics and datasheets instead of prose and tables.<span style="font-size: 75%; line-height: normal"> (Also consider looking for &quot;Ralf Brown's Interrupt List&quot;.)<br /><br />(For reference, the CGA has the MC6845 at I/O addresses 0x3D4 and 0x3D5, mirrored across 0x3D0-0x3D7. Later compatible things didn't mirror that full range. It also has a bunch of other control registers from 0x3D8-0x3DC.)</span></div><br /><br />Yeah, too bad I can't really read those schematics and datasheets, so I'd have to learn that first. I appreciate the info though, I came across the document but I thought it would be more about the low hardware-level aspects of components, like pin arrangement and voltage levels and stuff, so I skipped it. I'll look more into it though. <br /><br /><div class="quotetitle">lidnariq wrote:</div><div class="quotecontent">The same badness that happens if you're (trying to) using the video driver for an ATI video card but you actually have an Intel card instead. Some certain features are completely compatible (e.g. &quot;VGA compatible&quot;), many aren't. In the bad old days, you'd sometimes have quite a dance of moving things around to get everything to play together.</div><br /><br />While I understand the driver thing, I don't understand how you can run a disk image like MS-DOS and have it run normally whether a CGA, WCGA, or whatever graphics card is installed. What I mean is that MS-DOS can for instance write to address $F00 to set certain pixels on the screen or whatever, because it expects some kind of graphics register there. How does the processor/graphics card make sure that the write is received as a write to the expected register, even though there are multiple possibly connected cards with different registers/behavior?

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>2</strong> of <strong>3</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>