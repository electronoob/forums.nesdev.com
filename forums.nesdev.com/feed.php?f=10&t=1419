<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=10&amp;t=1419" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2006-06-25T07:26:18-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=10&amp;t=1419</id>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-06-25T07:26:18-07:00</updated>
<published>2006-06-25T07:26:18-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=14525#p14525</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=14525#p14525"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=14525#p14525"><![CDATA[
Just an update for anyone who's interested.<br /><br />I'm still working on this in my copious free time.  I'm up to about 50 classes and 5,000 lines of Java code now.  It took several redesigns, but I now have a pretty flexible code generation framework (in Java) to support my code-generation efforts.  It has pretty-printers for C++ and assembly, and supports heirarchially composable output through the use of "output contexts" (language-specific write-only text buffers) that can be nested (i.e. you can embed a context inside another context) and can have other things (text generators, or hints for the pretty printer) embedded in them wherever you want.  It allows the code-generation code to execute in whatever order is useful, and have the output go where you want it to go--you don't have to produce output in the order it will eventually appear.  I'm actually pretty happy with it.<br /><br />Here is a snippet of generated C++ code, for example (the indenting is automatic):<div class="codetitle"><b>Code:</b></div><div class="codecontent">/**************************************************************************/<br /><br />#define setNZ_8 do &#123; NF=&#40;res&gt;&gt;7&#41;&amp;1; ZF=!&#40;res&amp;0xFF&#41;; &#125;while&#40;0&#41;<br /><br />void alu_op&#40;int opcode&#41; &#123;<br />    switch &#40;opcode&#41; &#123;<br />    case ADC:<br />        VF=&#40;A^T&#41;; A=res=&#40;A+T+CF&#41;; VF=&#40;&#40;VF^res&#41;&gt;&gt;7&#41;&amp;1;<br />        CF=&#40;res&gt;&gt;8&#41;&amp;1; setNZ_8; break;<br />    case SBC:<br />        VF=&#40;A^T&#41;; A=res=&#40;A-T-CF&#41;; VF=&#40;&#40;VF^res&#41;&gt;&gt;7&#41;&amp;1;<br />        CF=!&#40;res&gt;&gt;8&#41;; setNZ_8; break;<br /><br />    case CMP: res=&#40;A-T&#41;; CF=!&#40;res&gt;&gt;8&#41;; setNZ_8; break;<br />    case CPX: res=&#40;X-T&#41;; CF=!&#40;res&gt;&gt;8&#41;; setNZ_8; break;<br /></div><br />and generated assembly will look something like this (horizontal spacing is automatic):<div class="codetitle"><b>Code:</b></div><div class="codecontent">; n6502small.asm<br />; THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT.<br /><br />;---------------------------------------------------------------------------<br />; Dispatch table<br />;---------------------------------------------------------------------------<br /><br />%macro F 1<br />                dw      &#40;op_%1 - APUBASE&#41;,0<br />%endmacro<br />%macro FF 2<br />                dw      &#40;op1_%1 - APUBASE&#41;,&#40;op2_%2 - APUBASE&#41;<br />%endmacro<br />%macro FC 2<br />                dw      &#40;op_%1 - APUBASE&#41;,&#40;%2&#41;<br />%endmacro<br /><br />                ALIGN   32,nop<br />dispatchTab:    F       op_brk_impl             ; 4 ;00: BRK   impl<br />                FF      op1_dxi, op2_ora        ; 4 ;01: ORA   dxi<br />                F       op_hlt_impl             ; 4 ;02: HLT   impl<br />                FF      op1_dxi, op2_slo        ; 4 ;03: SLO   dxi<br />                FF      op1_d, op2_skb          ; 4 ;04: SKB   d<br />                FF      op1_d, op2_ora          ; 4 ;05: ORA   d<br />                FF      op1_d, op2_asl          ; 4 ;06: ASL   d</div><br /><br />Regarding actual code generation, I wrote 95% of a "simple C core generator" for the 6502, and about two thirds of the one for the 65816.  The output they were producing was very large and verbose though.  I also made an attempt at an assembly core generator for the 6502 and ran into difficulties because the way I organized my template-refining code was not very flexible.  So I backed off of that and focused on the C cores for a bit.<br /><br />In an effort to solve the verbosity problem of the C code, I wrote 95% of a 6502 core by hand yesterday---one that uses roughly one case per addressing mode in the giant switch (instead of one case per instruction).  I then refactored my template-refining code and wrote a new 6502 simple C core generator, that generates exactly what I wrote by hand except using the internal data structures of my code generation stuff.  I am very happy with the result (so far)--its about 462 lines long where the old verbose core was well over 4000 lines, making the new one much easier to read.<br /><br />Here's an example of the code being generated for the new "simple-but-readable" 6502 C core:<div class="codetitle"><b>Code:</b></div><div class="codecontent">    case IG_ALU_A:<br />        /* 2 */ SETL&#40;AA,Read&#40;PC++&#41;&#41;;<br />        /* 3 */ SETH&#40;AA,Read&#40;PC++&#41;&#41;;<br />        /* 4 */ T = Read&#40;AA&#41;; do_alu&#40;opcode&#41;;<br />        break;<br /><br />    case IG_ALU_AY: ireg=Y;<br />    case IG_ALU_AX:<br />        /* 2 */ SETL&#40;AA,Read&#40;PC++&#41;&#41;;<br />        /* 3 */ SETH&#40;AA,Read&#40;PC++&#41;&#41;;<br />        carry = &#40;&#40;GETL&#40;AA&#41;+ireg&#41;&gt;&gt;8&#41;; SETL&#40;AA,GETL&#40;AA&#41; + ireg&#41;;<br />        /* 4 */ T = Read&#40;AA&#41;; SETH&#40;AA,GETH&#40;AA&#41; + carry&#41;;<br />        /* 5?*/ if &#40;carry&#41; &#123; T = Read&#40;AA&#41;; &#125;<br />        do_alu&#40;opcode&#41;;<br />        break;<br /></div><br /><br />While refactoring I made the 6502 and 65816 stuff more similar internally, and I am pretty sure I can produce a 65816 generator in this new style fairly easily.  The next thing I plan to do though, is make another stab at an assembly core generator for the 6502.<br /><br />...I haven't compiled any of the generated code yet.  It looks pretty though!   <img src="http://forums.nesdev.com/images/smilies/icon_cool.gif" alt="8)" title="Cool" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Sun Jun 25, 2006 7:26 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-26T12:34:58-07:00</updated>
<published>2006-04-26T12:34:58-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12260#p12260</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12260#p12260"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12260#p12260"><![CDATA[
Yeah, the beauty of code generators is that you don't have "copy and paste" code; you can generate similar-looking code in several places in the output, from a single source.<br /><br />Example:  Suppose I wanted to add a comment to each assembly handler for an undocumented instruction that said "; (undocumented)".  That would be a one- or two-line change somewhere in the code generator.  I don't even have to figure out manually which instructions are the undocumented ones (my tool already knows that).  If I change my mind and decide to put the comment on entries in the dispatch table instead, thats another simple change in one place.  The same principle applies to less trivial changes (such as changing what register a temporary value lives in, or changing the calling convention for the memory access functions).  Hopefully changes like that can be made in fewer places.<br /><br />Some of the same benefits can be had from using macros in the assembler, but I don't really like to use macros because they can obscure what instructions are actually being generated.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Wed Apr 26, 2006 12:34 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-04-25T22:08:03-07:00</updated>
<published>2006-04-25T22:08:03-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12246#p12246</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12246#p12246"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12246#p12246"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />'m not sure how well this will work in terms of performance<br /></div><br /><br />I'd expect performance to possibly exceed that of any other CPU emulator, since you would automate everything and then override this at various layers with optimizations. Optimizations wouldn't just apply to a specific opcode (though they could); they might apply to a whole addressing mode or logical operation. This is the beauty of code generators (or any kind of abstraction): changes can be made at high levels without having to manually update code in several places to avoid inconsistency.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Tue Apr 25, 2006 10:08 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[abonetochew]]></name></author>
<updated>2006-04-25T21:46:26-07:00</updated>
<published>2006-04-25T21:46:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12244#p12244</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12244#p12244"/>
<title type="html"><![CDATA[Re: My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12244#p12244"><![CDATA[
I'm not sure how well this will work in terms of performance, but generating a CPU emulator from a (relatively) readable set of instruction definitions just sounds cool.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=13">abonetochew</a> — Tue Apr 25, 2006 9:46 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-24T21:05:42-07:00</updated>
<published>2006-04-24T21:05:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12213#p12213</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12213#p12213"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12213#p12213"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />Tried <a href="http://www.cminusminus.org/" class="postlink">C--</a>? It's like C but it exposes more low-level machine features, making it suitable as an output language for compiler front ends such as yours.<br /></div><br />I looked at it many years ago, but not lately.  (I didn't like it much then, but maybe it has improved...)<br /><br />Besides, that would take all the fun out of it!  Fiddling with x86 assembly is sort of a hobby of mine.   <img src="http://forums.nesdev.com/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /><br /><br />One thing I've noticed from looking at various people's emulation cpu cores... they are kind of big.  I have a feeling I could produce one that is 1/4th the code size of a typical assembly core, and comparably fast.  I want to see if I can make it work.  (<a href="http://www.grc.com/smgassembly.htm" class="postlink">Small is beautiful.</a>)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Mon Apr 24, 2006 9:05 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2006-04-24T17:50:31-07:00</updated>
<published>2006-04-24T17:50:31-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12207#p12207</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12207#p12207"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12207#p12207"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />Wouldn't most of these issues go away if you were targeting a modern RISC architecture? If you're targeting x86, that basically means a fast desktop machine<br /></div><br />Not necessarily. My main computer is a five-year-old machine with a 0.9 GHz Pentium III. In addition, things such as rewind, fast forward, and multiple systems in multiple windows need a fast CPU.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />In my opinion, any investment in the x86 architecture is doomed to become obsolete in the future<br /></div><br />Then why did Apple switch from PowerPC to x86?<br /><br /><div class="quotetitle">mozz wrote:</div><div class="quotecontent"><br />Emulators can take advantage of architectural features that aren't visible to C, such as machine flags<br /></div><br />Tried <a href="http://www.cminusminus.org/" class="postlink">C--</a>? It's like C but it exposes more low-level machine features, making it suitable as an output language for compiler front ends such as yours.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Apr 24, 2006 5:50 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-24T16:35:04-07:00</updated>
<published>2006-04-24T16:35:04-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12206#p12206</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12206#p12206"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12206#p12206"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />Wouldn't most of these issues go away if you were targeting a modern RISC architecture? If you're targeting x86, that basically means a fast desktop machine, so optimization doesn't matter near as much. The main value of optimization seems to be for portables, which virtually all use RISC processors. In that case, you can let the C compiler optimize and schedule the instructions better.<br /></div><br />People have been saying x86 would die now for at least 10 years.  They've been wrong and they're still wrong.  But that's irrelevant.  I like writing assembly for x86.  =)  There is no other good reason to do it.<br /><br />Its true that decent C compilers do much better on RISC than they do on x86 (mostly because there are more architecturally-visible registers; modern x86 are all-RISC inside).  But writing C code is not nearly as fun or challenging as writing assembly.  Emulators can take advantage of architectural features that aren't visible to C, such as machine flags, continuation-style code, your own funky register passing convention that requires less spillage for your specific use case, etc.  And other things that are hard to make use of in portable C code: rotate instructions, SIMD/MMX instructions, etc.<br /><br />And of course, there are zillions of x86 boxes out there already.  It would be nice to have emulators which were both highly accurate, and fast/lightweight enough to run on that older hardware.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Mon Apr 24, 2006 4:35 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-04-24T15:47:44-07:00</updated>
<published>2006-04-24T15:47:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12204#p12204</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12204#p12204"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12204#p12204"><![CDATA[
Wouldn't most of these issues go away if you were targeting a modern RISC architecture? If you're targeting x86, that basically means a fast desktop machine, so optimization doesn't matter near as much. The main value of optimization seems to be for portables, which virtually all use RISC processors. In that case, you can let the C compiler optimize and schedule the instructions better.<br /><br />In my opinion, any investment in the x86 architecture is doomed to become obsolete in the future, whereas targeting RISC basically means writing your code in a straightforward way in C and using plenty of local variables. Sorry, I just hate the x86 architecture with a strong passion. :)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Mon Apr 24, 2006 3:47 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-24T15:02:32-07:00</updated>
<published>2006-04-24T15:02:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12199#p12199</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12199#p12199"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12199#p12199"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />What practical benefits do you hope to achieve? Some that come to mind are many opportunities for re-use and collaboration at various levels, and the ability to generate cores with various levels of emulation accuracy.<br /></div><br />Mostly I want to experiment with different strategies for making the assembly cores smaller and faster.  I want to be able to (for example) change what register a particular temporary value is stored in, without having to track down 20 places in the code and change them all, and without having to riddle my assembly code with macros.<br /><br />You could think of my tool as a very specialized compiler which has the input (the specs for each chip) built in.  Its Intermediate Representation (IR) is just the template string.  Refining the template is sort of like optimizing the IR (though peephole optimizations are usually done near the end).  Strings are easy to manipulate, and it can generate straight-line code from each string template with ease, because it doesn't have to worry about control flow and register allocation and so on---the code it is generating is specialized for one particular task (cycle-accurate emulation of an instruction) so not much smarts will be needed for that (I hope).<br /><br />In the last few months, I have written by hand most of a slow-but-readable C core for a 65816.  I have written most of an optimized-for-size assembly core for SPC700, and some parts of an optimized-for-size assembly core for a 65816.  Enough so that I have a pretty good idea of what I want to generate.  I more or less wrote those by manually following the steps I hope to automate with my tool.  Which is good, because I sometimes overlook little details (and introduce hard-to-find bugs) when I do a bunch of manual steps like that.  With the tool, once I get the tool doing the right thing, I can change it and generate a new core with the press of a button.  Unless I introduce a bug in the tool, I don't have to worry about one of the derivation steps being performed incorrectly.<br /><br />Also, by having the slow-but-readable-C core and the very different optimized assembly core, I can test them against each other.  Any discrepancy points to some sort of bug or oversight in either in the code generator, or in the blocks of code it is generating.<br /><br />Ultimately I want to have fully automated tests for each part of my emulator.  For the cores, this means exhaustive tests for each instruction, testing all the corner cases of each addressing mode (wrapping behaviour, exact timing of read and write cycles, interrupting for DMA, multi-byte accesses that overlap different memory regions, etc).  For example, the assembly core for a 65816 calls one function to fetch two bytes, and the C core does two 8-bit reads and combines the result afterwards.  The assembly core has 5 separate dispatch tables and uses different handlers for M0 and M1 versions of an instruction; the C core uses one switch statement and has if-tests where the M flag affects execution.  The assembly core relies on X86 flag values wherever possible to compute the flags of the emulated processor; the C core will have to evaluate them separately.  The C core will be an executable embodiment of "what the semantics should be".  The assembly core's behaviour will then be compared against the C core's behaviour in great detail to make sure the optimizations did not break the assembly core in some subtle fashion.  Whenever I change things or fix a bug or disable or enable new optimizations, I generate both cores and run the automated tests to prove they are still equivalent.<br /><br />Another kind of easy automated test I thought of is ROM-loading tests.   Write a tool which processes the output of a ROM-cleaning utility (e.g. for SNES roms, I'd use NSRT; for NES roms, perhaps GoodNES?) and caches the information about how each ROM should be loaded:  LoROM/HiROM or mapper type, what special chips are activated, etc.  Then test the emulator by having it load each ROM and compare the decisions it made while loading the ROM, to the cached info from ROM tool.  So if the cached info says the ROM uses a certain mapper, you check that the emulator decided to set up the same mapper.  There's one test for each ROM, which fails if there are any discrepancies (i.e. it fails if the emulator interprets the ROM differently than the tool's database said it should be interpreted).  Collect a large set of ROMs for each system, and whenever I make changes to the rom loading code, run these tests.<br /><br />Edit: also, the tools will format the generated code to make it nice and easy to read.  The C code generator will automatically count open curly braces and indent each line the correct number of spaces.  The assembly code generator would accept something like "foo: add eax,edx  ; 2 ...comment" and would spread out the fields the proper amount:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">foo:            add     eax,edx                         ; 2 ...comment</div>  If it needs to make more room for the label or comment, it can wrap it onto the next line, etc.  That number ("2") is the size of the instruction; my text editor has a column mode and I can sum the columns to find out how many bytes of code are generated.  With a little smarts built into it, the tool could compute that number for me.  It could also compute 4-1-1 decoder templates and insert the number of P3 micro-ops required for each instruction, etc (something I occasionally do by hand just for curiosity's sake).<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Mon Apr 24, 2006 3:02 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2006-04-23T23:37:59-07:00</updated>
<published>2006-04-23T23:37:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12164#p12164</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12164#p12164"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12164#p12164"><![CDATA[
I have been thinking of writing a code generator for a few CPU cores, since it is one area where extensive abstraction tools could significantly improve ease-of-coding without sacrificing speed. The main demotivator is that I don't think it'd help much, due to a small number of instructions being much more common than others.<br /><br />What practical benefits do you hope to achieve? Some that come to mind are many opportunities for re-use and collaboration at various levels, and the ability to generate cores with various levels of emulation accuracy.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The advantage here is that each prefab block of code is represented in one place, and can be re-used in different but similar templates. So if I have a bug in the code for some addressing mode (for example), I only have to fix it in one place.<br /></div><br /><br />A while back I wrote a fresh 6502 core that had absolutely no duplication of any code, and it was a breeze to get debugged since any bug would affect many opcodes, either all using a certain addressing mode or all using a certain operation.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Apr 23, 2006 11:37 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-23T21:26:34-07:00</updated>
<published>2006-04-23T21:26:34-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12161#p12161</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12161#p12161"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12161#p12161"><![CDATA[
And by "we" I mean "I".  (The "royal We").  Years of working on projects with collective code ownership have apparently messed me up in the head.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Sun Apr 23, 2006 9:26 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[mozz]]></name></author>
<updated>2006-04-23T21:20:28-07:00</updated>
<published>2006-04-23T21:20:28-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12160#p12160</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12160#p12160"/>
<title type="html"><![CDATA[My crazy project]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=1419&amp;p=12160#p12160"><![CDATA[
I've started working on an ambitious project that some folks here might find interesting.  (I have a habit of starting ambitious projects and not finishing them, but I've been interested in SNES emulation for at least a year and a half now, so hopefully I will stick with it!)<br /><br />Though it is ambitious, I've put lots of thought into it and I'm heading in a direction that seems good so far.  Over the last few months I've made several attempts to capture the semantics of a 65816 (for example) in a "simple specification" which I could then write tools to generate code from (i.e. generate an emulation core for that chip).  I wanted a representation where each "timing template" fit on one line.  After struggling with various attempts to capture this information, I've finally hit on a representation with the characteristics I want.<br /><br />A "timing template" is meant to be a loose description of the externally visible effects of an instruction during its execution.  In other words, it describes what the chip does in each cycle -- a memory read or write, an operand fetch, or some internal operation.  After struggling with various attempts to capture this information, I've hit on a format that I think will work.  Here are some examples from my G65816 templates (which are derived directly from table 6-7 in the W65C816S datasheet):<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">       &quot;1a : &#123;F_AAL&#125; &#123;F_AAH&#125; &#123;AX_L&#125; ?1&#123;AX_H&#125; alu_op&quot;,<br />       &quot;1b : &#123;F_NewPCL&#125; &#123;F_NewPCH&#125; PC=NewPC&quot;,<br />       &quot;1c : &#123;F_NewPCL&#125; &#123;F_NewPCH&#125; &#123;IO&#125; &#123;PUSH_PCH&#125; &#123;PUSH_PCL&#125; PC=NewPC&quot;,<br />       &quot;1d : &#123;F_AAL&#125; &#123;F_AAH&#125; &#123;AR_L&#125; ?1&#123;AR_H&#125; &#123;rmw_op&#125; ?1&#123;AW_H&#125; &#123;AW_L&#125;&quot;,<br /><br />       &quot;10a: &#123;F_DO&#125; ?2&#123;IO&#125; &#123;DX_L&#125; ?1&#123;DX_H&#125; alu_op&quot;,<br /></div><br />1a is used for ALU instructions with Absolute addressing mode.  1d is used for R-M-W instructions with Absolute addressing mode. 10a would be used for ALU instructions with Direct addressing mode.  Each {term} represents one cycle.  Extra effects which appear outside the curly braces can be thought of as part of the previous cycle.  The ?1 at the beginning of certain cycles is a "predicate", and means that cycle is ONLY part of the instruction for situations where "condition 1" is true.  In this case, "condition 1" means the instruction has 16-bit data (i.e. the X flag=0 for instructions which use X/Y, or the M flag=0 for instructions which use the accumulator).<br /><br />So, what can I do with these things, anyway?<br /><br />Well, I am hoping to produce a code generator (written in Java) which can output various emulation cores for these chips.  I hope to eventually use the same code generator infrastructure to produce slow-but-readable C cores, optimized assembly cores and an exhaustive set of automated tests for several chips (NES CPU, SNES CPU and APU, Gameboy CPU, whatever).  I would then use these cores as part of the implementation of a multi-system emulator.   The slow-but-readable C cores will be derived more or less directly from the timing templates of each chip, so they will be easy to read and debug (but still cycle-accurate).  The optimized assembly cores will have a significantly different internal structure, but using automated tests I will exhaustively compare their behaviour with that of the slow-but-readable C cores and ensure that every instruction has exactly the same visible side effects in the assembly core as in its slower cousin.<br /><br /><br />How will this code generator work?<br /><br />Essentially, it will start with a table of all instructions (in a format easily derived from available documents).  It will parse the table into an internal format, and compute the proper base "timing template" for each instruction.<br /><br />For each instruction, the code generator will scan the template, counting the minimum and maximum number of cycles, and comparing those to what is known about the instruction (to make sure it is consistent).  It will use the predicates mentioned in the template to decide if we need multiple instantiations of this instruction (for example, if it has the ?1 predicate in it, we will need either M0 and M1 versions, or X0 and X1 versions).<br /><br />It will the proceed to <strong>refine</strong> the template into a more useful form, for a particular instantiation.  It will essentially search-and-replace certain parts of it with other parts.  For example, when generating the assembly core, it might replace "{F_AAL} {F_AAH}" with something like "{}{F16_AA}", because the assembly core is going to use one function to read both bytes simultaneously.  (This is kind of like a peephole optimization).<br /><br />The replacement is context-sensitive, so if necessary, I can interpret the same term in different ways depending on the instruction it is used in.  For example, in 1a for a STA instruction, the {AX_L} might become an {AW_L} to write the low byte.  For a different instruction like ADC, it might become {AR_L} instead.  (Or for the assembly core and M0, both cycles would be replaced by {}{AR16_T}).<br /><br />The predicate ?1 is a good example.  In the slow-but-readable C core, "{AX_L} ?1{AX_H}" might generate code for two cycles, with an if-statement around the second cycle's code so it only executes if M=0.  In the assembly core, the entire instruction will be instantiated twice and different handlers will be generated for each mode (i.e. M1 and M0).  So the predicate can be evaluated at code-generation time, as it were... the M1 handler will have those two terms replaced by something like {AR_L}", and the M0 handler would have them replaced by "{}{AR16_T}".<br /><br />Notice that refinement can add semantic information which was not present in the original templates.  For example, in the 10a template, somehow between the {F_DO} term and the first direct read or write (the {DX_L} term) we need to take the direct address "DO" and add the D register to it.  The template intentionally does NOT capture this requirement (leaving it out makes it easier to manipulate the template in various ways).  Either through refinement, or later when we generate the code for those terms, we need to make sure the effect of calculating the direct address happens.  Maybe in the C core, we will use refinement to insert an explicit action "DO += D" after the {F_DO} term.  But in the assembly core, I might instead expect the function called to implement the read/write term to handle the calculation of the address.<br /><br />After refinement, there are some steps which manipulate the structure instantiated instruction templates.  (Long story short--in some of the assembly cores, I plan to split most of the instruction handlers into two routines chained together, to reduce the amount of duplicated code.  At this point, it would find points in the instantiated templates where they could be split, and work out what the two halves of each instruction's handler are, etc).<br /><br />Finally, we generate code in a greedy fashion by matching parts of the final template string and spitting out prefab blocks of code.  The advantage here is that each prefab block of code is represented in one place, and can be re-used in different but similar templates.  So if I have a bug in the code for some addressing mode (for example), I only have to fix it in one place.  This is almost like using a macro in the assembler, but its more convenient for me this way.<br /><br />As mentioned above, I also want to generate automated tests for each instruction of each CPU.  I haven't thought about how that will work in as much detail, but hopefully the same code generator thingy will support that task as well.  =)<br /><br />How far have I got?<br /><br />So far, I've got instruction lists for N6502 (documented only) and G65816 and SPC700 which are being parsed into usable data structures.  I've got timing templates for G65816 and SPC700, and I'm computing the correct timing template for each instruction for the G65816.  I'm about ready to try and write the first code for matching and refining parts of G65816 templates.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=330">mozz</a> — Sun Apr 23, 2006 9:20 pm</p><hr />
]]></content>
</entry>
</feed>