<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=3&amp;t=6167" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2010-03-15T08:03:32-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=3&amp;t=6167</id>
<entry>
<author><name><![CDATA[Jarhmander]]></name></author>
<updated>2010-03-15T08:03:32-07:00</updated>
<published>2010-03-15T08:03:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58339#p58339</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58339#p58339"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58339#p58339"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />C++ FAQ has <a href="http://yosefk.com/c++fqa/" class="postlink">a rebuttal</a>; have you read it?<br /></div><br /><br />No! And I'm really happy to see such a site, that's the first time I see such a website bashing C++ <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> thanks!!! I'll read it carefully.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=336">Jarhmander</a> — Mon Mar 15, 2010 8:03 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Jarhmander]]></name></author>
<updated>2010-03-15T07:43:39-07:00</updated>
<published>2010-03-15T07:43:39-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58337#p58337</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58337#p58337"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58337#p58337"><![CDATA[
<div class="quotetitle">tepples wrote:</div><div class="quotecontent"><br />Are you <em>trying</em> to get on TheDailyWTF.com? <img src="http://forums.nesdev.com/images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /><br /></div><br />No... <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> ? But you can call me freak anyways...<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=336">Jarhmander</a> — Mon Mar 15, 2010 7:43 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2010-03-14T19:26:33-07:00</updated>
<published>2010-03-14T19:26:33-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58291#p58291</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58291#p58291"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58291#p58291"><![CDATA[
<div class="quotetitle">~J-@D!~ wrote:</div><div class="quotecontent"><br />OK, I've spent half my afternoon to find a solution without using any macro (because macros are evil (C++ FAQ lite) and we want something more portable)<br /></div><br />C++ FAQ has <a href="http://yosefk.com/c++fqa/" class="postlink">a rebuttal</a>; have you read it? As for portability, even on the same compiler targeting the same CPU, different operating systems have different UI toolkits.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">// and now, we make our list of unsigned integral type<br />typedef type_list&lt;<br />        unsigned char, type_list&lt;<br />            unsigned wchar_t, type_list&lt;<br />                unsigned short, type_list&lt;<br />                    unsigned int, type_list&lt;<br />                        unsigned long int, type_list&lt;<br />                            unsigned long long int, Empty&gt;<br />                        &gt;<br />                    &gt;<br />                &gt;<br />            &gt;<br />        &gt;<br />    unsigned_integral_type_list;<br /></div><br /></div><br />Are you <em>trying</em> to get on TheDailyWTF.com? <img src="http://forums.nesdev.com/images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Sun Mar 14, 2010 7:26 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-14T19:04:33-07:00</updated>
<published>2010-03-14T19:04:33-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58288#p58288</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58288#p58288"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58288#p58288"><![CDATA[
Oh dear, overkill^overkill there with those templates. If you want fully portable code but don't want to have to remember to mask everywhere (forget and you have a bug), use a bitfield:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">struct &#123;<br />   unsigned pc : 16;<br />&#125; m;<br /><br />m.pc++; // equivalent to m.pc = &#40;m.pc + 1&#41; &amp; 0xFFFF</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Mar 14, 2010 7:04 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Jarhmander]]></name></author>
<updated>2010-03-14T18:31:50-07:00</updated>
<published>2010-03-14T18:31:50-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58284#p58284</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58284#p58284"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58284#p58284"><![CDATA[
OK, I've spent half my afternoon to find a solution without using any macro (because macros are evil (C++ FAQ lite) and we want something more portable) and without execution penalty (in other words, everything is done compile-time).  My code is a bit generic, so it may suit other situations.<br /><br />The key is to use templates to make compile-time decisions on the type of a typedef. First, we have to make a kind of static linked list of types using templates, and make a meta-programmed algorithm to find the desired type that have the sizeof we want.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">// we have to make such a static linked list of type. <br />// so that's the basic definition, and later we'll link it with himself<br />template&lt;typename T, typename U&gt;<br /> struct type_list<br />&#123;<br />    //those members are facultative here, but might be useful<br />    typedef T head;<br />    typedef U tail;<br />&#125;;<br /><br />// but to find the end of such a list, we have to define it<br />class Empty&#123;&#125;;<br /><br /><br />// and now, we make our list of unsigned integral type<br />typedef type_list&lt;<br />        unsigned char, type_list&lt;<br />            unsigned wchar_t, type_list&lt;<br />                unsigned short, type_list&lt;<br />                    unsigned int, type_list&lt;<br />                        unsigned long int, type_list&lt;<br />                            unsigned long long int, Empty&gt;<br />                        &gt;<br />                    &gt;<br />                &gt;<br />            &gt;<br />        &gt;<br />    unsigned_integral_type_list;<br /><br /><br />// that class will perform the actual research algorithm<br />template&lt;unsigned size_of, typename T&gt;<br />  class find_type_with_n_bytes;<br /><br />// anything that doesn't match something below will lead to compile error.<br />template&lt;unsigned size_of, typename head, typename tail&gt;<br /> class find_type_with_n_bytes&lt;size_of,type_list&lt;head, tail&gt; &gt;<br />&#123;<br />    // in the private field we have another struct that will truly do the job<br />    // using recursion, at compile-time.<br />    template&lt;bool, unsigned, typename, typename&gt;<br />        struct research_type_by_size_of;<br /><br />    // this is the case when we have found the type.<br />    template&lt;unsigned my_size_of,typename _result, typename _any&gt;<br />        struct research_type_by_size_of&lt;true, my_size_of, _result, _any &gt;<br />    &#123;<br />        typedef _result _type;<br />    &#125;;<br /><br />    //this is the case when the type is not found, and we're at the end of <br />    // the list. We typedef the struct type_not_found so when trying to<br />    // actually use the type, it will fail to compile with a fairly explicit <br />    // error like &quot; illegal use of 'struct type_not_found' &quot;<br />    template&lt;unsigned my_size_of, typename _result&gt;<br />        struct research_type_by_size_of&lt;false, my_size_of, _result, Empty &gt;<br />    &#123;<br />        typedef struct type_not_found _type;<br />    &#125;;<br /><br />    // the recursive case, when the type is not found and we're not yet at<br />    // the end of the list.<br />    template&lt;unsigned my_size_of,typename _result, typename _head, typename _tail&gt;<br />        struct research_type_by_size_of&lt;false, my_size_of, _result, type_list&lt; _head, _tail &gt; &gt;<br />    &#123;<br />        typedef typename research_type_by_size_of&lt;&#40;sizeof&#40;_head&#41;== my_size_of&#41;, my_size_of, _head, _tail &gt;::_type _type;<br /><br />    &#125;;<br /><br />public:<br />    // what the user can use.<br />    typedef typename research_type_by_size_of&lt;&#40;sizeof&#40;head&#41;== size_of&#41;, size_of, head, tail &gt;::_type result;<br /><br /><br />&#125;;<br /><br />int main&#40;int,char *&#91;&#93;&#41;<br />&#123;<br />     // how to use:<br />     typedef find_type_with_n_bytes&lt;2,unsigned_integral_list_type&gt;::result myUInt_16_t;<br /><br />     //do whatever you want with<br />     myUInt_16_t a, b, c = b = a = 0;<br /><br />     return 0;<br />&#125;<br /></div><br /><br />Note: I suspect there's something in the C++ Boost library that already addresses the issue, but I didn't checked out, probably because I wanted to take that challenge <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=336">Jarhmander</a> — Sun Mar 14, 2010 6:31 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Hangin10]]></name></author>
<updated>2010-03-14T18:28:07-07:00</updated>
<published>2010-03-14T18:28:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58283#p58283</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58283#p58283"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58283#p58283"><![CDATA[
Portability is great, but how many people that are all about it actually make sure their code runs on all of Windows, *nix, and Mac? Nevermind the fact that newer Macs make it so they don't have to care about non-x86 platforms.<br /><br />I have noticed lately that I need to use long long to get 64bit "u64" typedefs on both i586 and x86-64 gcc, so I really shouldn't talk.  <img src="http://forums.nesdev.com/images/smilies/icon_rolleyes.gif" alt=":roll:" title="Rolling Eyes" />  <img src="http://forums.nesdev.com/images/smilies/icon_cool.gif" alt="8)" title="Cool" /><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3934">Hangin10</a> — Sun Mar 14, 2010 6:28 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Zepper]]></name></author>
<updated>2010-03-14T17:20:51-07:00</updated>
<published>2010-03-14T17:20:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58277#p58277</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58277#p58277"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58277#p58277"><![CDATA[
- It makes sense, but it's just annoying to use only <strong>int</strong> or <strong>unsigned int</strong> for every value. <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> Some values must be boolean (unsigned char), for example.<br /><br />- Anyway, what system/OS/whatever "see" an unsigned short different, other than 16bit long? AFAIK, the "old" (?) Macs use reversed bytes, Big endian, not Little endian.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=39">Zepper</a> — Sun Mar 14, 2010 5:20 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Petruza]]></name></author>
<updated>2010-03-14T14:40:21-07:00</updated>
<published>2010-03-14T14:40:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58254#p58254</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58254#p58254"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58254#p58254"><![CDATA[
Well my main concern right now is not speed optimization, but just to have a value I'm sure won't surpass 0xFFFF.<br />So it's either enforced by the data type or by a bit mask.<br />That's why I ask this.<br />And also my concern is that this code is the most portable possible.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3773">Petruza</a> — Sun Mar 14, 2010 2:40 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-14T14:08:27-07:00</updated>
<published>2010-03-14T14:08:27-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58246#p58246</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58246#p58246"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58246#p58246"><![CDATA[
It's one thing to use uint16_t to get implicit masking with 0xFFFF, but quite another to use it for a particular format in memory. Many machines store the least-significant octet first, then the most, but plenty store it in the reverse order. And plenty of machines require that it be aligned on a two-byte boundary, either aborting the program or giving a wrong result when it's not aligned. Unless profiling shows that your program is too slow AND that it is improved enough by using uint16_t instead of accessing the bytes individually and combining them, stick to something you know is portable.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Mar 14, 2010 2:08 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[koitsu]]></name></author>
<updated>2010-03-14T11:30:04-07:00</updated>
<published>2010-03-14T11:30:04-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58228#p58228</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58228#p58228"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58228#p58228"><![CDATA[
Please don't assume short = 16-bit.  That simply isn't the case on all platforms.  Please use the standard uintXX_t and intXX_t types that are already defined (mostly) universally.  Specifically uint8_t, uint16_t, uint32_t, and uint64_t.  Same goes for the non-unsigned versions.<br /><br />You might also find things like 1ULL useful.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3">koitsu</a> — Sun Mar 14, 2010 11:30 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Petruza]]></name></author>
<updated>2010-03-14T10:27:49-07:00</updated>
<published>2010-03-14T10:27:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58219#p58219</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58219#p58219"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58219#p58219"><![CDATA[
yes, I actually use typedef unsigned short int word;<br />Thanks for the tips on how to assert word's length at compile time.<br /><br />I just want to make the code the most portable possible, but I guess the source would need some modification for machines in which shorts are larger than two bytes.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3773">Petruza</a> — Sun Mar 14, 2010 10:27 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Zepper]]></name></author>
<updated>2010-03-14T10:26:20-07:00</updated>
<published>2010-03-14T10:26:20-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58218#p58218</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58218#p58218"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58218#p58218"><![CDATA[
- Well, I knew about the alignment thing, but never thought it would have some impact.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=39">Zepper</a> — Sun Mar 14, 2010 10:26 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Disch]]></name></author>
<updated>2010-03-14T10:12:06-07:00</updated>
<published>2010-03-14T10:12:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58213#p58213</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58213#p58213"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58213#p58213"><![CDATA[
I say typedef it.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">typedef unsigned short u16;<br />typedef signed short s16;<br /></div><br /><br />If you run into a compiler/system where short is a different size -- just change your typedef.<br /><br />If you run into a compiler/system that doesn't support a 16-bit data type, you can write a class to simulate one (can just use a larger type and overload mathematical operators to mask afterward).  Just change your typedef to be your class.<br /><br /><br />typedefs are great.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=33">Disch</a> — Sun Mar 14, 2010 10:12 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-14T10:07:44-07:00</updated>
<published>2010-03-14T10:07:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58211#p58211</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58211#p58211"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58211#p58211"><![CDATA[
I recommend simply masking with 0xFFFF. I use plain int for addresses in most of my emulators and don't have to constantly mask them. This is the most portable approach, since it doesn't depend on the hardware doing anything in particular. If you want to support machines with 16-bit int (rare these days), you'll need to use unsigned int. If you want to support non-two's-complement machines, you'll need to use unsigned int or cast to unsigned int before masking (consider subtracting 1 from an address of 0; you get -1 if signed int, then cast to unsigned int and are guaranteed a two's complement representation, for masking).<br /><br />If profiling shows that masking is somehow significantly slower than using uint16_t, you can get the latter from &lt;stdint.h&gt;. Just remember that stdint.h isn't part of C89 (it's part of C99), and not a part of any C++ standard. Even on C99, it's not guaranteed to exist, because the host hardware might not support such a size.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Mar 14, 2010 10:07 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[hyarion]]></name></author>
<updated>2010-03-14T09:52:42-07:00</updated>
<published>2010-03-14T09:52:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58210#p58210</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58210#p58210"/>
<title type="html"><![CDATA[[C/C++]Relying on short to be 2 bytes wide, a good practice?]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6167&amp;p=58210#p58210"><![CDATA[
if you need an int to be exactly 16bits wide, why not use int16_t / uint16_t instead (defined in &lt;stdint.h&gt;)?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3903">hyarion</a> — Sun Mar 14, 2010 9:52 am</p><hr />
]]></content>
</entry>
</feed>