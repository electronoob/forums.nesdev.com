<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Z80 T-cycle timing: what the hell damn guy?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Z80 T-cycle timing: what the hell damn guy?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=23&amp;t=14994">http://forums.nesdev.com/viewtopic.php?f=23&amp;t=14994</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>3</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Fri Oct 28, 2016 9:24 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />How in the world is this possible?<br /><br /><img src="http://i.imgur.com/CyPIh8i.png" alt="Image" /><br /><br />The opcode fetch (0xed) should consume 4 cycles.<br />The suffix fetch (0xb0) should consume 4 cycles.<br />The read from (HL) should consume 3 cycles.<br />Incrementing HL and DE; plus decrementing BC; should take 3 cycles? Yet we end up consuming 5.<br />Decrementing PC when BC=0 should take 1 cycle? But ends up consuming 5.<br /><br />This one's even worse:<br /><br /><img src="http://i.imgur.com/m6kkzG6.jpg" alt="Image" /><br /><br />The opcode fetch (0xed) is once again 4 cycles.<br />But now the suffix fetch (0xa2) is taking FIVE cycles??!!<br />And now our read from in(C) should take 4 cycles, but is now THREE cycles?! &gt;_&lt;<br />The increment of HL and decrement of B should take 2 cycles, but instead takes four.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ccovell</b> [ Fri Oct 28, 2016 5:06 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />It's microcoded, right?  So those extra cycles are taken up by some hidden opcode sequencer figuring out what instruction to do next to perform LDIR, I'd imagine.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Sat Oct 29, 2016 6:02 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ccovell wrote:</div><div class="quotecontent">It's microcoded, right?  So those extra cycles are taken up by some hidden opcode sequencer figuring out what instruction to do next to perform LDIR, I'd imagine.</div><br /><br />Probably. I know the 68K definitely is, at least.<br /><br />The issue is I'm really not sure how to emulate such variable timings. Maybe I could make a template parameter on the read/write/in/out functions to override the amount of cycles they consume. Sometimes add one, sometimes remove one.<br /><br />But when there are extra M cycles (presumably wait states), it's important to know where to place them to get a proper cycle timing between components.<br /><br />There's also so many mistakes in the manual. I'd hate to go to the extra trouble and end up with broken timings for it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Dwedit</b> [ Sat Oct 29, 2016 11:10 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />You end up using unrolled LDIs because it's faster than LDIR.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Stef</b> [ Sun Oct 30, 2016 6:49 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />HL, BC, DE registers are 16 bits so that requires using 16 bits inc/dec ALU, not sure how many are available in the Z80 CPU but that may explain why the LDI instruction is so slow.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>AWJ</b> [ Sun Oct 30, 2016 4:06 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">How in the world is this possible?</div><br /><br />You can look at the bus traces I linked a while back to see what's going on. Remember, internal operations (i.e. T-states in excess of what that type of bus access should normally take) occur at the <em>end</em> of an M-cycle.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><img src="http://i.imgur.com/CyPIh8i.png" alt="Image" /><br /><br />The opcode fetch (0xed) should consume 4 cycles.<br />The suffix fetch (0xb0) should consume 4 cycles.<br />The read from (HL) should consume 3 cycles.<br />Incrementing HL and DE; plus decrementing BC; should take 3 cycles? Yet we end up consuming 5.<br />Decrementing PC when BC=0 should take 1 cycle? But ends up consuming 5.</div><br /><br />Let's look at the bus trace for LDIR:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">Opcode: ED B0 =&gt; LDIR<br /><br />-----------------------------------------------------------+<br />#001H T1&nbsp; AB:000 DB:--&nbsp; M1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#002H T2&nbsp; AB:000 DB:ED&nbsp; M1&nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Opcode read from 000 -&gt; ED<br />#003H T3&nbsp; AB:000 DB:--&nbsp; &nbsp; &nbsp;RFSH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <br />#004H T4&nbsp; AB:000 DB:--&nbsp; &nbsp; &nbsp;RFSH MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Refresh address&nbsp; 000<br />-----------------------------------------------------------+<br />#005H T1&nbsp; AB:001 DB:--&nbsp; M1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#006H T2&nbsp; AB:001 DB:B0&nbsp; M1&nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Opcode read from 001 -&gt; B0<br />#007H T3&nbsp; AB:001 DB:--&nbsp; &nbsp; &nbsp;RFSH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <br />#008H T4&nbsp; AB:001 DB:--&nbsp; &nbsp; &nbsp;RFSH MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Refresh address&nbsp; 001<br />#009H T5&nbsp; AB:06C DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#010H T6&nbsp; AB:06C DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Memory read from 06C -&gt; 00<br />#011H T7&nbsp; AB:06C DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Memory read from 06C -&gt; 00<br />#012H T8&nbsp; AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#013H T9&nbsp; AB:05B DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#014H T10 AB:05B DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ&nbsp; &nbsp; WR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Memory write to&nbsp; 05B &lt;- 00<br />#015H T11 AB:05B DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#016H T12 AB:05B DB:00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#017H T13 AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#018H T14 AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#019H T15 AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#020H T16 AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#021H T17 AB:05B DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />-----------------------------------------------------------+</div><br /><br />The fourth M-cycle is the write to (DE) (#012-#014) plus two internal T-states (#015-#016). The Z80 has to increment DE, decrement BC, and test the decremented BC for zero.<br />The fifth M-cycle when the loop is taken (#017-#021) is completely internal (no bus access). It's probably doing the same stuff as a JR instruction (which also takes 5 T-states at the end)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">This one's even worse:<br /><br /><img src="http://i.imgur.com/m6kkzG6.jpg" alt="Image" /><br /><br />The opcode fetch (0xed) is once again 4 cycles.<br />But now the suffix fetch (0xa2) is taking FIVE cycles??!!<br />And now our read from in(C) should take 4 cycles, but is now THREE cycles?! &gt;_&lt;<br />The increment of HL and decrement of B should take 2 cycles, but instead takes four.</div><br /><br />4, 5, 3, 4 is obviously incorrect (the manual writer probably used the counts from OUTI by mistake). It's actually 4, 5, 4, 3:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">Opcode: ED A2 =&gt; INI<br /><br />-----------------------------------------------------------+<br />#001H T1&nbsp; AB:000 DB:--&nbsp; M1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#002H T2&nbsp; AB:000 DB:ED&nbsp; M1&nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Opcode read from 000 -&gt; ED<br />#003H T3&nbsp; AB:000 DB:--&nbsp; &nbsp; &nbsp;RFSH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <br />#004H T4&nbsp; AB:000 DB:--&nbsp; &nbsp; &nbsp;RFSH MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Refresh address&nbsp; 000<br />-----------------------------------------------------------+<br />#005H T1&nbsp; AB:001 DB:--&nbsp; M1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#006H T2&nbsp; AB:001 DB:A2&nbsp; M1&nbsp; &nbsp; &nbsp; MREQ RD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Opcode read from 001 -&gt; A2<br />#007H T3&nbsp; AB:001 DB:--&nbsp; &nbsp; &nbsp;RFSH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <br />#008H T4&nbsp; AB:001 DB:--&nbsp; &nbsp; &nbsp;RFSH MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Refresh address&nbsp; 001<br />#009H T5&nbsp; AB:001 DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#010H T6&nbsp; AB:049 DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#011H T7&nbsp; AB:049 DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RD&nbsp; &nbsp; IORQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | I/O read from 049<br />#012H T8&nbsp; AB:049 DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RD&nbsp; &nbsp; IORQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | I/O read from 049<br />#013H T9&nbsp; AB:049 DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RD&nbsp; &nbsp; IORQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | I/O read from 049<br />#014H T10 AB:06E DB:--&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#015H T11 AB:06E DB:A3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />#016H T12 AB:06E DB:A3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MREQ&nbsp; &nbsp; WR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Memory write to&nbsp; 06E &lt;- A3<br />-----------------------------------------------------------+</div><br /><br />Fetch, fetch + one internal operation (#009), port in, write.<br /><br />I believe the Z80 has only one 16-bit inc/dec unit which is shared between the PC, the SP, and the register pairs, and it takes more than one T-state to do its job (i.e. increment or decrement one 16-bit register). Any M-cycle that performs an increment/decrement <em>that the next cycle needs the value of</em> seems to end up taking extra T-states. Notice that PUSH qq has an internal T-state after the fetch and before the first memory write (5, 3, 3) but POP qq doesn't have any (4, 3, 3). PUSH needs the <em>decremented</em> value of SP, so the second M-cycle can't begin until the decrement is complete. But for POP the effective address is the <em>current</em> value of SP, so the memory access can happen right away.<br /><br />(Notice that the 6502 is the exact opposite of the Z80: PHA uses the <em>current</em> value of SP, PLA uses the <em>incremented</em> value of SP, and PLA takes one more cycle than PHA does. Stacks that work like the Z80's are called &quot;full&quot; stacks and stacks that work like the 6502's are called &quot;empty&quot; stacks)<br /><br />Don't think of each T-state as one discrete operation (this cycle is incrementing HL, this next one is incrementing DE), think of several things going on at once inside the chip that take varying amounts of time, and the next M-cycle can't begin until all of them are done. Internal T-states happen when the register-level operations can't all be completed in the time that the memory operation takes.<br /><br />From an emulation perspective I suggest having a &quot;op_internal(unsigned count)&quot; method that can efficiently add any number of internal T-states, and call that from each opcode handler at the appropriate times (just like you call op_io() or whatever it's called now in the 65816/6502) You pretty much have to handle the internal cycles separately from the memory-accessing cycles, because some (many) instructions have an internal T-state or two on their first cycle, and you can't tell that until you've decoded the instruction!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Mon Oct 31, 2016 5:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Thanks as always for the info!<br /><br />&gt; Let's look at the bus trace for LDIR:<br /><br />Would you happen to have a bus trace for every instruction? That would be really super helpful.<br /><br />If you're making these by hand, then I don't want to bug you to do all that work. But if it already exists, please share :D<br /><br />&gt; It's actually 4, 5, 4, 3:<br /><br />Oh, whew. I can accept that the increment wait-state is earlier in the instruction this time, but not that a read/write/in/out call takes less time.<br /><br />&gt; From an emulation perspective I suggest having a &quot;op_internal(unsigned count)&quot; method that can efficiently add any number of internal T-states<br /><br />Yeah, right now I have: read, write, in, out, wait. And I also have some convenience wrappers like opcode() [8-bit read from PC + one wait state], operand() [8-bit read from PC], operands() [16-bit read from PC], push, pop, etc that are all built off the first five.<br /><br />The downside is those internal operations consume time, so it becomes harder to count the T-states to make sure there are no errors. But it's not impossibly difficult.<br /><br />What would really help would be if the manual broke down the T-states. Or at the very least, if the official manual weren't chock full of errors &gt;_&lt;<br /><br />&gt; You pretty much have to handle the internal cycles separately from the memory-accessing cycles, because some (many) instructions have an internal T-state or two on their first cycle, and you can't tell that until you've decoded the instruction!<br /><br />Given that internally, all read/write/in/out/wait calls advance the CPU time, and can thus cause a context switch, it may be a good micro-optimization to have something like read&lt;5&gt;(addr) instead of read(addr), wait(2). But the cycle timing could end up wrong if the wait(2) isn't in the correct location. I don't know if all T-states do the bus operation at the start, and the I/O stuff at the end or not.<br /><br />Probably not a good idea to micro-optimize. The Z80 shouldn't be a bottleneck in the Mega Drive nor Master System.<br /><br />...<br /><br />EDIT: I assume OUTI, OUTD are correct at 4,5,3,4 then. Since it's read+out at the end.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Tue Nov 01, 2016 3:12 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Okay, implemented every instruction on the Z80. Have a few more questions, of course.<br /><br /><strong>RETI, RETN</strong><br /><br />I understand that RETI is a specialized version of RET that somehow signals to external hardware that it occurred. For the sake of the Master System and/or Mega Drive, do I need to do any kind of special handling for this, or can I just treat it like RET?<br /><br />And on that note, RETN is just RET + IFF1=IFF2, right?<br /><br /><strong>ED 77, ED 7F</strong><br /><br />Are these instructions NOP (as per z80-documented.pdf), or LD I,I and LD R,R (as per <!-- m --><a class="postlink" href="http://www.z80.info/z80oplist.txt">http://www.z80.info/z80oplist.txt</a><!-- m -->) ? This matters as there's (presumably) an extra cycle penalty on the latter.<br /><br /><strong>LD (I,A;A,I;A,R;R,A)</strong><br /><br />The manual states the T-cycles for these are T(4,5). I really would have expected this one to be T(4,4).<br /><br />Is there really an extra cycle here?<br /><br />Also, the manual says that &quot;LD A,I&quot;; &quot;LD A,R&quot;; set flags. I could understand that adding an extra cycle penalty. But &quot;LD I,A&quot;; &quot;LD R,A&quot; do not set flags and still (supposedly) have the extra cycle penalty?<br /><br /><strong>DAA</strong><br /><br />These algorithms are always brutally difficult to get correct. I remember VBA using a lookup table for the Game Boy DAA instruction, <em>and still getting the wrong results!</em> (the table itself had bad values in it.)<br /><br />Wasn't able to use my LR35902 implementation (known to be correct per blargg), because it's missing a lot of the flag values and said CPU doesn't have the N flag that affects the computation.<br /><br />So my implementation was based off <a href="https://sourceforge.net/p/dgen/dgen/ci/a6f61a594b996840110a6c4bc0347a9d8e4f81e7/tree/cz80/cz80_op.inc" class="postlink">CZ80</a> ... is this algorithm known to be correct or incorrect?<br /><br />Specifically, this is what I came up with in adapting said code:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">auto Z80::instructionDAA() -&gt; void {<br />&nbsp; uint8 lo = A.bits(0,3);<br />&nbsp; uint8 hi = A.bits(4,7);<br />&nbsp; uint8 diff;<br /><br />&nbsp; if(CF) {<br />&nbsp; &nbsp; diff = lo &lt;= 9 &amp;&amp; !HF ? 0x60 : 0x66;<br />&nbsp; } else if(lo &gt;= 10) {<br />&nbsp; &nbsp; diff = hi &lt;= 8 ? 0x06 : 0x66;<br />&nbsp; } else if(hi &gt;= 10) {<br />&nbsp; &nbsp; diff = HF ? 0x66 : 0x60;<br />&nbsp; } else {<br />&nbsp; &nbsp; diff = HF ? 0x06 : 0x00;<br />&nbsp; }<br /><br />&nbsp; if(NF == 0) A += diff;<br />&nbsp; if(NF == 1) A -= diff;<br /><br />&nbsp; CF = CF || (lo &lt;= 9 ? hi &gt;= 10 : hi &gt;= 9);<br />&nbsp; PF = parity(A);<br />&nbsp; XF = A.bit(3);<br />&nbsp; HF = NF ? (HF &amp;&amp; lo &lt;= 5) : (lo &gt;= 10);<br />&nbsp; YF = A.bit(5);<br />&nbsp; ZF = A == 0;<br />&nbsp; SF = A.bit(7);<br />}</div><br /><br />If that works, it's a very clever way to implement it. But it's highly unusual looking to me.<br /><br /><strong>16-bit arithmetic</strong><br /><br />I'd rather be a bit lazy and reuse the existing 8-bit ADD/SUB functions if possible.<br />99% sure this is fine, but just to be certain, it's okay if I implement these like so, correct?<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">auto Z80::instructionADC_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = ADD(HL &gt;&gt; 0, x &gt;&gt; 0, CF);<br />&nbsp; wait(3);<br />&nbsp; auto hi = ADD(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}<br /><br />auto Z80::instructionADD_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = ADD(HL &gt;&gt; 0, x &gt;&gt; 0);<br />&nbsp; wait(3);<br />&nbsp; auto hi = ADD(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}<br /><br />auto Z80::instructionSBC_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = SUB(HL &gt;&gt; 0, x &gt;&gt; 0, CF);<br />&nbsp; wait(3);<br />&nbsp; auto hi = SUB(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}</div><br /><br /><strong>RLD / RRD</strong><br /><br />It was easy enough to see what these were doing via CZ80, but ... what the hell are these useful for? &gt;_&gt;<br /><br /><strong>Testing</strong><br /><br />Last question, are there any good stress-testing modules for a Z80 core that don't require a working Master System VDP core? If I have to go my usual route (compare my trace logs to Mednafen's), I can do that, but I'd rather save time on the inevitable weeks of debugging a new CPU core.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>mic_</b> [ Tue Nov 01, 2016 4:22 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt;what the hell are these useful for? &gt;_&gt;<br /><br />I found some use for RLD when I was writing some code to read a sector of data from an SD card one nybble at a time:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Read to RAM/SRAM<br />;<br />; 46.625 cycles/byte<br />;<br />; In:<br />;&nbsp; &nbsp;HL = buf<br />neo2_recv_sd:<br />&nbsp; &nbsp; &nbsp; &nbsp; ld&nbsp; &nbsp; &nbsp; b,#64<br />&nbsp; &nbsp; &nbsp; &nbsp; ld&nbsp; &nbsp; &nbsp; de,#MYTH_NEO2_RD_DAT4<br />&nbsp; &nbsp; &nbsp; &nbsp; ; Read one sector (512 bytes)<br />1$:<br />&nbsp; &nbsp; &nbsp; &nbsp; ld&nbsp; &nbsp; &nbsp; a,(de)&nbsp; &nbsp;; 7<br />&nbsp; &nbsp; &nbsp; &nbsp; ld&nbsp; &nbsp; &nbsp; (hl),a&nbsp; &nbsp;; 7<br />&nbsp; &nbsp; &nbsp; &nbsp; ld&nbsp; &nbsp; &nbsp; a,(de)&nbsp; &nbsp;; 7<br />&nbsp; &nbsp; &nbsp; &nbsp; rld&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 18.&nbsp; (hl) = (hl)&lt;&lt;4 + a&amp;0x0F<br />&nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp; &nbsp;hl&nbsp; &nbsp; &nbsp; &nbsp;; 6<br />; 2nd byte<br />&nbsp; &nbsp; &nbsp; &nbsp;same as for byte 1. Unrolled 8 times.<br />&nbsp; &nbsp; &nbsp; &nbsp;....<br /></div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Tue Nov 01, 2016 7:22 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Wow, the card reads nybbles into RAM, with the top four bits unused in each byte?<br /><br />Yeah, that would be a perfect use case for RLD. But, guessing they weren't anticipating SD cards back then :P<br /><br />It actually would've been a pretty amazing opcode for serial if it were (hl)=(hl)&lt;&lt;1|a&amp;1 instead. RRD as well in case the bits were in the other order.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Stef</b> [ Tue Nov 01, 2016 2:51 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent"><strong>RETI, RETN</strong><br /><br />I understand that RETI is a specialized version of RET that somehow signals to external hardware that it occurred. For the sake of the Master System and/or Mega Drive, do I need to do any kind of special handling for this, or can I just treat it like RET?<br /><br />And on that note, RETN is just RET + IFF1=IFF2, right?<br /></div><br /><br />If you don't plan to emulate back signal from RETI (which is indeed not needed in case of the Sega Megadrive) then RETI = RETN<br />They both do IFF1 = IFF2 while RET doesn't.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><strong>DAA</strong><br /><br />These algorithms are always brutally difficult to get correct. I remember VBA using a lookup table for the Game Boy DAA instruction, <em>and still getting the wrong results!</em> (the table itself had bad values in it.)<br /><br />Wasn't able to use my LR35902 implementation (known to be correct per blargg), because it's missing a lot of the flag values and said CPU doesn't have the N flag that affects the computation.<br /><br />So my implementation was based off <a href="https://sourceforge.net/p/dgen/dgen/ci/a6f61a594b996840110a6c4bc0347a9d8e4f81e7/tree/cz80/cz80_op.inc" class="postlink">CZ80</a> ... is this algorithm known to be correct or incorrect?<br /><br />...<br /><br />If that works, it's a very clever way to implement it. But it's highly unusual looking to me.<br /></div><br /><br />I wrote CZ80 very quickly and only made one bugfixe update to it (first version was 0.90, and that is the 0.91), i'm almost certain it still has some bugs so i wouldn't trust it too much :-/<br />To be honest i don't even remember from where i get that implementation, i guess it was by reading and analyzing what was doing the DAA instruction or maybe from the small z80-documented.pdf file. The reason i used that code was to reduce code size, I mainly wrote CZ80 to provide a fast and (hopefully :p) accurate Z80 C core that i could use on Dreamcast (where code size matter a lot for better cache use).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><strong>16-bit arithmetic</strong><br /><br />I'd rather be a bit lazy and reuse the existing 8-bit ADD/SUB functions if possible.<br />99% sure this is fine, but just to be certain, it's okay if I implement these like so, correct?<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">auto Z80::instructionADC_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = ADD(HL &gt;&gt; 0, x &gt;&gt; 0, CF);<br />&nbsp; wait(3);<br />&nbsp; auto hi = ADD(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}<br /><br />auto Z80::instructionADD_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = ADD(HL &gt;&gt; 0, x &gt;&gt; 0);<br />&nbsp; wait(3);<br />&nbsp; auto hi = ADD(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}<br /><br />auto Z80::instructionSBC_hl_rr(uint16&amp; x) -&gt; void {<br />&nbsp; wait(4);<br />&nbsp; auto lo = SUB(HL &gt;&gt; 0, x &gt;&gt; 0, CF);<br />&nbsp; wait(3);<br />&nbsp; auto hi = SUB(HL &gt;&gt; 8, x &gt;&gt; 8, CF);<br />&nbsp; HL = hi &lt;&lt; 8 | lo &lt;&lt; 0;<br />&nbsp; ZF = HL == 0;<br />}</div><br /></div><br /><br />I would say the arithmetic is correct, but be careful about the FLAG calculation. Strangely enough Z is not affected by 16 bits ADD, nor are S and P bit, they are only affected by 16 bits ADC/SBC. Also N is cleared *even* for SBC...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>AWJ</b> [ Tue Nov 01, 2016 4:38 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />The bus traces I've been quoting are here:<br /><br /><!-- m --><a class="postlink" href="http://baltazarstudios.com/zilog-z80-undocumented-behavior/">http://baltazarstudios.com/zilog-z80-un ... -behavior/</a><!-- m --><br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent"><strong>LD (I,A;A,I;A,R;R,A)</strong><br /><br />The manual states the T-cycles for these are T(4,5). I really would have expected this one to be T(4,4).<br /><br />Is there really an extra cycle here?</div><br /><br />Yes, there really is an extra T-state for all I/R moves. The pipeline stall probably has nothing to do with flags; it's more likely because R has to be incremented on every M1 cycle (opcode fetch), and therefore the next opcode fetch can't happen until the register move is complete (unlike normal register-register moves, which can be overlapped with the next opcode fetch)<br /><br />The reason moves to/from I incur the stall (and not just moves to/from R) is that internally IR is a single 16-bit register, with I in the upper half and R in the lower half.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><strong>DAA</strong><br /><br />These algorithms are always brutally difficult to get correct. I remember VBA using a lookup table for the Game Boy DAA instruction, <em>and still getting the wrong results!</em> (the table itself had bad values in it.)<br /><br />Wasn't able to use my LR35902 implementation (known to be correct per blargg), because it's missing a lot of the flag values and said CPU doesn't have the N flag that affects the computation.</div><br /><br />DAA is different between the LR35902 and the Z80 even apart from the Z80's additional flags. One difference (not the only one) is that on the LR35902 the upper and lower nybbles of A only affect the result of an adjust-after-add (NF == 0), but on the Z80 they affect both adjust-after-add and adjust-after-subtract.<br /><br />In fact, I believe the problem with the table VBA used was that it was correct for the Z80 rather than the LR35902.<br /><br />Here's my algorithm for Z80 DAA, which should be equivalent to the one you quoted, and a fair bit simpler and easier to understand:<br /><br />(Edit: Simplified by doing the adjusts directly on A, taking advantage of the fact that the upper nybble adjust doesn't affect the test for the lower nybble adjust. Note that the converse is <em>not</em> true; the lower nybble adjust would mess up the upper nybble test if you did it first, so don't change the order of the first two lines!)<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">uint oldA = A; // save the previous value of A to calculate HF with<br /><br />if (CF || (A &gt; 0x99)) { A += (NF ? -0x60 : 0x60); CF = 1; } // if carry set or A &gt; BCD 99, adjust upper nybble and set carry<br />if (HF || (A.bits(0,3) &gt; 9)) { A += (NF ? -6 : 6); }&nbsp; &nbsp; &nbsp; &nbsp; // if half-carry set or lower nybble &gt; 9, adjust lower nybble<br /><br />HF = (A ^ oldA).bit(4); // half-carry is set if bit 4 changed, otherwise cleared<br /><br />// the rest of the flags are set the usual way for an ALU operation (except that PF is parity, rather than overflow like you'd expect...)<br />// note that unlike the LR35902, NF is preserved<br />PF = parity(A);<br />XF = A.bit(3);<br />YF = A.bit(5);<br />ZF = A == 0;<br />SF = A.bit(7);</div><br /><br />Here's a side-by-side tester I whipped up in Python, omitting flag calculations that depend solely on the resulting value of A. It passes, but someone should double-check my translation of byuu's algorithm (and mine) from nalled C++ to Python:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!/usr/bin/python3<br /><br />def mydaa(A, CF, HF, NF):<br />&nbsp; &nbsp; oldA = A<br />&nbsp; &nbsp; if CF or A &gt; 0x99:<br />&nbsp; &nbsp; &nbsp; &nbsp; A += -0x60 if NF else 0x60<br />&nbsp; &nbsp; &nbsp; &nbsp; CF = True<br />&nbsp; &nbsp; if HF or A &amp; 0xf &gt; 9:<br />&nbsp; &nbsp; &nbsp; &nbsp; A += -6 if NF else 6<br /><br />&nbsp; &nbsp; HF = bool((A ^ oldA) &amp; 0x10)<br /><br />&nbsp; &nbsp; return A, CF, HF<br /><br /><br />def byuudaa(A, CF, HF, NF):<br />&nbsp; &nbsp; lo, hi = A &amp; 0xf, A &gt;&gt; 4<br /><br />&nbsp; &nbsp; if CF:<br />&nbsp; &nbsp; &nbsp; &nbsp; diff = 0x66 if HF or lo &gt; 9 else 0x60<br />&nbsp; &nbsp; elif lo &gt;= 10:<br />&nbsp; &nbsp; &nbsp; &nbsp; diff = 0x66 if hi &gt; 8 else 0x06<br />&nbsp; &nbsp; elif hi &gt;= 10:<br />&nbsp; &nbsp; &nbsp; &nbsp; diff = 0x66 if HF else 0x60<br />&nbsp; &nbsp; else:<br />&nbsp; &nbsp; &nbsp; &nbsp; diff = 0x06 if HF else 0<br /><br />&nbsp; &nbsp; A = A - diff if NF else A + diff<br /><br />&nbsp; &nbsp; CF = CF or (hi &gt;= (10 if lo &lt;= 9 else 9))<br />&nbsp; &nbsp; HF = (HF and lo &lt;= 5) if NF else (lo &gt;= 10)<br /><br />&nbsp; &nbsp; return A, CF, HF<br /><br />myresult = &#91;(A, CF, HF, NF, mydaa(A, CF, HF, NF))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for A in range(256)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for CF in (False, True)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for HF in (False, True)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for NF in (False, True)&#93;<br /><br />byuuresult = &#91;(A, CF, HF, NF, byuudaa(A, CF, HF, NF))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for A in range(256)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for CF in (False, True)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for HF in (False, True)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for NF in (False, True)&#93;<br /><br />passed = True<br />for mine, byuu in zip(myresult, byuuresult):<br />&nbsp; &nbsp; if mine != byuu:<br />&nbsp; &nbsp; &nbsp; &nbsp; print(&quot;mine: &quot; + repr(mine))<br />&nbsp; &nbsp; &nbsp; &nbsp; print(&quot;byuu: &quot; + repr(byuu))<br />&nbsp; &nbsp; &nbsp; &nbsp; passed = False<br /><br />if passed:<br />&nbsp; &nbsp; print(&quot;Passed&quot;)<br /></div><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><strong>RLD / RRD</strong><br /><br />It was easy enough to see what these were doing via CZ80, but ... what the hell are these useful for? &gt;_&gt;</div><br /><br />Just like the LR35902 SWAP instruction, they're useful for working with nybble-sized data (e.g. BCD decimal numbers).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Thu Jan 05, 2017 10:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Okay, I think this is the most evil one yet.<br /><br /><img src="http://i.imgur.com/ECTjLvd.png" alt="Image" /><br /><br />So in this case the M cycles / T states break down like so:<br /><br />[1] 4 =&gt; read 0xDD prefix (or 0xFD prefix)<br />[2] 4 =&gt; read 0xCB prefix<br />[3] 3 =&gt; read int8 displacement byte<br />[4] 5 =&gt; compute (IX,IY)+displacement<br />[5] 4 =&gt; read opcode identifier<br />[6] 4 =&gt; read from (IX,IY)+displacement and RLC it (extra cycle penalty for the RLC operation)<br />[7] 3 =&gt; write RLC'd value to (IX,IY)+displacement<br /><br />That's seven cycles, not six.<br /><br />Every instance ever of (IX,IY)+displacement consumes the two 3,5 T states.<br /><br />It looks like the documentation is acting as though you can read the opcode identifier at the same time as doing the wait(5) computation for (IX,IY)+displacement.<br /><br />Or is the documentation wrong here?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>AWJ</b> [ Thu Jan 12, 2017 7:07 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">Okay, I think this is the most evil one yet.<br /><br /><img src="http://i.imgur.com/ECTjLvd.png" alt="Image" /><br /><br />So in this case the M cycles / T states break down like so:<br /><br />[1] 4 =&gt; read 0xDD prefix (or 0xFD prefix)<br />[2] 4 =&gt; read 0xCB prefix<br />[3] 3 =&gt; read int8 displacement byte<br />[4] 5 =&gt; compute (IX,IY)+displacement<br />[5] 4 =&gt; read opcode identifier<br />[6] 4 =&gt; read from (IX,IY)+displacement and RLC it (extra cycle penalty for the RLC operation)<br />[7] 3 =&gt; write RLC'd value to (IX,IY)+displacement<br /><br />That's seven cycles, not six.<br /><br />Every instance ever of (IX,IY)+displacement consumes the two 3,5 T states.<br /><br />It looks like the documentation is acting as though you can read the opcode identifier at the same time as doing the wait(5) computation for (IX,IY)+displacement.</div><br /><br />Yes, that's exactly what the Z80 does. The displacement calculation occurs in parallel with the sub-opcode fetch. That's why instructions with both a DD/FD prefix and a CB prefix are encoded &quot;out of order&quot;, with the displacement coming before the sub-opcode. Index+displacement instructions that only have the DD/FD prefix have no useful work that can be done while the ALU is calculating the effective address, but instructions with both prefixes are a bit more efficient thanks to the funny encoding (though they're still among the slowest instructions in the Z80 instruction set--perhaps &quot;closer to memory-bound&quot; is a better term than &quot;efficient&quot;)<br /><br />Note that for the double-prefixed instructions, the bus signals and timing for the sub-opcode fetch cycle are the same as an <em>operand</em> fetch with two dead T-states after, not an opcode fetch (unlike CB-prefix-only instructions, where the sub-opcode fetch is a real opcode fetch) That also means that the R register isn't incremented for the sub-opcode.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Fri Jan 13, 2017 3:35 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Z80 T-cycle timing: what the hell damn guy?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; That's why instructions with both a DD/FD prefix and a CB prefix are encoded &quot;out of order&quot;, with the displacement coming before the sub-opcode.<br /><br />Oh man, thank you so much for explaining that. I was really racking my brain trying to understand why they went with that design. It completely wrecked my attempts to merge the DD/FD prefixes into the existing opcode tables. I ended up needing an entirely separate DD/FD CB instruction table, and as such had to do the displacement before invoking the individual opcodes due to needing the CB opcode number before I could invoke the appropriate instruction.<br /><br />I'll probably end up doing the same for the regular non-CB/ED instructions since why not at this point? Avoids the messy specialization for (IX,IY+n) conversion that's not needed for regular HL instructions.<br /><br />&gt; That also means that the R register isn't incremented for the sub-opcode.<br /><br />If you don't mind, I do actually have one more interesting question.<br /><br />Turns out the source of a LOT of game bugs was that I was following the Z80 documented undocumented document where it was saying that DD/FD are treated as &quot;separate instructions that set an internal flag&quot;, hence you can easily stack multiple prefixes like DD DD FD DD FD CB ... and it'll &quot;ignore&quot; all but the final FD.<br /><br />But if I do this, and allow interrupts to fire between the prefix and CB opcode, obviously very bad things happen.<br /><br />So ... what happens in a sequence like the above? What if I fill the bus with nothing but 0xDD? (All ROM and all RAM.) Will IRQs and NMIs never fire as a result?

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>3</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>