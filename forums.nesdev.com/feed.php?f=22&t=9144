<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=22&amp;t=9144" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2012-08-23T16:50:20-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=22&amp;t=9144</id>
<entry>
<author><name><![CDATA[Movax12]]></name></author>
<updated>2012-08-11T15:38:59-07:00</updated>
<published>2012-08-11T15:38:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97980#p97980</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97980#p97980"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97980#p97980"><![CDATA[
This isn't hard to change is it? You could have the NMI routine take care of screen updates and split screen and exit and return to the selected engine with the same basic structure. I'm actually working on this right now. This may be a bit much for the OP (not really that complex) but I use something like this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">main_jump_vector:     .res 3 ; 3 bytes for jmp (lo)(hi)<br /><br />.proc reset<br /><br />  standard_init     ;video + sound is off<br />   <br />  set_new_engine_state state_titlescreen     ; initial gamecode pointer<br />   <br />  set_PPU_CTRL CR_NMI,1     ; Turn on NMI before MainLoop, never turn it off (video still off)<br />   <br />  Mainloop: <br /><br />   : bit NMIhit      ; Wait for a  <br />   bpl :-         ; NMI to occur<br />   clrflag NMIhit    ; before proceeding<br />      <br />   jsr main_jump_vector<br />      <br /> jmp Mainloop ;} <br />   <br />   <br />.endproc<br /><br />; -----------------------------------------------<br /><br />.proc   state_titlescreen<br />   &#91;do stuff, then:&#93;<br />   set_new_engine_state state_readyscreen<br />   rts<br />.endproc<br /><br />.proc   state_readyscreen<br />   &#91;do stuff, then:&#93;<br />   set_new_engine_state state_gameplay<br />   rts<br />.endproc<br /><br /><br />.proc   state_gameplay<br />   &#91;do stuff, then:&#93;   <br />   set_new_engine_state state_gameover   <br />   rts<br />.endproc<br /><br /><br /><br />.proc   state_gameover<br />        &#91;do stuff, then:&#93;   <br />   set_new_engine_state state_titlescreen<br />   rts<br />.endproc<br /><br />;----------------------<br /><br /><br />.macro set_new_engine_state engine_state<br />   <br />   lda #_RTS_<br />   sta main_jump_vector<br />   lda #&lt;(engine_state)<br />   sta main_jump_vector+1<br />   lda #&gt;(engine_state)<br />   sta main_jump_vector+2<br />   lda #_JMP_<br />   sta main_jump_vector<br />   <br />.endmacro<br /></div><br /><br />I am working on it now, but I have decided that every engine should expect rendering to be off when started and should turn it off before changing to a new state - but no changes are made directly - nothing happens to the PPU side of the NES until NMI - it updates all changes based on flags marking data that is ready.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4680">Movax12</a> — Sat Aug 11, 2012 3:38 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2012-08-11T09:02:05-07:00</updated>
<published>2012-08-11T09:02:05-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97959#p97959</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97959#p97959"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97959#p97959"><![CDATA[
That is indeed the most straightforward way to make use of NMIs, but like tepples said, it might screw up raster effects (i.e. mid-screen changes to the scroll, palettes, etc.) in case your frame logic takes longer than the time of a NES frame (in most games that happens only when lots of objects are active at the same time). If you are sure your frame calculations will never take too long to finish (usually the case of most puzzle games and games with little variation in the number of on-screen objects), that NMI solution is safe to use.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sat Aug 11, 2012 9:02 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2012-08-10T15:06:44-07:00</updated>
<published>2012-08-10T15:06:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97936#p97936</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97936#p97936"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97936#p97936"><![CDATA[
The solution that 3gengames gave works, and I use it in my own games. But it'll run into flicker problems once you start doing raster effects, such as scrolling with a still status bar.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Fri Aug 10, 2012 3:06 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[3gengames]]></name></author>
<updated>2012-08-10T14:05:21-07:00</updated>
<published>2012-08-10T14:05:21-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97934#p97934</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97934#p97934"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97934#p97934"><![CDATA[
NMI:<br />  INC Frame<br />RTI:<br />  RTI<br /><br />WaitForNMI:<br />  LDA Frame<br />.Loop:<br />  CMP Frame<br />  BEQ .Loop<br />  RTS<br /><br />....somewhere in your game<br />Engine:<br />JSR WaitForNMI<br />...other stuff...<br />JMP Engine.<br /><br /><br />And just make as many &quot;engines&quot; as needed but remember the PPU code and stuff has to go in each one and might not all be the same.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4311">3gengames</a> — Fri Aug 10, 2012 2:05 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2012-08-10T12:08:52-07:00</updated>
<published>2012-08-10T12:08:52-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97929#p97929</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97929#p97929"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97929#p97929"><![CDATA[
By &quot;NMI switching&quot; do you refer to having multiple NMI handlers?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Fri Aug 10, 2012 12:08 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DC]]></name></author>
<updated>2012-08-10T12:03:32-07:00</updated>
<published>2012-08-10T12:03:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97928#p97928</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97928#p97928"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97928#p97928"><![CDATA[
Ok thanks. My brain wanted to subtract :/. Hey 3gengames can you post an example of nmi switching?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5381">DC</a> — Fri Aug 10, 2012 12:03 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Movax12]]></name></author>
<updated>2012-08-10T15:57:21-07:00</updated>
<published>2012-08-10T09:53:24-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97921#p97921</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97921#p97921"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97921#p97921"><![CDATA[
When learning binary most people learn the weight of the bits in decimal:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">01010101<br /><br />128, 64,  32, 16, 8, 4, 2, 1<br />  0  1    0    1  0  1  0  1 = 64 + 16 + 4 + 1 = 85<br /></div><br /><br />With a signed byte you can think of the 7th bit (on the left end) as a value of -128<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">11010101<br /><br />128, 64, 32, 16, 8, 4, 2, 1<br />  1   1   0  1  0   1  0  1 = -128 + 64 + 16 + 4 + 1 = -43<br /></div><br /><br /><br />So -1 is 11111111 (-128 + 127 = -1)<br /><br />edit: That was maybe a bit confusing, fixed<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4680">Movax12</a> — Fri Aug 10, 2012 9:53 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[3gengames]]></name></author>
<updated>2012-08-10T09:13:09-07:00</updated>
<published>2012-08-10T09:13:09-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97917#p97917</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97917#p97917"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97917#p97917"><![CDATA[
#%00000001=1<br /><br />When you reverse the bits to make it -1...<br /><br />#%00000001=FE=-2.<br /><br />So you add 1 to correct it.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4311">3gengames</a> — Fri Aug 10, 2012 9:13 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DC]]></name></author>
<updated>2012-08-10T08:53:51-07:00</updated>
<published>2012-08-10T08:53:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97913#p97913</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97913#p97913"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97913#p97913"><![CDATA[
Why do you have to add after you invert the bits?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5381">DC</a> — Fri Aug 10, 2012 8:53 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Movax12]]></name></author>
<updated>2012-08-06T22:29:07-07:00</updated>
<published>2012-08-06T22:29:07-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97720#p97720</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97720#p97720"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97720#p97720"><![CDATA[
I'm not sure if bunnyboy didn't want to teach signed numbers for a reason, but you would be a lot better of using signed values for moving the ball. You could reduce the size and complexity of the code that changes the ball's position:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />MoveBall:         ;this routine simply moves that ball<br />   lda balldirection   ;ball direction is now 1 byte, bit 0 is the X direction, bit 1 is the y direction (way more efficent)<br />   and #%00000001      ;teste the x direction (0 for right, 1 for left)<br />   bne BallMoveRight<br />   lda ballx      ;moves the ball accordingly<br />   clc<br />   adc ballspeedx<br />   sta ballx<br />   jmp CheckBallY      ;afterwards ckeck the y direction<br />BallMoveRight:         ;same as above but in the other direction<br />   lda ballx<br />   sec<br />   sbc ballspeedx<br />   sta ballx<br />CheckBallY:         ;same as above but for Y<br />   lda balldirection   <br />   and #%00000010      ;checks the y direction (bit 0 for down, bit 1 for up)<br />   bne BallMoveUp<br />   lda bally<br />   clc<br />   adc ballspeedy<br />   sta bally<br />   jmp MoveBallDone<br />BallMoveUp:         <br />   lda bally<br />   sec<br />   sbc ballspeedy<br />   sta bally<br />MoveBallDone:   <br />   rts<br /></div><br />Could be:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">MoveBall:         ;this routine simply moves that ball<br />   lda ballx      ;moves the ball accordingly<br />   clc<br />   adc ballspeedx<br />   sta ballx<br />   lda bally<br />   clc<br />   adc ballspeedy<br />   sta bally<br />   rts<br /></div><br /><br />But you would have to change the code that checks collisions:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />CheckBallCollision:      ;this checks the four sides of the screen<br />   lda bally<br />   cmp #TOPWALL      ;checks the top wall (similar to the paddles)<br />   bcs CheckBottomWall<br />   lda #TOPWALL      ;fixes the ball's y position to the edge of the wall <br />   sta bally<br />   lda ballspeedy<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedy<br />   jmp CheckLeftWall<br />CheckBottomWall:<br />   cmp #BOTTOMWALL-8   ;same as top wall<br />   bcc CheckLeftWall<br />   lda #BOTTOMWALL-8<br />   sta bally<br />   lda ballspeedy<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedy<br />CheckLeftWall:         ;checks the side wall<br />   lda ballx<br />   cmp #LEFTWALL<br />   bcs CheckRightWall<br />   jsr IncrementScore2   ;if it hit the wall, increase the score<br />   lda #$80      ;then rest the ball's position<br />   sta ballx<br />   sta bally<br />   lda ballspeedx<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedx<br />   rts<br />CheckRightWall:         ;same as left wall<br />   cmp #RIGHTWALL<br />   bcc CheckBallCollisionDone<br />   jsr IncrementScore1<br />   lda #$80<br />   sta ballx<br />   sta bally<br />   lda ballspeedx<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedx<br />CheckBallCollisionDone:<br />   rts<br /><br />CheckPaddleCollision:      ;this checks if the ball hit a paddle<br />   lda ballx<br />   cmp #PADDLE1X+8      ;test if the ballx is within the paddle area<br />   bcs CheckOtherPaddle<br />   lda paddle1y      ;if so, test if bally is within the paddle's top coordinate<br />   sec<br />   sbc #$08      ;the sub 8 is to ensure that the bottom of the ball collides with the top of the paddle<br />   cmp bally<br />   bcs CheckOtherPaddle   ;if this fails go test the other paddle<br />   lda paddle1y<br />   clc<br />   adc #PADDLELENGTH   ;this tests the bottom of the paddle (16 is added to ensure that the top of the ball collides with the bottom of the paddle<br />   cmp bally<br />   bcc CheckOtherPaddle<br />   lda ballspeedx<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedx<br />   lda #PADDLE1X+8      ;and fix ballx to the edge of the paddle (otherwise causes wierd glitches)<br />   sta ballx<br />CheckOtherPaddle:      ;same as paddle 1<br />   lda ballx<br />   cmp #PADDLE2X-8<br />   bcc SkipCollision<br />   lda paddle2y<br />   sec<br />   sbc #$08<br />   cmp bally<br />   bcs SkipCollision<br />   lda paddle2y<br />   clc<br />   adc #PADDLELENGTH<br />   cmp bally<br />   bcc SkipCollision<br />   lda ballspeedx<br />   clc         ;negate ballspeed<br />   eor #$FF           ;Invert all the bits<br />   adc #1   <br />   sta ballspeedx<br />   lda #PADDLE2X-8<br />   sta ballx<br />SkipCollision:   <br />   rts<br /></div><br /><br />You no longer need balldirection either I don't think. Google &quot;two's complement&quot; if you don't understand the changes.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4680">Movax12</a> — Mon Aug 06, 2012 10:29 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DC]]></name></author>
<updated>2012-08-23T16:50:20-07:00</updated>
<published>2012-08-05T11:31:50-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97673#p97673</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97673#p97673"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97673#p97673"><![CDATA[
Thanks lazigamer I noticed I had a bit of unnecessary code in the checking scoring system. This will be helpful for future reference. Please do post 3gengames.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5381">DC</a> — Sun Aug 05, 2012 11:31 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[3gengames]]></name></author>
<updated>2012-08-04T20:27:30-07:00</updated>
<published>2012-08-04T20:27:30-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97615#p97615</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97615#p97615"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97615#p97615"><![CDATA[
<div class="codetitle"><b>Code:</b></div><div class="codecontent">.org $E000<br />.org $FFFA</div><br /><br />That does nothing.<br /><br />And you missed the biggest coding optimization of them all. Take all the NMI out of the NMI so replacing different NMI engines of your game is actually easy.. If you need example program I can show you.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4311">3gengames</a> — Sat Aug 04, 2012 8:27 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lazigamer]]></name></author>
<updated>2012-08-04T19:11:40-07:00</updated>
<published>2012-08-04T19:11:40-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97607#p97607</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97607#p97607"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97607#p97607"><![CDATA[
After looking through your code I figured that i should optimize it as much as possible. That way you can look through it and see what kind of optimizations can be done and compare it to your original code.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  .inesprg 1   ; 1x 16KB PRG code<br />  .ineschr 1   ; 1x  8KB CHR data<br />  .inesmap 0   ; mapper 0 = NROM, no bank swapping<br />  .inesmir 1   ; background mirroring<br />  <br />  <br /><br />;;;;;;;;;;;;;;;<br /><br />;; DECLARE SOME VARIABLES HERE<br />  .rsset $0000  ;;start variables at ram location 0<br />  <br />gamestate  .rs 1  ; .rs 1 means reserve one byte of space<br />ballx      .rs 1  ; ball horizontal position<br />bally      .rs 1  ; ball vertical position<br />balldirection   .rs 1 ;direction the ball moves<br />ballspeedx .rs 1  ; ball horizontal speed per frame<br />ballspeedy .rs 1  ; ball vertical speed per frame<br />paddle1y      .rs 1  ; paddle vertical position<br />paddle2y      .rs 1  ; paddle vertical position<br />buttons1   .rs 1  ; player 1 gamepad buttons, one bit per button<br />buttons2   .rs 1  ; player 2 gamepad buttons, one bit per button<br />scoreOnes     .rs 1  ; byte for each digit in the decimal score<br />scoreTens     .rs 1<br />scoreHundreds .rs 1<br />scoreOnes2     .rs 1  ; byte for each digit in the decimal score<br />scoreTens2     .rs 1<br />scoreHundreds2 .rs 1<br /><br /><br />;; DECLARE SOME CONSTANTS HERE<br />STATETITLE     = $00  ; displaying title screen<br />STATEPLAYING   = $01  ; move paddles/ball, check for collisions<br />STATEGAMEOVER  = $02  ; displaying game over screen<br />  <br />RIGHTWALL      = $F4  ; when ball reaches one of these, do something<br />TOPWALL        = $20<br />BOTTOMWALL     = $E0<br />LEFTWALL       = $04<br />  <br />PADDLE1X       = $08  ; horizontal position for paddles, doesnt move<br />PADDLE2X       = $F0<br />PADDLESPEED   = $04<br />PADDLELENGTH    = $10<br />INITALBALLSPEED = $02<br /><br />A_BUTTON = %10000000<br />B_BUTTON = %01000000<br />SELECT_BUTTON = %00100000<br />START_BUTTON = %00010000<br />UP_BUTTON = %00001000<br />DOWN_BUTTON = %00000100<br />LEFT_BUTTON = %00000010<br />RIGHT_BUTTON = %00000001<br />;;;;;;;;;;;;;;;;;;<br /><br />  .bank 0<br />  .org $C000 <br />RESET:<br />  SEI          ; disable IRQs<br />  CLD          ; disable decimal mode<br />  LDX #$40<br />  STX $4017    ; disable APU frame IRQ<br />  LDX #$FF<br />  TXS          ; Set up stack<br />  INX          ; now X = 0<br />  STX $2000    ; disable NMI<br />  STX $2001    ; disable rendering<br />  STX $4010    ; disable DMC IRQs<br /><br />clrmem:<br />  LDA #$00<br />  STA $0000, x<br />  STA $0100, x<br />  STA $0300, x<br />  STA $0400, x<br />  STA $0500, x<br />  STA $0600, x<br />  STA $0700, x<br />  LDA #$FE<br />  STA $0200, x<br />  INX<br />  BNE clrmem<br /><br />vblankwait1:       ; First wait for vblank to make sure PPU is ready<br />  BIT $2002<br />  BPL vblankwait1   <br />vblankwait2:      ; Second wait for vblank, PPU is ready after this<br />  BIT $2002<br />  BPL vblankwait2<br /><br /><br />LoadPalettes:<br />  LDA $2002             ; read PPU status to reset the high/low latch<br />  LDA #$3F<br />  STA $2006             ; write the high byte of $3F00 address<br />  LDA #$00<br />  STA $2006             ; write the low byte of $3F00 address<br />  LDX #$00              ; start out at 0<br />LoadPalettesLoop:<br />  LDA palette, x        ; load data from address (palette + the value in x)<br />  STA $2007             ; write to PPU<br />  INX                   ; X = X + 1<br />  CPX #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites<br />  BNE LoadPalettesLoop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero<br /><br />ClearNametable:      ;writes #$24 to the nametable 1024 times to make a clear screen<br />  LDX #$00      ;X is for the first loop<br />  LDY #$04      ;Y is for the second loop<br />  LDA $2002<br />  LDA #$20<br />  STA $2006<br />  LDA #$00<br />  STA $2006      ;set PPU to $2000<br />  LDA #$24<br />ClearNametableLoop:<br />  STA $2007      ;store the value<br />  INX<br />  BNE ClearNametableLoop ;this loop runs 256 times<br />  DEY<br />  BNE ClearNametableLoop ;this loop runs 4 times<br /><br />  LDA #$50              ;Set some initial ball stats<br />  STA bally  <br />  LDA #$80<br />  STA ballx<br />  <br />  LDA #INITALBALLSPEED   ;initalize ball speed<br />  STA ballspeedx<br />  STA ballspeedy<br /><br />  LDA #$50      ;initalize paddle positions<br />  STA paddle1y<br />  STA paddle2y<br />  <br />  LDA #STATETITLE   ;Set starting game state<br />  STA gamestate<br />              <br />  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1<br />  STA $2000<br /><br />  LDA #%00011110   ; enable sprites, enable background, no clipping on left side<br />  STA $2001<br /><br />Forever:<br />  JMP Forever     ;jump back to Forever, infinite loop, waiting for NMI<br />  <br /><br />NMI:<br />  LDA #$02<br />  STA $4014       ; set the high byte (02) of the RAM address, start the transfer<br /><br />  JSR DrawScore<br />  JSR DrawScore2<br /><br />  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1<br />  STA $2000<br />  LDA #%00011110   ; enable sprites, enable background, no clipping on left side<br />  STA $2001<br />  LDA #$00        ;;tell the ppu there is no background scrolling<br />  STA $2005<br />  STA $2005<br /><br />  JSR ReadController1  ;;get the current button data for player 1<br />  JSR ReadController2  ;;get the current button data for player 2<br />   <br />GameEngine:        ;Game state selection (later you might want to make each state a subroutine)<br />  LDA gamestate<br />  CMP #STATETITLE<br />  BEQ EngineTitle    ;;game is displaying title screen <br />  CMP #STATEPLAYING<br />  BEQ EnginePlaying   ;;game is playing   <br />  CMP #STATEGAMEOVER<br />  BEQ EngineGameOver  ;;game is displaying ending screen <br />GameEngineDone:<br />  JSR UpdateSprites    ;this is best done every frame<br />  RTI<br /> <br /><br />EngineTitle:    <br />        LDA buttons1      ;checks if start button was pressed<br />        AND #START_BUTTON<br />        BEQ EngineTitleBranch<br />        lda #STATEPLAYING   ;sets new state if pressed<br />   sta gamestate<br />EngineTitleBranch:<br />   jmp GameEngineDone   ;goes back either way<br /><br />EngineGameOver:         ;similar to engine title but will reset values after start is pressed<br />        LDA buttons1<br />        AND #START_BUTTON<br />        BEQ EngineGameOverBranch<br />        lda #STATEPLAYING<br />   sta gamestate<br />   lda #$00 <br />   STA scoreOnes      ;clears scores<br />   STA scoreTens<br />   STA scoreHundreds<br />   STA scoreOnes2<br />   STA scoreTens2<br />   STA scoreHundreds2<br />   LDA #$50      ;resets paddles<br />   STA paddle1y<br />   STA paddle2y<br />EngineGameOverBranch:<br />   jmp GameEngineDone   ;have all of your game states go back to somewhere that the rti triggers<br /><br />EnginePlaying:<br />   jsr MovePaddle1      ;the playing engine<br />   jsr MovePaddle2<br />   jsr MoveBall<br />   jsr CheckBallCollision<br />   jsr CheckPaddleCollision<br />     jmp GameEngineDone<br /><br />MovePaddle1:         ;moves the paddle up or down<br />   lda buttons1<br />   and #UP_BUTTON<br />   beq CheckPaddle1Down   ;check if up button pressed otherwise check down pressed<br />   lda paddle1y      ;subtracts paddlespeed to move it up<br />   sec<br />   sbc #PADDLESPEED<br />   cmp #TOPWALL      ;if it passed through the top wall, fix it to the top wall, otherwise nevermind<br />   bcs Paddle1NotTop<br />   lda #TOPWALL<br />Paddle1NotTop:<br />   sta paddle1y<br />   rts<br />CheckPaddle1Down:<br />   lda buttons1      ;same check as above<br />   and #DOWN_BUTTON<br />   beq CheckPaddle1Done<br />   lda paddle1y      ;moves the paddle down<br />   clc<br />   adc #PADDLESPEED<br />   cmp #BOTTOMWALL-16   ;checks the bottom wall the same way (the -16 is due to the paddles coordinate being at the top of the paddle)<br />   bcc Paddle1NotBottom<br />   lda #BOTTOMWALL-16 <br />Paddle1NotBottom:<br />   sta paddle1y<br />CheckPaddle1Done:   <br />   rts<br /><br />MovePaddle2:         ;this is identical to above but with paddle 2 instead<br />   lda buttons2<br />   and #UP_BUTTON<br />   beq CheckPaddle2Down<br />   lda paddle2y<br />   sec<br />   sbc #PADDLESPEED<br />   cmp #TOPWALL<br />   bcs Paddle2NotTop<br />   lda #TOPWALL<br />Paddle2NotTop:<br />   sta paddle2y<br />   rts<br />CheckPaddle2Down:<br />   lda buttons2<br />   and #DOWN_BUTTON<br />   beq CheckPaddle2Done<br />   lda paddle2y<br />   clc<br />   adc #PADDLESPEED<br />   cmp #BOTTOMWALL-16<br />   bcc Paddle2NotBottom<br />   lda #BOTTOMWALL-16<br />Paddle2NotBottom:<br />   sta paddle2y<br />CheckPaddle2Done:   <br />   rts<br /><br />MoveBall:         ;this routine simply moves that ball<br />   lda balldirection   ;ball direction is now 1 byte, bit 0 is the X direction, bit 1 is the y direction (way more efficent)<br />   and #%00000001      ;teste the x direction (0 for right, 1 for left)<br />   bne BallMoveRight<br />   lda ballx      ;moves the ball accordingly<br />   clc<br />   adc ballspeedx<br />   sta ballx<br />   jmp CheckBallY      ;afterwards ckeck the y direction<br />BallMoveRight:         ;same as above but in the other direction<br />   lda ballx<br />   sec<br />   sbc ballspeedx<br />   sta ballx<br />CheckBallY:         ;same as above but for Y<br />   lda balldirection   <br />   and #%00000010      ;checks the y direction (bit 0 for down, bit 1 for up)<br />   bne BallMoveUp<br />   lda bally<br />   clc<br />   adc ballspeedy<br />   sta bally<br />   jmp MoveBallDone<br />BallMoveUp:         <br />   lda bally<br />   sec<br />   sbc ballspeedy<br />   sta bally<br />MoveBallDone:   <br />   rts<br /><br />CheckBallCollision:      ;this checks the four sides of the screen<br />   lda bally<br />   cmp #TOPWALL      ;checks the top wall (similar to the paddles)<br />   bcs CheckBottomWall<br />   lda #TOPWALL      ;fixes the ball's y position to the edge of the wall <br />   sta bally<br />   lda balldirection<br />   eor #%00000010      ;switches the ball's y direction by toggling the bit<br />   sta balldirection<br />   jmp CheckLeftWall<br />CheckBottomWall:<br />   cmp #BOTTOMWALL-8   ;same as top wall<br />   bcc CheckLeftWall<br />   lda #BOTTOMWALL-8<br />   sta bally<br />   lda balldirection<br />   eor #%00000010<br />   sta balldirection<br />CheckLeftWall:         ;checks the side wall<br />   lda ballx<br />   cmp #LEFTWALL<br />   bcs CheckRightWall<br />   jsr IncrementScore2   ;if it hit the wall, increase the score<br />   lda #$80      ;then rest the ball's position<br />   sta ballx<br />   sta bally<br />   lda balldirection<br />   eor #%00000001      ;and change it's direction<br />   sta balldirection<br />   rts<br />CheckRightWall:         ;same as left wall<br />   cmp #RIGHTWALL<br />   bcc CheckBallCollisionDone<br />   jsr IncrementScore1<br />   lda #$80<br />   sta ballx<br />   sta bally<br />   lda balldirection<br />   eor #%00000001<br />   sta balldirection<br />CheckBallCollisionDone:<br />   rts<br /><br />CheckPaddleCollision:      ;this checks if the ball hit a paddle<br />   lda ballx<br />   cmp #PADDLE1X+8      ;test if the ballx is within the paddle area<br />   bcs CheckOtherPaddle<br />   lda paddle1y      ;if so, test if bally is within the paddle's top coordinate<br />   sec<br />   sbc #$08      ;the sub 8 is to ensure that the bottom of the ball collides with the top of the paddle<br />   cmp bally<br />   bcs CheckOtherPaddle   ;if this fails go test the other paddle<br />   lda paddle1y<br />   clc<br />   adc #PADDLELENGTH   ;this tests the bottom of the paddle (16 is added to ensure that the top of the ball collides with the bottom of the paddle<br />   cmp bally<br />   bcc CheckOtherPaddle<br />   lda balldirection   ;if the tests were sucessful then flip the x direction of the ball<br />   eor #%00000001<br />   sta balldirection<br />   lda #PADDLE1X+8      ;and fix ballx to the edge of the paddle (otherwise causes wierd glitches)<br />   sta ballx<br />CheckOtherPaddle:      ;same as paddle 1<br />   lda ballx<br />   cmp #PADDLE2X-8<br />   bcc SkipCollision<br />   lda paddle2y<br />   sec<br />   sbc #$08<br />   cmp bally<br />   bcs SkipCollision<br />   lda paddle2y<br />   clc<br />   adc #PADDLELENGTH<br />   cmp bally<br />   bcc SkipCollision<br />   lda balldirection<br />   eor #%00000001<br />   sta balldirection<br />   lda #PADDLE2X-8<br />   sta ballx<br />SkipCollision:   <br />   rts<br /><br />UpdateSprites:   ;all sprite update should be done in one pass<br />  LDA bally  ;ball<br />  STA $0200  <br />  LDA #$75<br />  STA $0201  <br />  LDA #$00<br />  STA $0202  <br />  LDA ballx<br />  STA $0203  <br />  LDA paddle1y ;left paddle top tile<br />  STA $0204<br />  LDA #$7F<br />  STA $0205  <br />  LDA #$00<br />  STA $0206 <br />  LDA #PADDLE1X <br />  STA $0207 <br />  LDA paddle1y ;left paddle bottom tile<br />  CLC<br />  ADC #$08     ;Add 8 to put it beneath the other tile<br />  STA $0208<br />  LDA #$7F<br />  STA $0209<br />  LDA #$00<br />  STA $020A<br />  LDA #PADDLE1X<br />  STA $020B<br />  LDA paddle2y ;right paddle top tile<br />  STA $020C<br />  LDA #$7F<br />  STA $020D  <br />  LDA #$00<br />  STA $020E <br />  LDA #PADDLE2X <br />  STA $020F <br />  LDA paddle2y ;right paddle bottom tile<br />  CLC<br />  ADC #$08     ;Add 8 to put it beneath the other tile<br />  STA $0210<br />  LDA #$7F<br />  STA $0211<br />  LDA #$00<br />  STA $0212<br />  LDA #PADDLE2X<br />  STA $0213  <br />  RTS<br /> <br />DrawScore:<br />  LDA $2002<br />  LDA #$20<br />  STA $2006<br />  LDA #$21<br />  STA $2006          ; start drawing the score at PPU $2021 <br />  LDA scoreHundreds<br />  STA $2007<br />  LDA scoreTens<br />  STA $2007<br />  LDA scoreOnes<br />  STA $2007<br />  RTS<br />  <br />DrawScore2:<br />  LDA $2002<br />  LDA #$20<br />  STA $2006<br />  LDA #$3C<br />  STA $2006          ; start drawing the score at PPU $203C<br />  LDA scoreHundreds2<br />  STA $2007<br />  LDA scoreTens2<br />  STA $2007<br />  LDA scoreOnes2<br />  STA $2007<br />  RTS<br /> <br />IncrementScore1:   ;increases the score by one and sets the gameover flag if it hits 100<br />   inc scoreOnes<br />   lda scoreOnes<br />   cmp #$0A<br />   bne IncrementScore1Done<br />   lda #$00<br />   sta scoreOnes<br />   inc scoreTens<br />   lda scoreTens<br />   cmp #$0A<br />   bne IncrementScore1Done<br />   lda #$00<br />   sta scoreTens<br />   inc scoreHundreds<br />   lda #STATEGAMEOVER<br />   sta gamestate   <br />IncrementScore1Done:<br />   rts<br />        <br />IncrementScore2:<br />   inc scoreOnes2<br />   lda scoreOnes2<br />   cmp #$0A<br />   bne IncrementScore2Done<br />   lda #$00<br />   sta scoreOnes2<br />   inc scoreTens2<br />   lda scoreTens2<br />   cmp #$0A<br />   bne IncrementScore2Done<br />   lda #$00<br />   sta scoreTens2<br />   inc scoreHundreds2<br />   lda #STATEGAMEOVER<br />   sta gamestate   <br />IncrementScore2Done:<br />   rts  <br /> <br />ReadController1:<br />  LDA #$01<br />  STA $4016<br />  LDA #$00<br />  STA $4016<br />  LDX #$08<br />ReadController1Loop:<br />  LDA $4016<br />  LSR A            ; bit0 -&gt; Carry<br />  ROL buttons1     ; bit0 &lt;- Carry<br />  DEX<br />  BNE ReadController1Loop<br />  RTS<br />  <br />ReadController2:<br />  LDA #$01<br />  STA $4016<br />  LDA #$00<br />  STA $4016<br />  LDX #$08<br />ReadController2Loop:<br />  LDA $4017<br />  LSR A            ; bit0 -&gt; Carry<br />  ROL buttons2     ; bit0 &lt;- Carry<br />  DEX<br />  BNE ReadController2Loop<br />  RTS   <br /><br />palette:<br />  .db $22,$29,$1A,$0F,  $22,$36,$17,$0F,  $22,$30,$21,$0F,  $22,$27,$17,$0F   ;;background palette<br />  .db $22,$1C,$15,$14,  $22,$02,$38,$3C,  $22,$1C,$15,$14,  $22,$02,$38,$3C   ;;sprite palette<br /><br />  .bank 1<br />  .org $E000<br />  .org $FFFA     ;first of the three vectors starts here<br />  .dw NMI        ;when an NMI happens (once per frame if enabled) the <br />                   ;processor will jump to the label NMI:<br />  .dw RESET      ;when the processor first turns on or is reset, it will jump<br />                   ;to the label RESET:<br />  .dw 0          ;external interrupt IRQ is not used in this tutorial<br />  .bank 2<br />  .org $0000<br />  .incbin &quot;mario.chr&quot;   ;includes 8KB graphics file from SMB<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5036">lazigamer</a> — Sat Aug 04, 2012 7:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[DC]]></name></author>
<updated>2012-08-04T12:31:03-07:00</updated>
<published>2012-08-04T12:31:03-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97590#p97590</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97590#p97590"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97590#p97590"><![CDATA[
The ball acts spasticly and bounces below the paddle. Urgh... <br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">CheckPaddleCollision:<br />  LDA ballx<br />  SEC<br />  SBC #$08  <br />  CMP #PADDLE1X<br />  BCS CheckPaddleCollisionDone      ;;if ball x &gt; left wall, still on screen, skip next section  &lt;--BCC changed to BCS    <br />  LDA bally  <br />  CLC<br />  ADC #$08<br />  CMP paddle1y<br />  BCC CheckPaddleCollisionDone      ;;if ball y &gt; top wall, still on screen, skip next section &lt;--BCS changed to BCC   <br />;  LDA bally<br /><br />  sec                              ;    &lt;-- Fixes the width of the paddle so the ball collides with the whole thing <br />  sbc #$08                      ;    &lt;-- otherwise it would pass through the bottom half (effectively the same as adding 8 to paddle1y2)<br />;  STA bally<br /><br />  CMP paddle1y2<br />  BCS CheckPaddleCollisionDone      ;;if ball y &lt; bottom wall, still on screen, skip next section  <br />  LDA #$01<br />  STA ballright  <br />  LDA #$00<br />  STA ballleft         ;;bounce, ball now moving right<br />  JMP CheckPaddleCollisionDone <br />CheckPaddleCollisionDone:</div><br /><br />This seems to work better, but I don't understand why. What was wrong with the hitboxes?<br /><br />Finished:<br /><br /><!-- m --><a class="postlink" href="http://pastebin.com/cZAUUTfH">http://pastebin.com/cZAUUTfH</a><!-- m --><br /><br />Any tips for optimization?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5381">DC</a> — Sat Aug 04, 2012 12:31 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lazigamer]]></name></author>
<updated>2012-08-04T05:54:36-07:00</updated>
<published>2012-08-04T05:54:36-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97568#p97568</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97568#p97568"/>
<title type="html"><![CDATA[Re: Pong tutorial failure]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=9144&amp;p=97568#p97568"><![CDATA[
Ok I solved the collision problem.<br /><br />Your second and third compares were reversed the idea is to skip the collision handling if NOT within the paddle's range (this is a VERY common error that I still find myself falling for).<br /><br />Also, the value of paddle1y2 being only 8 higher that paddle1y makes the paddle collision area 9 pixels. Subtracting 8 from bally for the comparison fixes that but you should find a better way of doing it.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">CheckPaddleCollision:<br />  LDA ballx<br />  CMP #PADDLE1X+8<br />  BCS CheckPaddleCollisionDone      ;;if ball x &gt; left wall, still on screen, skip next section  &lt;--BCC changed to BCS    <br />  LDA bally<br />  CMP paddle1y<br />  BCC CheckPaddleCollisionDone      ;;if ball y &gt; top wall, still on screen, skip next section &lt;--BCS changed to BCC   <br />  LDA bally<br /><br />  sec                                  &lt;-- Fixes the width of the paddle so the ball collides with the whole thing <br />  sbc #$08                          &lt;-- otherwise it would pass through the bottom half (effectively the same as adding 8 to paddle1y2)<br /><br />  CMP paddle1y2<br />  BCS CheckPaddleCollisionDone      ;;if ball y &lt; bottom wall, still on screen, skip next section  <br /></div><br /><br />All in all, the collision should work.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=5036">lazigamer</a> — Sat Aug 04, 2012 5:54 am</p><hr />
]]></content>
</entry>
</feed>