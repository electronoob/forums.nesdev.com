<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=3&amp;t=10373" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2013-08-16T09:11:14-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=3&amp;t=10373</id>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2013-08-16T09:11:14-07:00</updated>
<published>2013-08-16T09:11:14-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116607#p116607</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116607#p116607"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116607#p116607"><![CDATA[
I should have been more careful. Not sure how I missed the paste errors. That did improve things a bit. Super Mario Bros sounds a little better, but there are still problems and I guess I'm just not sweeping the frequencies properly.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Fri Aug 16, 2013 9:11 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Grapeshot]]></name></author>
<updated>2013-08-13T18:20:45-07:00</updated>
<published>2013-08-13T18:20:45-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116465#p116465</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116465#p116465"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116465#p116465"><![CDATA[
Well I know that's how it works, but the sweep result shouldn't be stored between clocks of the sweep unit; it should either be applied directly to the channel's period or the result should be discarded. It could still be correct as is, but I do see this copy and paste error:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  <br />    case 0x4005:<br />         if (value &amp; 0x80) { square&#91;1&#93;.sweepenable = 1; square&#91;1&#93;.sweepresult = square&#91;0&#93;.period; }<br />         else { square&#91;1&#93;.sweepenable = 0; square&#91;1&#93;.sweepresult = square&#91;0&#93;.period; }<br />         square&#91;1&#93;.sweepperiod = ((value &gt;&gt; 4) &amp; 7) + 1;<br /></div><br /><br />and even with that corrected, the original channel period should NOT be restored if the sweep enable is turned off.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4844">Grapeshot</a> — Tue Aug 13, 2013 6:20 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2013-08-13T18:05:08-07:00</updated>
<published>2013-08-13T18:05:08-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116463#p116463</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116463#p116463"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116463#p116463"><![CDATA[
I think the reason for the separate sweep result is that if the sweep unit calculates a result too large, it silences the channel even if sweep is disabled. This is why a lot of games don't use the pulse channels' bottom octave, as writing $00 causes anything in the bottom octave to instantly silence the channel.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Tue Aug 13, 2013 6:05 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Grapeshot]]></name></author>
<updated>2013-08-13T16:11:03-07:00</updated>
<published>2013-08-13T16:11:03-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116460#p116460</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116460#p116460"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116460#p116460"><![CDATA[
Well for one, it's wrong to have a separate sweep result and square period. The sweep unit should change the period of the channel directly. Here's my code for the sweep unit (Java)<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    private void setsweep() {<br />        //System.err.println(&quot;sweep&quot;);<br />        for (int i = 0; i &lt; 2; ++i) {<br />            sweepsilence&#91;i&#93; = false;<br />            if (sweepreload&#91;i&#93;) {<br />                sweepreload&#91;i&#93; = false;<br />                sweeppos&#91;i&#93; = sweepperiod&#91;i&#93;;<br />            }<br />            ++sweeppos&#91;i&#93;;<br />            final int rawperiod = (timers&#91;i&#93;.getperiod() &gt;&gt; 1);<br />            int shiftedperiod = (rawperiod &gt;&gt; sweepshift&#91;i&#93;);<br />            if (sweepnegate&#91;i&#93;) {<br />                //invert bits of period<br />                //add 1 on second channel only<br />                shiftedperiod = -shiftedperiod + i;<br />            }<br />            shiftedperiod += rawperiod;<br />            if ((rawperiod &lt; 8) || shiftedperiod &gt; 0x7ff) {<br />                // silence channel<br />                sweepsilence&#91;i&#93; = true;<br />            } else if (sweepenable&#91;i&#93; &amp;&amp; (sweepshift&#91;i&#93; != 0) &amp;&amp; lengthctr&#91;i&#93; &gt; 0<br />                    &amp;&amp; sweeppos&#91;i&#93; &gt; sweepperiod&#91;i&#93;) {<br />                sweeppos&#91;i&#93; = 0;<br />                timers&#91;i&#93;.setperiod(shiftedperiod &lt;&lt; 1);<br />            }<br />        }<br />    }</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4844">Grapeshot</a> — Tue Aug 13, 2013 4:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2013-08-13T16:04:06-07:00</updated>
<published>2013-08-13T16:04:06-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116459#p116459</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116459#p116459"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116459#p116459"><![CDATA[
Ah, yeah that makes sense heh. I'm going to look over the wiki doc on sweeping again, but still if anybody can see my problem help me out of you can please! The sweepclock() function is probably what needs to be looked it. It's not very long.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Tue Aug 13, 2013 4:04 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Grapeshot]]></name></author>
<updated>2013-08-13T15:11:57-07:00</updated>
<published>2013-08-13T15:11:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116458#p116458</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116458#p116458"/>
<title type="html"><![CDATA[Re: It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116458#p116458"><![CDATA[
You're going to need to fix your sweep implementation then, because the reason the square channels keep playing is because the sweep unit isn't silencing them when it should be. Try the game Driar as well for another interesting use of the sweep unit to change octaves of the square channls without popping.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4844">Grapeshot</a> — Tue Aug 13, 2013 3:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[miker00lz]]></name></author>
<updated>2013-08-13T12:40:59-07:00</updated>
<published>2013-08-13T12:40:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116446#p116446</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116446#p116446"/>
<title type="html"><![CDATA[It's about time to finally fix my APU!]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=10373&amp;p=116446#p116446"><![CDATA[
I've been playing with trying to fix this on and off for a long time, but it's just really getting on my nerves and it seriously needs to get fixed. So, there are multiple issues. Right now I'm most interested in fixing the most annoying one. Sometimes my square channels continue to output a high tone when they should be silent. It's pretty rare in a game, but I've got a chiptune NSF that I converted to a NES by zanzan that demonstrates it right at the beginning, and continues for the first 20 to 25 seconds of the song. I've attached a ZIP of the current win32 build (works in WINE too) of my emulator along with that NES ROM to play it so you can see what I mean. After the first part of the song, the rest of it sounds pretty much correct compared to other emulators.<br /><br />moarnes-0.13.8.13-win32.zip<br /><br />This is my APU code, some of it's a little sloppy but it's readable. I've been wrestling with this for at least a year to no avail. If anybody can spot the problem, it would be amazing. I just can't figure it out. It's probably an easy bug to spot for some of you guys. My second issue is I just can't get my damn sweeps working properly no matter what I do, but one thing at a time! I can deal with sweeps after I fix this square channel bug.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/* MoarNES source - APU.c<br /><br />   This open-source software is (c)2010-2013 Mike Chambers, and is released<br />   under the terms of the GNU GPL v2 license.<br /><br />   This is my work-in-progess APU emulation code. Sweep functionality<br />   isn't working yet.<br />*/<br /><br />#include &quot;config.h&quot;<br />#include &lt;stdio.h&gt;<br />#include &lt;malloc.h&gt;<br />#include &quot;moarnes.h&quot;<br /><br />uint8_t length_lookup&#91;2&#93;&#91;16&#93; = { //the first bracket value should be bit 3, second bracket bits 7 to 4<br />   { 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x3C, 0x0E, 0x1A, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x48, 0x10, 0x20 },<br />   { 0xFE, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E}<br />};<br /><br />uint32_t noise_lookup&#91;16&#93; = {<br />   0x004, 0x008, 0x010, 0x020, 0x040, 0x060, 0x080, 0x0A0,<br />   0x0CA, 0x0FE, 0x17C, 0x1FC, 0x2FA, 0x3F8, 0x7F2, 0xFE4<br />};<br /><br />int8_t triangle_step&#91;32&#93; = {<br />   15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,<br />   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15<br />};<br /><br />uint32_t dmc_period&#91;16&#93; = {<br />   0x1AC, 0x17C, 0x154, 0x140, 0x11E, 0x0FE, 0x0E2, 0x0D6,<br />   0x0BE, 0x0A0, 0x08E, 0x080, 0x06A, 0x054, 0x048, 0x036<br />};<br /><br />uint8_t square_duty&#91;4&#93;&#91;8&#93; = {<br />   { 0, 1, 0, 0, 0, 0, 0, 0 },<br />   { 0, 1, 1, 0, 0, 0, 0, 0 },<br />   { 0, 1, 1, 1, 1, 0, 0, 0 },<br />   { 1, 0, 0, 1, 1, 1, 1, 1 }<br />};<br /><br />extern uint64_t clockticks6502;<br /><br />SDL_AudioSpec audio;<br />uint32_t buffersize, cursamplerate;<br />uint8_t buf&#91;48000&#93;;<br /><br />uint64_t seqtickgap = 0xFFFFFFFF, seqticknext = 0xFFFFFFFF;<br />uint64_t sampleticks, cursampleticks, fastsampleticks, nextsamplecycle = 0xFFFFFFFF, nextseqcycle = 0xFFFFFFFF;<br /><br />uint8_t seqstep = 0, seqmode = 4, interruptAPU = 0;<br />struct square_s square&#91;2&#93;;<br />struct triangle_s triangle;<br />struct noise_s noise;<br />struct dmc_s dmc;<br />uint8_t allowsweeps = 0; //sweep code is completely buggy right now, and really breaks a lot of stuff. allow sweeps if you want, but be prepared for extreme fail.<br /><br />int8_t channels&#91;5&#93; = { 0, 0, 0, 0, 0}; //square 1, square 2, triangle, noise, DMC<br />FILE *wavefile = NULL;<br /><br />uint8_t readAPU(uint16_t addr) {<br />   uint8_t outbyte;<br />   if (addr == 0x4015) {<br />      if (square&#91;0&#93;.enabled &amp;&amp; square&#91;0&#93;.lengthcounter) outbyte = 1;<br />         else outbyte = 0;<br />      if (square&#91;1&#93;.enabled &amp;&amp; square&#91;1&#93;.lengthcounter) outbyte |= 2;<br />      if (triangle.enabled &amp;&amp; triangle.lengthcounter) outbyte |= 4;<br />      if (noise.enabled &amp;&amp; noise.lengthcounter) outbyte |= 8;<br /><br />      return(outbyte);<br />   }<br />   return(0);<br />}<br /><br />void writeAPU(uint16_t addr, uint8_t value) {<br />   switch (addr) {<br />      case 0x4000: //square 1<br />         square&#91;0&#93;.duty = value &gt;&gt; 6;<br />         if (value &amp; 0x20) square&#91;0&#93;.lengthhalt = 1;<br />            else square&#91;0&#93;.lengthhalt = 0;<br />         if (value &amp; 0x10) square&#91;0&#93;.constant = 1;<br />            else square&#91;0&#93;.constant = 0;<br />         square&#91;0&#93;.envelope = value &amp; 0x0F;<br />         break;<br />      case 0x4001:<br />         if (value &amp; 0x80) { square&#91;0&#93;.sweepenable = 1; square&#91;0&#93;.sweepresult = square&#91;0&#93;.period; }<br />         else { square&#91;0&#93;.sweepenable = 0; square&#91;0&#93;.sweepresult = square&#91;0&#93;.period; }<br />         square&#91;0&#93;.sweepperiod = ((value &gt;&gt; 4) &amp; 7) + 1;<br />         if (value &amp; 0x08) square&#91;0&#93;.negate = 1;<br />            else square&#91;0&#93;.negate = 0;<br />         square&#91;0&#93;.sweep = value &amp; 7;<br />         square&#91;0&#93;.sweepreload = 1;<br />         break;<br />      case 0x4002:<br />         square&#91;0&#93;.period &amp;= 0xFF00;<br />         square&#91;0&#93;.period += (uint32_t)value + 1;<br />         square&#91;0&#93;.sweepresult = square&#91;0&#93;.period;<br />         break;<br />      case 0x4003:<br />         square&#91;0&#93;.lengthindex = value &gt;&gt; 3;<br />         square&#91;0&#93;.period &amp;= 0xFF;<br />         square&#91;0&#93;.period += (uint32_t)(value &amp; 7) &lt;&lt; 8;<br />         square&#91;0&#93;.dutypos = 0;<br />         squarereload(0);<br />         square&#91;0&#93;.wrotebit4 = 1;<br />         square&#91;0&#93;.sweepresult = square&#91;0&#93;.period;<br />         break;<br /><br />      case 0x4004: //square 2<br />         square&#91;1&#93;.duty = value &gt;&gt; 6;<br />         if (value &amp; 0x20) square&#91;1&#93;.lengthhalt = 1;<br />            else square&#91;1&#93;.lengthhalt = 0;<br />         if (value &amp; 0x10) square&#91;1&#93;.constant = 1;<br />            else square&#91;1&#93;.constant = 0;<br />         square&#91;1&#93;.envelope = value &amp; 0x0F;<br />         break;<br />      case 0x4005:<br />         if (value &amp; 0x80) { square&#91;1&#93;.sweepenable = 1; square&#91;1&#93;.sweepresult = square&#91;0&#93;.period; }<br />         else { square&#91;1&#93;.sweepenable = 0; square&#91;1&#93;.sweepresult = square&#91;0&#93;.period; }<br />         square&#91;1&#93;.sweepperiod = ((value &gt;&gt; 4) &amp; 7) + 1;<br />         if (value &amp; 0x08) square&#91;1&#93;.negate = 1;<br />            else square&#91;0&#93;.negate = 0;<br />         square&#91;1&#93;.sweep = value &amp; 7;<br />         square&#91;1&#93;.sweepreload = 1;<br />         break;<br />      case 0x4006:<br />         square&#91;1&#93;.period &amp;= 0xFF00;<br />         square&#91;1&#93;.period += (uint32_t)value;<br />         square&#91;1&#93;.sweepresult = square&#91;1&#93;.period;<br />         break;<br />      case 0x4007:<br />         square&#91;1&#93;.lengthindex = value &gt;&gt; 3;<br />         square&#91;1&#93;.period &amp;= 0xFF;<br />         square&#91;1&#93;.period += (uint32_t)(value &amp; 7) &lt;&lt; 8;<br />         square&#91;1&#93;.dutypos = 0;<br />         squarereload(1);<br />         square&#91;1&#93;.wrotebit4 = 1;<br />         square&#91;1&#93;.sweepresult = square&#91;1&#93;.period;<br />         break;<br /><br />      case 0x4008: //triangle<br />         if (value &amp; 0x80) triangle.lengthhalt = 1;<br />            else triangle.lengthhalt = 0;<br />         triangle.linearreload = value &amp; 0x7F;<br />         break;<br />      case 0x400A:<br />         triangle.period &amp;= 0xFF00;<br />         triangle.period += value + 1;<br />         break;<br />      case 0x400B:<br />         triangle.lengthindex = value &gt;&gt; 3;<br />         triangle.period &amp;= 0xFF;<br />         triangle.period += (uint32_t)(value &amp; 7) &lt;&lt; 8;<br />         //if (triangle.lengthhalt == 0)<br />            triangle.lengthcounter = length_lookup&#91;triangle.lengthindex &amp; 1&#93;&#91;triangle.lengthindex &gt;&gt; 1&#93;;<br />         break;<br /><br />      case 0x400C: //noise<br />         if (value &amp; 0x20) noise.lengthhalt = 1;<br />            else noise.lengthhalt = 0;<br />         if (value &amp; 0x10) noise.constant = 1;<br />            else noise.constant = 0;<br />         noise.envreload = value &amp; 0x0F;<br />         noise.envelope = noise.envreload;<br />         break;<br />      case 0x400E:<br />         noise.mode = value &gt;&gt; 7;<br />            noise.period = noise_lookup&#91;value &amp; 0x0F&#93;;<br />         break;<br />      case 0x400F:<br />         noise.lengthindex = value &gt;&gt; 3;<br />         noise.lengthcounter = length_lookup&#91;noise.lengthindex &amp; 1&#93;&#91;noise.lengthindex &gt;&gt; 1&#93;;<br />         noise.wrotebit4 = 1;<br />         break;<br /><br />      case 0x4010: //DMC<br />         if (value &amp; 0x40) dmc.loopmode = 1;<br />            else dmc.loopmode = 0;<br />         dmc.period = dmc_period&#91;value &amp; 0x0F&#93; &gt;&gt; 3;<br />         break;<br />      case 0x4011:<br />         channels&#91;4&#93; = value &amp; 0x7F;<br />         break;<br />      case 0x4012:<br />         dmc.addressreg = value;<br />         dmc.address = ((uint16_t)value &lt;&lt; 6) | 0xC000;<br />         break;<br />      case 0x4013:<br />         dmc.lengthreg = value;<br />         dmc.bytesremain = ((uint16_t)value &lt;&lt; 4) + 1;<br />         break;<br /><br />      case 0x4015:<br />         if (value &amp; 1) {<br />            square&#91;0&#93;.enabled = 1;<br />         } else {<br />            square&#91;0&#93;.enabled = 0;<br />            square&#91;0&#93;.lengthcounter = 0;<br />         }<br />         if (value &amp; 2) {<br />            square&#91;1&#93;.enabled = 1;<br />         } else {<br />            square&#91;1&#93;.enabled = 0;<br />            square&#91;1&#93;.lengthcounter = 0;<br />         }<br />         if (value &amp; 4) {<br />            triangle.enabled = 1;<br />         } else {<br />            triangle.enabled = 0;<br />            triangle.lengthcounter = 0;<br />         }<br />         if (value &amp; 8) noise.enabled = 1;<br />            else noise.enabled = 0;<br />            if (value &amp; 16) { dmc.enabled = 1; dmc.lasttick = clockticks6502; }<br />            else dmc.enabled = 0;<br />         break;<br /><br />      case 0x4017:<br />         if (value &amp; 0x80) seqmode = 5;<br />            else seqmode = 4;<br />         break;<br />   }<br />   if (square&#91;0&#93;.enabled == 0) square&#91;0&#93;.lengthcounter = 0;<br />   if (square&#91;1&#93;.enabled == 0) square&#91;1&#93;.lengthcounter = 0;<br />   if (triangle.enabled == 0) {<br />      triangle.lengthcounter = 0;<br />      triangle.linearcounter = 0;<br />   }<br />   if (noise.enabled == 0) noise.lengthcounter = 0;<br />}<br /><br />void squarereload(uint8_t channel) {<br />   square&#91;channel&#93;.lengthcounter = length_lookup&#91;square&#91;channel&#93;.lengthindex &amp; 1&#93;&#91;square&#91;channel&#93;.lengthindex &gt;&gt; 1&#93;;<br />}<br /><br />void envclock() {<br />   if (square&#91;0&#93;.constant == 0) {<br />      if (square&#91;0&#93;.wrotebit4) {<br />         square&#91;0&#93;.envelope = 15;<br />         square&#91;0&#93;.wrotebit4 = 0;<br />      } else {<br />         if (square&#91;0&#93;.envelope &gt; 0) square&#91;0&#93;.envelope--;<br />      }<br />      if ((square&#91;0&#93;.envelope == 0) &amp;&amp; square&#91;0&#93;.envloop) {<br />         square&#91;0&#93;.envelope = 15;<br />      }<br />   }<br /><br />   if (square&#91;1&#93;.constant == 0) {<br />      if (square&#91;1&#93;.wrotebit4) {<br />         square&#91;1&#93;.envelope = 15;<br />         square&#91;1&#93;.wrotebit4 = 0;<br />      } else {<br />         if (square&#91;1&#93;.envelope &gt; 0) square&#91;1&#93;.envelope--;<br />      }<br />      if ((square&#91;1&#93;.envelope == 0) &amp;&amp; square&#91;1&#93;.envloop) {<br />         square&#91;1&#93;.envelope = 15;<br />      }<br />   }<br /><br />   if (noise.constant == 0) {<br />      if (noise.wrotebit4) {<br />         noise.envelope = 15;<br />         noise.wrotebit4 = 0;<br />      } else {<br />         if (noise.envelope &gt; 0) noise.envelope--;<br />      }<br />      if ((noise.envelope == 0) &amp;&amp; noise.lengthhalt) {<br />         noise.envelope = 15;<br />      }<br />   }<br />}<br /><br />void linearclock() {<br />   if (triangle.lengthhalt == 0) {<br />      if (triangle.linearcounter &gt; 0) triangle.linearcounter--;<br />         else triangle.linearcounter = triangle.linearreload;<br />   } else {<br />      triangle.linearcounter = triangle.linearreload;<br />   }<br />}<br /><br />void lengthclock() {<br />   if (square&#91;0&#93;.lengthhalt == 0) {<br />      if (square&#91;0&#93;.lengthcounter &gt; 0) square&#91;0&#93;.lengthcounter--;<br />   }<br /><br />   if (square&#91;1&#93;.lengthhalt == 0) {<br />      if (square&#91;1&#93;.lengthcounter &gt; 0) square&#91;1&#93;.lengthcounter--;<br />   }<br /><br />   if (triangle.lengthhalt == 0) {<br /><br />      if (triangle.lengthcounter &gt; 0) triangle.lengthcounter--;<br />   }<br /><br />   if (noise.lengthhalt == 0) {<br />      if (noise.lengthcounter &gt; 0) noise.lengthcounter--;<br />   }<br />}<br /><br />void sweepclock() {<br />   int32_t s, wl, d&#91;4&#93;;<br />   uint8_t chan;<br /><br />   for (chan=0; chan&lt;2; chan++) {<br />      if ((--square&#91;chan&#93;.sweep == 0) || square&#91;chan&#93;.sweepreload) square&#91;chan&#93;.sweep = square&#91;chan&#93;.sweepperiod;<br />      if ((square&#91;chan&#93;.period &gt;= 8) &amp;&amp; square&#91;chan&#93;.sweepenable &amp;&amp; square&#91;chan&#93;.sweep) {<br />         wl = square&#91;chan&#93;.period;<br />         s = wl &gt;&gt; square&#91;chan&#93;.sweep;<br />         d&#91;0&#93; = s; d&#91;1&#93; = s; d&#91;2&#93; = ~s; d&#91;3&#93; = -s;<br />         wl += d&#91;square&#91;chan&#93;.negate*2 + chan&#93;;<br />         if (wl &lt; 0x800) square&#91;chan&#93;.sweepresult = wl;<br />            else square&#91;chan&#93;.sweepresult = 0;<br />      } else square&#91;chan&#93;.sweepresult = 0;<br />      if (!allowsweeps) square&#91;chan&#93;.sweepresult = square&#91;chan&#93;.period;<br />   }<br />}<br /><br />void setinterruptAPU() {<br />}<br /><br />void frameseqAPU() {<br />    if (clockticks6502 &lt; seqticknext) return;<br />      else seqticknext += seqtickgap;<br /><br />      if  (seqmode == 4) {<br />         switch (seqstep) {<br />            case 0:<br />               envclock();<br />               linearclock();<br />               break;<br />            case 1:<br />               lengthclock();<br />               sweepclock();<br />               envclock();<br />               linearclock();<br />               break;<br />            case 2:<br />               envclock();<br />               linearclock();<br />               break;<br />            case 3:<br />               setinterruptAPU();<br />               lengthclock();<br />               sweepclock();<br />               envclock();<br />               linearclock();<br />               break;<br />         }<br />         seqstep = (seqstep + 1) % seqmode;<br />      } else if (seqmode == 5) {<br />         switch (seqstep) {<br />            case 0:<br />               lengthclock();<br />               sweepclock();<br />               envclock();<br />               linearclock();<br />               break;<br />            case 1:<br />               envclock();<br />               linearclock();<br />               break;<br />            case 2:<br />               lengthclock();<br />               sweepclock();<br />               envclock();<br />               linearclock();<br />               break;<br />            case 3:<br />               envclock();<br />               linearclock();<br />               break;<br />            case 4:<br />               break;<br />         }<br />         seqstep = (seqstep + 1) % seqmode;<br />      }<br />}<br /><br />void mixerinput(uint8_t channel, uint8_t value) {<br />   channels&#91;channel&#93; = value;<br />}<br /><br />int32_t bufferpos = 0, buffersync = 0, audiosync = 0, unpausebufpos;<br />int8_t last = 0;<br />int8_t mixeroutAPU() {<br />   double outbyte;<br /><br />   double squareout, tndout;<br />   squareout = 0;<br />   if (square&#91;0&#93;.enabled &amp;&amp; (square&#91;0&#93;.period &gt; 7) &amp;&amp; (square&#91;0&#93;.lengthcounter &gt; 0)) squareout += channels&#91;0&#93;;<br />   if (square&#91;1&#93;.enabled &amp;&amp; (square&#91;1&#93;.period &gt; 7) &amp;&amp; (square&#91;1&#93;.lengthcounter &gt; 0)) squareout += channels&#91;1&#93;;<br />   squareout *= 0.00752;<br />   tndout = 0;<br />   if (triangle.enabled &amp;&amp; (triangle.period &gt; 7) &amp;&amp; (triangle.lengthcounter &gt; 0) &amp;&amp; (triangle.linearcounter &gt; 0)) tndout += channels&#91;2&#93;;<br /><br />   tndout = tndout * 0.00851 + 0.00494 * channels&#91;3&#93; + 0.00335 * channels&#91;4&#93;;<br />   outbyte = (int16_t)(127 * squareout);<br />   outbyte += (int16_t)(127 * tndout);<br />   <br /><br />   return(outbyte);<br />}<br /><br />void buffersampleAPU() {<br />   if ((uint32_t)bufferpos &lt; buffersize) {<br />      buf&#91;bufferpos++&#93; = mixeroutAPU();<br />   } else {<br />      SDL_PauseAudio(0);<br />   }<br />}<br /><br />void tickchannelsAPU() {<br />   int16_t tmpbit, feedback;<br />   uint32_t squaretarget;<br /><br />   if (clockticks6502 &gt;= nextsamplecycle) {<br />      buffersampleAPU();<br />      nextsamplecycle += fastsampleticks;<br />   }<br /><br />   if ((uint32_t)bufferpos &gt;= buffersize) { //if sample buffer is full, postpone channel ticks<br />      square&#91;0&#93;.lasttick = square&#91;1&#93;.lasttick = triangle.lasttick = noise.lasttick = dmc.lasttick = clockticks6502;<br />      return;<br />   }<br /><br />   if (clockticks6502 &gt;= nextseqcycle) {<br />      frameseqAPU();<br />      nextseqcycle += seqtickgap;<br />   }<br /><br />   if (square&#91;0&#93;.sweepenable) squaretarget = square&#91;0&#93;.sweepresult;<br />      else squaretarget = square&#91;0&#93;.period;<br />   if ((clockticks6502 - square&#91;0&#93;.lasttick) &gt;= (squaretarget &lt;&lt; 1)) {<br />      if (square&#91;0&#93;.enabled &amp;&amp; (squaretarget &gt; 7) &amp;&amp; (square&#91;0&#93;.lengthcounter &gt; 0)) {<br />         channels&#91;0&#93; = square&#91;0&#93;.envelope * square_duty&#91;square&#91;0&#93;.duty&#93;&#91;square&#91;0&#93;.dutypos&#93;;<br />         square&#91;0&#93;.dutypos = (square&#91;0&#93;.dutypos + 1) &amp; 7;<br />      } else channels&#91;0&#93; = 0;<br />      square&#91;0&#93;.lasttick = clockticks6502 - ((clockticks6502 - square&#91;0&#93;.lasttick) - (squaretarget &lt;&lt; 1));<br />   }<br /><br />   if (square&#91;1&#93;.sweepenable) squaretarget = square&#91;1&#93;.sweepresult;<br />      else squaretarget = square&#91;1&#93;.period;<br />   if ((clockticks6502 - square&#91;1&#93;.lasttick) &gt;= (squaretarget &lt;&lt; 1)) {<br />      if (square&#91;1&#93;.enabled &amp;&amp; (squaretarget &gt; 7) &amp;&amp; (square&#91;1&#93;.lengthcounter &gt; 0)) {<br />         channels&#91;1&#93; = square&#91;1&#93;.envelope * square_duty&#91;square&#91;1&#93;.duty&#93;&#91;square&#91;1&#93;.dutypos&#93;;<br />         square&#91;1&#93;.dutypos = (square&#91;1&#93;.dutypos + 1) &amp; 7;<br />      } else channels&#91;1&#93; = 0;<br />      square&#91;1&#93;.lasttick = clockticks6502 - ((clockticks6502 - square&#91;1&#93;.lasttick) - (squaretarget &lt;&lt; 1));<br />   }<br /><br />   if ((clockticks6502 - triangle.lasttick) &gt;= triangle.period) {<br />      if (triangle.enabled &amp;&amp; (triangle.period &gt; 7) &amp;&amp; (triangle.lengthcounter &gt; 0) &amp;&amp; (triangle.linearcounter &gt; 0)) {<br />         channels&#91;2&#93; = triangle_step&#91;triangle.seqstep&#93; - 8;<br />         triangle.seqstep = (triangle.seqstep + 1) &amp; 31;<br />      } else channels&#91;2&#93; = 0;<br />      triangle.lasttick = clockticks6502 - ((clockticks6502 - triangle.lasttick) - triangle.period);<br />   }<br /><br />   if ((clockticks6502 - noise.lasttick) &gt;= noise.period) {<br />      if (noise.enabled) {<br />         if (noise.mode) {<br />            if (noise.shift &amp; 0x40) tmpbit = 1;<br />               else tmpbit = 0;<br />         } else {<br />            if (noise.shift &amp; 0x02) tmpbit = 1;<br />               else tmpbit = 0;<br />         }<br />         feedback = (noise.shift &amp; 1) ^ tmpbit;<br />         noise.shift = (noise.shift &gt;&gt; 1) | (feedback &lt;&lt; 13);<br />         if ((noise.lengthcounter &gt; 0) &amp;&amp; ((noise.shift &amp; 1) == 0) &amp;&amp; (noise.period &gt; 7)) {<br />            channels&#91;3&#93; = (int8_t)noise.envelope;<br />         } else channels&#91;3&#93; = 0;<br />      } else channels&#91;3&#93; = 0;<br />      noise.lasttick = clockticks6502 - ((clockticks6502 - noise.lasttick) - noise.period);<br />   }<br /><br />   if ((clockticks6502 - dmc.lasttick) &gt;= (dmc.period &lt;&lt; 3)) {<br />      if (dmc.enabled) {<br />         if (dmc.sampleempty) {<br />            dmc.sampleempty = 0;<br />            dmc.bufferbit = 0;<br />            dmc.samplebuffer = read6502(dmc.address++);<br />            if (dmc.address &lt; 0x8000) dmc.address = 0x8000;<br />            dmc.bytesremain--;<br />            if (dmc.bytesremain == 0) {<br />               if (!dmc.loopmode) {<br />                  dmc.enabled = 0;<br />               } else {<br />                  dmc.address = (dmc.addressreg &lt;&lt; 6) | 0xC000;<br />                  dmc.bytesremain = (dmc.lengthreg &lt;&lt; 4) + 1;<br />               }<br />            }<br />         }<br /><br />         if (!dmc.sampleempty) {<br />            if ((dmc.samplebuffer &gt;&gt; (dmc.bufferbit &amp; 7)) &amp; 1) {<br />               if (channels&#91;4&#93; &lt;= 0x7D) channels&#91;4&#93; += 2;<br />            } else {<br />               if (channels&#91;4&#93; &gt;= 2) channels&#91;4&#93; -= 2;<br />            }<br />            if (++dmc.bufferbit == 8) {<br />               dmc.sampleempty = 1;<br />            }<br />         }<br />      }<br /><br />      dmc.lasttick = clockticks6502 - ((clockticks6502 - dmc.lasttick) - (dmc.period &lt;&lt; 3));<br />   }<br />}<br /><br />double sampleratio = 1.00;<br />void rebufferAPU(void *udata, uint8_t *stream, int16_t len) {<br />   memcpy(stream, &amp;buf&#91;0&#93;, len);<br />   memmove(&amp;buf&#91;0&#93;, &amp;buf&#91;len&#93;, buffersize - len);<br />   bufferpos -= len;<br />   if (bufferpos &lt;= 0) bufferpos = 0;<br />}<br /><br />bool initAPU(uint8_t CPUmode, uint32_t samplerate) { //for CPUmode, 0 = NTSC, non-zero = PAL<br />   uint32_t buflen;<br /><br />   if (CPUmode) {<br />      seqtickgap = CPU_PAL / 240;<br />      sampleticks = CPU_PAL / samplerate;<br />   } else {<br />      seqtickgap = CPU_NTSC / 240;<br />      sampleticks = CPU_NTSC / samplerate;<br />   }<br />   cursampleticks = sampleticks;<br />   fastsampleticks = (uint64_t)((double)sampleticks * 1.05); //5% faster sample generation if we need to play catch-up<br /><br />   seqticknext = clockticks6502 + seqtickgap;<br />   seqmode = 4;<br />   seqstep = 0;<br />   triangle.seqstep = 0;<br />   noise.shift = 1;<br /><br />   buflen = (uint32_t)((float)(samplerate / 1000) * 100); //100 milliseconds is generally a safe latency period<br /><br />   audio.freq = samplerate;<br />   audio.samples = (uint16_t)buflen;<br />   audio.channels = 1;<br />   audio.format = AUDIO_S8;<br />   audio.callback = (void *)rebufferAPU;<br />   audio.userdata = NULL;<br /><br />   if (SDL_OpenAudio(&amp;audio, NULL) &lt; 0) return(false);<br /><br />    buffersize = buflen;<br />   bufferpos = 0;<br />   cursamplerate = samplerate;<br /><br />   SDL_PauseAudio(1);<br /><br />   return(true);<br />}<br /><br />void resetAPU() {<br />   SDL_PauseAudio(1);<br />   bufferpos = 0;<br />}<br /><br />void killAPU() {<br />   SDL_CloseAudio();<br />}<br /></div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4572">miker00lz</a> — Tue Aug 13, 2013 12:40 pm</p><hr />
]]></content>
</entry>
</feed>