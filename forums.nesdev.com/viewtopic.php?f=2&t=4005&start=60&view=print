<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Polygon filling..</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Polygon filling..</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=4005">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=4005</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>5</strong> of <strong>8</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Mon Apr 07, 2008 8:01 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I don't think "illegal" isn't the right word, as there's no law against using them.[1] Perhaps "undocumented" is the right word.
<br />
<br />A decent-size portion of the 6502 die is a gate array that decodes the opcodes. But it's full of "don't care" values for undocumented opcodes, and these "don't care" values result in a partial decoding "between" documented opcodes. This often means the behaviors of multiple opcodes get stacked together, resulting in the strange behaviors.
<br />
<br /><a href="http://en.wikipedia.org/wiki/Illegal_opcode" class="postlink">Wikipedia tells more</a>.
<br />
<br />
<br />[1] There might be a law that indirectly bans them in the context of a monopoly holder's business practice. If Nintendo holds a copyright on 10NES, along with a de facto monopoly on video games, along with a refusal to approve any game whose program uses undocumented opcodes, then the undocumented opcodes are in fact illegal. But otherwise, no.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Tue Apr 08, 2008 2:20 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Celius wrote:</div><div class="quotecontent">Umm... I have NEVER heard of those! Wow, that's really weird. How does that work? And why are they illegal?</div>The drawback of the illegal instructions is of course that many emulators, NES clones and assemblers don't support them or only have partial support.<br />Anyway as tepples said they're combinations of existing instructions operations and addressing modes introduced by accident rather than design. As such some have quite complicated or even unstable behavior. Furthermore different authors have given them different names, or names based on what their behavior was originally thought to be, which turned out wrong.<br />The opcode lists I posted earlier (<a href="http://unusedino.de/ec64/technical/aay/c64/ibmain.htm" class="postlink">AAY64</a>, <a href="http://www.oxyron.de/html/opcodes02.html" class="postlink">Graham's opcode list</a>) cover many of the details. Finding uses for these often involves a bit of ingenuity and as well as adapting your code to fit them. At first almost all of them seemed rather pointless to me but I've since found uses for most of them along the way until nowadays I wouldn't even want to write 6502 code without them.<br /><br />Here's a non-obvious but illustrative example of the kind of ways you may find to (ab-)use them:<br />Lets say you want initialize an array to an ascending sequence of numbers (say 0, 1, 2, 3, 4, 5, 6 and 7) as fast as possible. The obvious way to do this is to start out with zero and use INX/INY to get to the next number. This being a a single-byte, two-cycle instruction is as good as it gets, right? I mean don't you have to generate each new number somehow anyway? Not with illegals.. ;)<br />You see there is this instruction called SAX which stores the A ANDed together with X into memory. You can thus store three possible values directly from these registers, that is A and X themselves as well as the combined AND.<div class="codetitle"><b>Code:</b></div><div class="codecontent">LDA #%00000001<br />LDX #%11111110<br />CLC<br />SAX v0 ;; %0000 = %0001 &amp; %1110<br />STA v1 ;; %0001<br />ADC #%00000010<br />SAX v2 ;; %0010 = %0011 &amp; %1110<br />STA v3 ;; %0011<br />ADC #%00000010<br />SAX v4 ;; %0100 = %0101 &amp; %1110<br />STA v5 ;; %0101<br />ADC #%00000010<br />SAX v6 ;; %0110 = %0111 &amp; %1110<br />STA v7 ;; %0111</div>Cute, eh? And there is an even trickier version which uses SBX to avoid clearing carry.<br />The point is that successfully using the illegals often comes down realizing some particular property of these instructions which you just can't get from the normal ones and then finding a way to exploit it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">And why does it use an enormous amount of ROM? Is there a bunch of pre-defined stuff?</div>I've mostly spent it on large amounts of unrolled code. There's very nearly 32k of line drawing loops, and I've completely unrolled the code which clears the character set and tilemaps so there a 24k sequence of STAs in there somewhere, plus there's this big 12k atan2 table for directly finding out the angle of a point and another 5k of precalculated line slopes, and a few other things. About 96k in all by now I should think, but most if it ought to be avoidable without loosing too much performance, I just didn't see a reason not to use what space I have for optimization purposes whenever possible.
<br />Your main problem with using these techniques in a game environment would be the RAM usage. You see since uploading new graphics to the PPU usually takes more than one frame you have to be able to work on the next one simultaneously, something which I've chosen to do by double buffering the in-RAM versions of the character set and tilemaps. SO combined that with a few other necessary tables and I'm now down to only 320 bytes of contiguous RAM free.
<br />Then again how much game data do you really need to store when showing the cut-scenes between levels?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Tue Apr 08, 2008 6:58 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Here are some patches for Nintendulator and FCEUXD-SP to get this damnable demo to run. This gives me some hope for hardware compatibility as I really hadn't expected Nintendulator to be fine with my raster code without some heavy tweaking.
<br />
<br />Nintendulator (0.965 beta) needs implementations of the ANC/ASR/ARR and SBX illegals added to CPU.c<div class="codetitle"><b>Code:</b></div><div class="codecontent">22a23,24<br />&gt; #define ILLEGALWARNING 0<br />&gt; <br />1009a1012<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1010a1014<br />&gt; #&nbsp; &nbsp;endif<br />1014a1019<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1015a1021<br />&gt; #&nbsp; &nbsp;endif<br />1018a1025<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1019a1027<br />&gt; #&nbsp; &nbsp;endif<br />1034a1043<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1035a1045<br />&gt; #&nbsp; &nbsp;endif<br />1052a1063<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1053a1065<br />&gt; #&nbsp; &nbsp;endif<br />1068a1081<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1069a1083<br />&gt; #&nbsp; &nbsp;endif<br />1087a1102<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1088a1104<br />&gt; #&nbsp; &nbsp;endif<br />1092a1109<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1093a1111<br />&gt; #&nbsp; &nbsp;endif<br />1103a1122<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1104a1124<br />&gt; #&nbsp; &nbsp;endif<br />1119a1140<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1120a1142<br />&gt; #&nbsp; &nbsp;endif<br />1138a1161<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />1139a1163<br />&gt; #&nbsp; &nbsp;endif<br />1153a1178,1253<br />&gt; //////// new illegals ////////<br />&gt; static&nbsp; &nbsp;__forceinline void&nbsp; &nbsp;IV_ANC &#40;void&#41;<br />&gt; &#123;&nbsp; &nbsp;/* AND + copy bit-7 to carry */<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />&gt; &nbsp; &nbsp;EI.DbgOut&#40;_T&#40;&quot;Invalid opcode $%02X &#40;ANC&#41; encountered at $%04X&quot;&#41;,Opcode,OpAddr&#41;;<br />&gt; #&nbsp; &nbsp;endif<br />&gt; &nbsp; &nbsp;CPU_MemGet&#40;CalcAddr&#41;;<br />&gt; &nbsp; &nbsp;__asm<br />&gt; &nbsp; &nbsp;&#123;<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;al,CPU.LastRead<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;and&nbsp; &nbsp;CPU.A,al<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setz&nbsp; &nbsp;CPU.FZ<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;sets&nbsp; &nbsp;CPU.FN<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;sets&nbsp; &nbsp;CPU.FC<br />&gt; &nbsp; &nbsp;&#125;<br />&gt; &#125;<br />&gt; static&nbsp; &nbsp;__forceinline void&nbsp; &nbsp;IV_ASR &#40;void&#41;<br />&gt; &#123;&nbsp; &nbsp;/* AND + LSR */<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />&gt; &nbsp; &nbsp;EI.DbgOut&#40;_T&#40;&quot;Invalid opcode $%02X &#40;ASR&#41; encountered at $%04X&quot;&#41;,Opcode,OpAddr&#41;;<br />&gt; #&nbsp; &nbsp;endif<br />&gt; &nbsp; &nbsp;CPU_MemGet&#40;CalcAddr&#41;;<br />&gt; &nbsp; &nbsp;__asm<br />&gt; &nbsp; &nbsp;&#123;<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;al,CPU.LastRead<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;and al,CPU.A<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;shr&nbsp; &nbsp;al,1<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov CPU.A,al<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setc&nbsp; &nbsp;CPU.FC<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;CPU.FN,0<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setz&nbsp; &nbsp;CPU.FZ<br />&gt; &nbsp; &nbsp;&#125;<br />&gt; &#125;<br />&gt; static&nbsp; &nbsp;__forceinline void&nbsp; &nbsp;IV_ARR &#40;void&#41;<br />&gt; &#123;&nbsp; &nbsp;/* AND + ROR */<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />&gt; &nbsp; &nbsp;EI.DbgOut&#40;_T&#40;&quot;Invalid opcode $%02X &#40;ARR&#41; encountered at $%04X&quot;&#41;,Opcode,OpAddr&#41;;<br />&gt; #&nbsp; &nbsp;endif<br />&gt; &nbsp; &nbsp;CPU_MemGet&#40;CalcAddr&#41;;<br />&gt; &nbsp; &nbsp;__asm<br />&gt; &nbsp; &nbsp;&#123;<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;ah,CPU.FC<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;CPU.FN,ah<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;add&nbsp; &nbsp;ah,0xFF<br />&gt; <br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov&nbsp; &nbsp;al,CPU.LastRead<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;and al,CPU.A<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;rcr&nbsp; &nbsp;al,1<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov CPU.A,al<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setc&nbsp; &nbsp;CPU.FC<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;test&nbsp; &nbsp;al,0xFF<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setz&nbsp; &nbsp;CPU.FZ<br />&gt; &nbsp; &nbsp;&#125;<br />&gt; &#125;<br />&gt; static __forceinline void&nbsp; IV_SBX &#40;void &#41;<br />&gt; &#123;&nbsp; &nbsp;/* X = &#40;X &amp; A&#41; - #imm */<br />&gt; #&nbsp; &nbsp;if ILLEGALWARNING<br />&gt; &nbsp; &nbsp;EI.DbgOut&#40;_T&#40;&quot;Invalid opcode $%02X &#40;SBX&#41; encountered at $%04X&quot;&#41;,Opcode,OpAddr&#41;;<br />&gt; #&nbsp; &nbsp;endif<br />&gt; &nbsp; &nbsp;CPU_MemGet&#40;CalcAddr&#41;;<br />&gt; &nbsp; &nbsp;__asm<br />&gt; &nbsp; &nbsp;&#123;<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;cmp&nbsp; &nbsp;CPU.FC,1<br />&gt; <br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov al,CPU.X<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;and al,CPU.A<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;sbb&nbsp; &nbsp;al,CPU.LastRead<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;mov CPU.X,al<br />&gt; <br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setnc&nbsp; &nbsp;CPU.FC<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;setz&nbsp; &nbsp;CPU.FZ<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;sets&nbsp; &nbsp;CPU.FN<br />&gt; &nbsp; &nbsp;&nbsp; &nbsp;seto&nbsp; &nbsp;CPU.FV<br />&gt; &nbsp; &nbsp;&#125;<br />&gt; &#125;<br />&gt; <br />1188,1191c1288,1291<br />&lt; case 0x03:AM_INX&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x13:AM_INYW&#40;&#41;; IV_SLO&#40;&#41;;break;case 0x0B:AM_IMM&#40;&#41;;&nbsp; IV_UNK&#40;&#41;;break;case 0x1B:AM_ABYW&#40;&#41;; IV_SLO&#40;&#41;;break;case 0x07:AM_ZPG&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x17:AM_ZPX&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x0F:AM_ABS&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x1F:AM_ABXW&#40;&#41;; IV_SLO&#40;&#41;;break;<br />&lt; case 0x23:AM_INX&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x33:AM_INYW&#40;&#41;; IV_RLA&#40;&#41;;break;case 0x2B:AM_IMM&#40;&#41;;&nbsp; IV_UNK&#40;&#41;;break;case 0x3B:AM_ABYW&#40;&#41;; IV_RLA&#40;&#41;;break;case 0x27:AM_ZPG&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x37:AM_ZPX&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x2F:AM_ABS&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x3F:AM_ABXW&#40;&#41;; IV_RLA&#40;&#41;;break;<br />&lt; case 0x43:AM_INX&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x53:AM_INYW&#40;&#41;; IV_SRE&#40;&#41;;break;case 0x4B:AM_IMM&#40;&#41;;&nbsp; IV_UNK&#40;&#41;;break;case 0x5B:AM_ABYW&#40;&#41;; IV_SRE&#40;&#41;;break;case 0x47:AM_ZPG&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x57:AM_ZPX&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x4F:AM_ABS&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x5F:AM_ABXW&#40;&#41;; IV_SRE&#40;&#41;;break;<br />&lt; case 0x63:AM_INX&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x73:AM_INYW&#40;&#41;; IV_RRA&#40;&#41;;break;case 0x6B:AM_IMM&#40;&#41;;&nbsp; IV_UNK&#40;&#41;;break;case 0x7B:AM_ABYW&#40;&#41;; IV_RRA&#40;&#41;;break;case 0x67:AM_ZPG&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x77:AM_ZPX&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x6F:AM_ABS&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x7F:AM_ABXW&#40;&#41;; IV_RRA&#40;&#41;;break;<br />---<br />&gt; case 0x03:AM_INX&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x13:AM_INYW&#40;&#41;; IV_SLO&#40;&#41;;break;case 0x0B:AM_IMM&#40;&#41;;&nbsp; IV_ANC&#40;&#41;;break;case 0x1B:AM_ABYW&#40;&#41;; IV_SLO&#40;&#41;;break;case 0x07:AM_ZPG&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x17:AM_ZPX&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x0F:AM_ABS&#40;&#41;;&nbsp; IV_SLO&#40;&#41;;break;case 0x1F:AM_ABXW&#40;&#41;; IV_SLO&#40;&#41;;break;<br />&gt; case 0x23:AM_INX&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x33:AM_INYW&#40;&#41;; IV_RLA&#40;&#41;;break;case 0x2B:AM_IMM&#40;&#41;;&nbsp; IV_ANC&#40;&#41;;break;case 0x3B:AM_ABYW&#40;&#41;; IV_RLA&#40;&#41;;break;case 0x27:AM_ZPG&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x37:AM_ZPX&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x2F:AM_ABS&#40;&#41;;&nbsp; IV_RLA&#40;&#41;;break;case 0x3F:AM_ABXW&#40;&#41;; IV_RLA&#40;&#41;;break;<br />&gt; case 0x43:AM_INX&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x53:AM_INYW&#40;&#41;; IV_SRE&#40;&#41;;break;case 0x4B:AM_IMM&#40;&#41;;&nbsp; IV_ASR&#40;&#41;;break;case 0x5B:AM_ABYW&#40;&#41;; IV_SRE&#40;&#41;;break;case 0x47:AM_ZPG&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x57:AM_ZPX&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x4F:AM_ABS&#40;&#41;;&nbsp; IV_SRE&#40;&#41;;break;case 0x5F:AM_ABXW&#40;&#41;; IV_SRE&#40;&#41;;break;<br />&gt; case 0x63:AM_INX&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x73:AM_INYW&#40;&#41;; IV_RRA&#40;&#41;;break;case 0x6B:AM_IMM&#40;&#41;;&nbsp; IV_ARR&#40;&#41;;break;case 0x7B:AM_ABYW&#40;&#41;; IV_RRA&#40;&#41;;break;case 0x67:AM_ZPG&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x77:AM_ZPX&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x6F:AM_ABS&#40;&#41;;&nbsp; IV_RRA&#40;&#41;;break;case 0x7F:AM_ABXW&#40;&#41;; IV_RRA&#40;&#41;;break;<br />1194c1294<br />&lt; case 0xC3:AM_INX&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xD3:AM_INYW&#40;&#41;; IV_DCP&#40;&#41;;break;case 0xCB:AM_IMM&#40;&#41;;&nbsp; IV_UNK&#40;&#41;;break;case 0xDB:AM_ABYW&#40;&#41;; IV_DCP&#40;&#41;;break;case 0xC7:AM_ZPG&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xD7:AM_ZPX&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xCF:AM_ABS&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xDF:AM_ABXW&#40;&#41;; IV_DCP&#40;&#41;;break;<br />---<br />&gt; case 0xC3:AM_INX&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xD3:AM_INYW&#40;&#41;; IV_DCP&#40;&#41;;break;case 0xCB:AM_IMM&#40;&#41;;&nbsp; IV_SBX&#40;&#41;;break;case 0xDB:AM_ABYW&#40;&#41;; IV_DCP&#40;&#41;;break;case 0xC7:AM_ZPG&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xD7:AM_ZPX&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xCF:AM_ABS&#40;&#41;;&nbsp; IV_DCP&#40;&#41;;break;case 0xDF:AM_ABXW&#40;&#41;; IV_DCP&#40;&#41;;break;</div><br /><br />For FCEUXD-SP (1.07) I merely had to change the addressing modes of ISC and DCP in ops.c:<div class="codetitle"><b>Code:</b></div><div class="codecontent">352,358c352,358<br />&lt; case 0xC7: LD_ZP&#40;DEC;CMP&#41;;<br />&lt; case 0xD7: LD_ZPX&#40;DEC;CMP&#41;;<br />&lt; case 0xCF: LD_AB&#40;DEC;CMP&#41;;<br />&lt; case 0xDF: LD_ABX&#40;DEC;CMP&#41;;<br />&lt; case 0xDB: LD_ABY&#40;DEC;CMP&#41;;<br />&lt; case 0xC3: LD_IX&#40;DEC;CMP&#41;;<br />&lt; case 0xD3: LD_IY&#40;DEC;CMP&#41;;<br />---<br />&gt; case 0xC7: RMW_ZP&#40;DEC;CMP&#41;;<br />&gt; case 0xD7: RMW_ZPX&#40;DEC;CMP&#41;;<br />&gt; case 0xCF: RMW_AB&#40;DEC;CMP&#41;;<br />&gt; case 0xDF: RMW_ABX&#40;DEC;CMP&#41;;<br />&gt; case 0xDB: RMW_ABY&#40;DEC;CMP&#41;;<br />&gt; case 0xC3: RMW_IX&#40;DEC;CMP&#41;;<br />&gt; case 0xD3: RMW_IY&#40;DEC;CMP&#41;;<br />361,367c361,367<br />&lt; case 0xE7: LD_ZP&#40;INC;SBC&#41;;<br />&lt; case 0xF7: LD_ZPX&#40;INC;SBC&#41;;<br />&lt; case 0xEF: LD_AB&#40;INC;SBC&#41;;<br />&lt; case 0xFF: LD_ABX&#40;INC;SBC&#41;;<br />&lt; case 0xFB: LD_ABY&#40;INC;SBC&#41;;<br />&lt; case 0xE3: LD_IX&#40;INC;SBC&#41;;<br />&lt; case 0xF3: LD_IY&#40;INC;SBC&#41;;<br />---<br />&gt; case 0xE7: RMW_ZP&#40;INC;SBC&#41;;<br />&gt; case 0xF7: RMW_ZPX&#40;INC;SBC&#41;;<br />&gt; case 0xEF: RMW_AB&#40;INC;SBC&#41;;<br />&gt; case 0xFF: RMW_ABX&#40;INC;SBC&#41;;<br />&gt; case 0xFB: RMW_ABY&#40;INC;SBC&#41;;<br />&gt; case 0xE3: RMW_IX&#40;INC;SBC&#41;;<br />&gt; case 0xF3: RMW_IY&#40;INC;SBC&#41;;</div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Celius</b> [ Tue Apr 08, 2008 11:25 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />It's unfortunate many emulators don't support these opcodes. Some of these would be really useful. And it's really dumb since most people will be playing games we make on emulators, and if it doesn't work, they probably won't go download an updated version that might get it working. Like XAA seems like I would use it a lot. It's really too bad.
<br />
<br />But if you're just interested in developing for play on the real thing, I suppose you can do these. I'm interested in playing on the real thing, but I'm also interested in the ability to play it on an emulator.
<br />
<br />But does Nestopia support all of the illegal opcodes?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Tue Apr 08, 2008 11:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />The ultimate goal of any NESdev project is to produce a program that runs on a Nintendo Family Computer or Nintendo Entertainment System. Perhaps if there way to recompile 6502 assembly language into C, with high-level emulation of the PPU, it might be possible to make one binary that runs on PC hardware running Windows and another binary that runs on NES hardware (and good emulators). It's a bit easier to make a cross-platform game on the GBA or DS because its 32-bit CPU more readily accepts compiled C.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Tue Apr 08, 2008 11:38 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Celius wrote:</div><div class="quotecontent">It's unfortunate many emulators don't support these opcodes. Some of these would be really useful. And it's really dumb since most people will be playing games we make on emulators, and if it doesn't work, they probably won't go download an updated version that might get it working. Like XAA seems like I would use it a lot. It's really too bad.<br /><br />But if you're just interested in developing for play on the real thing, I suppose you can do these. I'm interested in playing on the real thing, but I'm also interested in the ability to play it on an emulator.</div>The reason that the emulators have such poor support for them is precisely that so little NES software uses them, no one would dream of releasing a C64 emulator without them because everyone and their grandmother are using them. So lets start including them in our NES games and demos and force things to change. Then again some people still use Nesticle so maybe things will never change..<br />Also you forgot the read the footnote on XAA. It's highly unstable and unpredictable so you couldn't have used it any event.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">But does Nestopia support all of the illegal opcodes?</div>I don't know, but it has supported everything I've tried so far which ought to be a good cross-section of them all. If anything useful is missing I'm betting it's the predictable "unstable" ones, i.e. those that AND with the page number once in a blue moon.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roth</b> [ Tue Apr 08, 2008 11:42 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If these were applied correctly to emus, I believe that would mean the Chinese <em>Biohazard</em> would be playable! Trying to save state just to get through to see how it was done altogether is a real pain.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Wed Apr 09, 2008 4:24 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I've been looking into the transformations, i.e. the 3D side of thing, and I fear writing them off as trivial may have been premature (not to mention arrogant).
<br />A lot of people can probably do this sort of thing in their sleep but I've never written any 3D code on a 'limited' system before so I don't know all the tricks yet. Unless you count fooling around in QBasic on my 386 that is, though come to think of it I had performance issues back then too (until I finally figured out that floating point was evil anyway).
<br />
<br />Essentially I've got to:<ul><li>work out a rotation matrix (from Euler angles)</li><li>multiply said matrix with the model's vertices</li><li>divide each vertex by Z for perspective correction</li><li>perform back-face culling</li><li>and light the polygons</li></ul>
<br />Working out the rotation matrix may only have to be done once per frame but it's still a significant part of the work when you're dealing with simple objects. Working out the combined rotations you get a matrix built from products and sums of sines and cosines of the three rotation angles. That is something like this, where sx is the sine of the angle of rotation along the X axis and so forth:<div class="codetitle"><b>Code:</b></div><div class="codecontent">&#91;&nbsp; sx*sy*sz + cx*cz, sx*cy,&nbsp; cx*sz - sx*sy*cz &#93;<br />&#91;&nbsp; cx*sy*cz - sx*cz, cx*cy, -cx*sy*cz - sx*sz &#93;<br />&#91; -cx*sz,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sy,&nbsp; &nbsp; &nbsp;cy*cz&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#93;</div>
<br />Naturally I'll make use of (co)sine tables but there's still an awful lot of multiplications in there and few common factors, so if I want full for the 16-bit precision vertices later on then we'll need 24-bit precision here. Luckily I remembered to check my high school formula collection and it so happens that it lists some highly useful identities for multiplying sines. For instance: 2 * cos x * cos y = cos(x - y) + cos(x + y)
<br />Now divide this by two and substitute X for Z and we've the final entry of the matrix. With only additions, subtractions and table lookups *and* without losing any precision at that. Neat :)
<br />
<br />Then you've got to multiply the vertices with the matrix. This ought to be fast and easy for fixed objects. Just design objects with lots of symmetry and nice integral coordinates then work out all of these constant multiplications by hand. With a simple cube you'd just add or subtract each of the basis vectors to get those eight points.
<br />
<br />The perspective correction is worse though and 8-bit precision will definitely not cut it. I've reserved a full 16k bank for the transformations' code and tables, so perhaps a set of logarithm and exponential tables might (just barely) have enough precision. Or perhaps a big reciprocal table and combine four of those cute square table multiplications to get a 16-bit division. A classic division algorithm with a bit of unrolling might even be fast enough, but in the past I've always been able to avoid those by cheating.
<br />
<br />I'm most uncertain about the culling and lighting though. They're basically the same thing, i.e. working out the angle between polygon and the camera or light source, in fact if I let the camera be the light source they are the same. IIRC I'd be taking the dot product between the light/camera vector (0,0,1) and the surface normal, so I ought to be able to work out the normals in advance and rotate them just like the rest of the vertices yet only calculate the Z components since we're just going to toss the rest away anyway.
<br />
<br />I'm not so sure about this part though. Aren't you supposed to do culling and lighting in screen space or something? XOR-filling cannot handle any overdraw so back facing polygons damn well better be hidden. Plus making the lighting look good when all you've got is a four color palette might get messy. And I don't even want to think about handling non-trivial (i.e. concave) objects with potential overdraw. I suppose early software renderers and 3D hardware without Z-buffering (like the PSX) must have dealt with it somehow.
<br />
<br />At any rate I'd love to hear some suggestions from people with real experience in 3D programming.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ReaperSMS</b> [ Wed Apr 09, 2008 5:21 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Considered using MMC5? or are you already using it? The multiplier would probably be handy.
<br />
<br />Pretty much everything comes down to a ton of dot products. If you can keep the space around, you probably want to try and avoid using eulers for all rotations, as there are a variety of issues with them. The downside is that quats are probably a bit of a no-go, though there are some pretty speedy sqrt and rsqrt algorithms out there.
<br />
<br />Vertex lighting is usually computed in view space before the perspective divide, and then the colors are interpolated across. If you're just going with directional face lighting though, it doesn't really matter that much. As you mentioned, if you tie the light to the camera, all you care about is the viewspace Z component of the transformed normal, which is one dot product.
<br />
<br />Culling usually happens after the perspective divide, as part of the actual triangle setup. Computing the gradiants requires finding out the screenspace area of the triangle, and if that is negative, it's backfacing. You probably want to cull quite a bit earlier than that though.
<br />
<br />I would suggest perhaps ignoring lighting, since you don't have all that many colors to work with anyways.
<br />
<br />Correct culling is a matter of determining which side of the face the camera is on, and is the sign of the dot product between the face normal and a vector from a point on the face to the camera. The bad news is this means you have to transform the normal and at least one of the points into view space to determine if it is visible.
<br />
<br />How are you handling clipping? Punting on it with a "don't hand down geometry that needs clipping" policy?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Zepper</b> [ Wed Apr 09, 2008 5:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />-...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Wed Apr 09, 2008 5:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ReaperSMS wrote:</div><div class="quotecontent">Considered using MMC5? or are you already using it? The multiplier would probably be handy.</div>MMC5 would certainly be nice, especially the reliable scanline counter, but it's just too obscure and complicated to use if I want to have any real chance of getting things tested on hardware. Plus it doesn't support CHR-RAM, or at least no official games seem to use it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Pretty much everything comes down to a ton of dot products. If you can keep the space around, you probably want to try and avoid using eulers for all rotations, as there are a variety of issues with them. The downside is that quats are probably a bit of a no-go, though there are some pretty speedy sqrt and rsqrt algorithms out there.</div>Normally that would be true but I don't actually want to do anything with the numbers, just animate simple spinning objects. In other words I just want to be able to let an object rotate by some variable amount along each axis each frame. So stability and such are non-issues.
<br />Of course if you've got a faster alternative method for setting this up then I'd be happy to hear it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Wed Apr 09, 2008 5:55 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ReaperSMS wrote:</div><div class="quotecontent">Culling usually happens after the perspective divide, as part of the actual triangle setup. Computing the gradiants requires finding out the screenspace area of the triangle, and if that is negative, it's backfacing. You probably want to cull quite a bit earlier than that though.</div>I'll only have a single low-polygon object at a fixed point in the middle of the screen so I there isn't much to gain from early culling. Plus with XOR-filling I'm actually drawing the outlines rather than the polygons themselves which involves a bit of special handling..<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I would suggest perhaps ignoring lighting, since you don't have all that many colors to work with anyways.</div>Perhaps but I've seen it done before in many C64 demos and it can look pretty good. Especially with a dynamic palette.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Correct culling is a matter of determining which side of the face the camera is on, and is the sign of the dot product between the face normal and a vector from a point on the face to the camera. The bad news is this means you have to transform the normal and at least one of the points into view space to determine if it is visible.</div>View space as in with perspective correction and everything? In that case couldn't I just use a dot product to find the orientation of the polygon on screen and avoid transforming the normal? <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">How are you handling clipping? Punting on it with a "don't hand down geometry that needs clipping" policy?</div>There is no clipping between objects as there will only be one and I'm hoping to avoid clipping against the screen edges as doing it efficiently would complicate some timing-sensitive raster code, it is certainly doable though, especially if I'm willing to waste tiles along the upper edge of the screen.
<br />Anyway that was pretty much what I wanted to ask. With XOR-filling overdraw just won't render correctly so if I want to draw non-trivial objects I'm going to have to clip things manually not just draw them in back-to-front order. The question is how can I efficiently determine which polygons might have to be clipped, and what's the most efficient way of performing the clipping itself?
<br />
<br />Please note if I ever actually wanted to use this thing in a NES game then it'd be as a way to compress cut-scenes, and then I'd naturally have everything pre-calculated and just store a list of polygons to draw. This whole business is just for me to prove I can do the "3D" bit on the NES as well ;)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>ReaperSMS</b> [ Wed Apr 09, 2008 7:49 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Clipping and culling are two different things. If you restrict things to convex polygons, and decree that no objects shall intersect, then backface culling is all you need.
<br />
<br />Culling is the elimination of entire polygons, due to them being outside the view frustum or backfacing. Usually pretty fast.
<br />
<br />Clipping is modifying the polygon to fit within a boundary, such as the view frustum. It involves chopping edges apart and adding new ones, and tends to be slow.
<br />
<br />Most clipping you can actually ignore, as long as you have some sort of scissoring happening at the screen edges in your rasterizer. The only time you *absolutely* need to clip is if a polygon intersects the near plane, as without that the perspective divide explodes.
<br />
<br />Coordinate spaces:
<br />
<br />Object space: space the vertices are modeled in. Origin is usually the center or some other handy spot on the object (such as the feet)
<br />
<br />World space: space objects and the camera are placed in, relatively arbitrary
<br />
<br />Camera/View space: space relative to the camera. The viewpoint is at the origin, looking down the positive or negative Z axis generally. Handy for lighting, as the View vector for a particular vertex is simply the negative of the position.
<br />
<br />Clip space: 4D homogeneous space, result of taking view space vertices and transforming them through the projection matrix. Usually X and Y range from +/-W, Z from 0 to W or 0 to -W. Handy for clipping, as your clip planes are usually X = -W, X = W, Y = -W, Y = W, etc.
<br />
<br />Normalized Device Coordinate space: the result of perspective dividing clipspace verts. X and Y cover +/- 1, Z usually runs from 0-1.
<br />
<br />Screen space: NDC coordinates moved through the viewport transformation, which is generally just a scale and offset to get corrdinates in 0-w and 0-h
<br />
<br />Usually the transforms get broken down into Model-&gt;View (OpenGL MODELVIEW), View-&gt;Clip (PROJECTION), and NDC-&gt;Screen (Viewport)
<br />
<br />As for just spinning a particular object, if you don't care about numeric precision eventually squashing or stretching it in odd ways, you can just store the transformation matrix, and do a single matrix multiply to rotate that matrix each frame to get the rotation. It might work out to fewer operations than constructing it from the eulers every time.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Thu Apr 10, 2008 12:01 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tepples wrote:</div><div class="quotecontent">I don't think "illegal" isn't the right word, as there's no law against using them. Perhaps "undocumented" is the right word.</div>
<br />Both are misleading, because they are documented, and they don't cause any hardware trap as illegal would suggest (except the several that halt the processor). I use the term "unofficial", since they aren't described in the official 6502 manuals from various manufacturers.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>doynax</b> [ Thu Apr 10, 2008 1:04 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">ReaperSMS wrote:</div><div class="quotecontent">Clipping and culling are two different things. If you restrict things to convex polygons, and decree that no objects shall intersect, then backface culling is all you need.</div>Right. The question is how would I deal with concave objects? Traditionally you could have used, say, a BSP tree to draw in the correct order but I've got to avoid overdraw altogether and clipping polygons against each other quite expensive.<br />I think I'll take the easy way out and that part of it.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Coordinate spaces:<br /><br />.<br />.<br />.<br /><br />Screen space: NDC coordinates moved through the viewport transformation, which is generally just a scale and offset to get corrdinates in 0-w and 0-h</div>That's a useful list, I was less than certain about the proper names for things.<br />In that case I've got to do back-face culling after the perspective correction, which seems pretty reasonable since a surface nearly parallel to the Z axis would get it's far side turned inwards and thus be hidden. So I suppose I'm stuck with doing a pair of multiplications per-surface for the test.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As for just spinning a particular object, if you don't care about numeric precision eventually squashing or stretching it in odd ways, you can just store the transformation matrix, and do a single matrix multiply to rotate that matrix each frame to get the rotation. It might work out to fewer operations than constructing it from the eulers every time.</div>Hm.. As far as I can see a matrix-by-matrix multiplication is 27 multiplications, while the original contains only 16 to begin with. And since it only contains multiplications of sines and cosines I believe I can to a bit of magic algebra to reduce everything to additions, subtractions and lookups in the sine tables.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>5</strong> of <strong>8</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>