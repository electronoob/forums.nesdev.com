<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - the Power Glove</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">the Power Glove</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>4</strong> of <strong>4</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Jun 02, 2012 6:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'm sure nocash has already done this as well, but... yeh.  The ALU opcodes in the cop888 seem to have no alignment any which way to the behaviors he's documented for the 8 and 16-bit instructions.  Which, sadly, means there's probably some internal ROM being run that takes the data and parses it out as a sort of meta code set.  And really, with so many bits seeming to correspond to raw data parameters, there wasn't much room at all for them to be proper CPU opcodes <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />
<br />
<br />And speaking of opcodes and programming... ugh.  I can see why reading whatever <em>is</em> there would be a pain.  Looks like the only way in or out of this chip for bulk data transfer is the MICROWIRE/PLUS bus which, at a very high level, looks to be an 8-bit-at-a-time automatic serial protocol.  Very nice, presumably, when dealing with data from a shift register, but not set up for a good old-fashioned address-&gt;data query.  For that matter, indications seem to point to the ROM being on-board and not even accessible directly to the program running within it- all opcodes resolve to an independent data-space address map.  Allegedly chunks of ROM can be transferred to data RAM, but to do that you'd presumably need to be running your own code in the ROM to begin with.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Jun 02, 2012 7:40 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">nocash wrote:</div><div class="quotecontent">PCB at the front of the glove (on the hand): <!-- m --><a class="postlink" href="http://www.instructables.com/files/deriv/FOZ/BKA3/FT17YOV5/FOZBKA3FT17YOV5.LARGE.jpg">http://www.instructables.com/files/deri ... .LARGE.jpg</a><!-- m --> (component side), and <!-- m --><a class="postlink" href="http://www.instructables.com/files/deriv/F2S/ZDBG/FT17VT0N/F2SZDBGFT17VT0N.LARGE.jpg">http://www.instructables.com/files/deri ... .LARGE.jpg</a><!-- m --> (solder side). The two speakers seem to be the round black things above index finder and little finger. And, there seems to be a third speaker glued to the middle of the casing; I guess that's where the "beep" sounds are coming from.<br /><br />PCB for the button part (on the arm): <!-- m --><a class="postlink" href="http://www.instructables.com/files/deriv/FWB/0JZC/FT1816N4/FWB0JZCFT1816N4.LARGE.jpg">http://www.instructables.com/files/deri ... .LARGE.jpg</a><!-- m --> (showing a fragment of the solder side only). Not much seen there, judging from the solder pads, it doesn't look as if there's a CPU on the component side (unless it'd be a SMD chip). So far, I'd guess that the CPU is located in that mysterious "junction box" (the small box that most photographers never mind taking pictures of when they are posing with their glove).</div>
<br />
<br />Okay.  So the brain isn't in the front of the glove, and it's not in the controller part of the glove (unless it's the IC evident on the reverse side of that PCB).  Which leaves the box-shaped things.  And box-shaped things with easily accessible screws aren't as bad to open.  
<br />
<br />I opened up the junction box (first box off the short lead to the NES plug) and the brain isn't there.  Just some resistors and a couple "ST" brand LM324N A935 ICs which, without bothering to look them up because I'm lazy, I'd guess would be some manner of shift-register or serialization controller.  (EDIT: nope.  It's a quad op-amp. - <!-- m --><a class="postlink" href="http://www.datasheetcatalog.com/datasheets_pdf/L/M/3/2/LM324N.shtml">http://www.datasheetcatalog.com/datashe ... 324N.shtml</a><!-- m -->) <!-- m --><a class="postlink" href="http://www.psychsoftware.org/stuff/temp/photo/PowerGlove/P6020329.JPG">http://www.psychsoftware.org/stuff/temp ... 020329.JPG</a><!-- m -->
<br />
<br />Which leaves the boxes in the frame.  Frame box #1 (literally, they have numbers: 1, 2, 3) contains a minimalist PCB with one tiny Texas Instruments TL062CP 939EB (EDIT: another op-amp - <!-- m --><a class="postlink" href="http://www.datasheetcatalog.com/datasheets_pdf/T/L/0/6/TL062CP.shtml">http://www.datasheetcatalog.com/datashe ... 62CP.shtml</a><!-- m -->). <!-- m --><a class="postlink" href="http://www.psychsoftware.org/stuff/temp/photo/PowerGlove/P6020330.JPG">http://www.psychsoftware.org/stuff/temp ... 020330.JPG</a><!-- m -->  Ditto on box #3 (out of order only because it was more accessible than the corner), which also has the main wire harness out to the Junction Box.  <!-- m --><a class="postlink" href="http://www.psychsoftware.org/stuff/temp/photo/PowerGlove/P6020331.JPG">http://www.psychsoftware.org/stuff/temp ... 020331.JPG</a><!-- m -->
<br />Box 2 has 2 boards- a clone of #1/#3, and the LED board containing a somewhat prominent Texas Instruments / MALAYSIA 8935AS SN74LS164N.  Which still doesn't look big enough to be a proper CPU.  (EDIT: THIS is a shift-register.  Serial-in-parallel-out shift reg, precisely, meaning it's probably taking a bitstream in and using it to drive all the LEDs at once - <!-- m --><a class="postlink" href="http://www.datasheetcatalog.com/datasheets_pdf/S/N/7/4/SN74LS164N.shtml">http://www.datasheetcatalog.com/datashe ... 164N.shtml</a><!-- m -->) <!-- m --><a class="postlink" href="http://www.psychsoftware.org/stuff/temp/photo/PowerGlove/P6020332.JPG">http://www.psychsoftware.org/stuff/temp ... 020332.JPG</a><!-- m -->
<br />
<br />Save copies of the photos if you want them; I'm not going to guarantee perma-hosting, at least not in that location.
<br />
<br />There's certainly nothing big enough to be a cop888 in any of those locations.  I seem to recall reading somewhere that the brain chip was indeed in the glove, which may mean it is on the backside of the D-pad PCB.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nocash</b> [ Sat Jun 02, 2012 11:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Many thanks for uploading the photos!
<br />
<br />Yes, the COP should be 44pin SMD chip on the control-pad board; since it's SMD, one can't see solder pads on the PCB-back-side photo that I've found.
<br />
<br />As how I understand the COP pinouts: The microwire feature is used to receive serial data from NES. And in the opposite direction, the 4021 parallel-in serial-out shift register is used to send serial data to NES.
<br />
<br />And there's a 8x3 keyboard matrix; 3 outputs, and 8 inputs; ie. the thing outputs a LOW level on one row, and checks if any column inputs go LOW (=button is pressed). The pull-ups are just there to drag the columns HIGH if the button isn't pressed (so there's just logic LOW and HIGH on that pins, no analog stuff).
<br />
<br />For the microphones, I'd have expected 3 inputs (though Tim has listed only two pins going to "near receivers") (but I'd guess there might be one more microphone pin somewhere).
<br />
<br />The whole NES data, LED data, and MICrophone data is squeezed through the 9pin connector on the junction box: Two pins for VCC and GND, three pins for NES connector, and presumably three pins for the microphones. That would would leave only 1 spare pin. Should be pretty impossible to control the six LEDs through that 1 spare pin...
<br />
<br />That's why I was suggesting that 4021 shift-register (and the wires in the cable) are shared for both COP-to-NES and COP-to-LED. So, the 4021's serial-output is wired both to NES, and to the 74LS165's serial-input on the LED board (and the 74LS165's parallel output then wired to the LEDs).
<br />
<br />With "Error Flags" I meant you "occlusion" byte, which would be the last byte transferred (If you are doing it the way as Super Glove Ball). So, in analog mode the LED bits should blink between 3Fh (1 frame; no errors) and FFh (2 frames, not ready).
<br />
<br />Bit0-3 of that value would be the four "direction-LEDs", bit4-5 would be "start/select" (which have no LEDs), and bit 6-7 would be the two "button LEDs".
<br />
<br />So, with the 3Fh/FFh values, the upper four LEDs should glow permanently, and lower two LEDs should flimmer (which may look as they are dimmed to medium brightness). At least, I'd think that it'd look like so in Glove Ball. EDIT: Or more likely vice-versa: FFh=All LEDs OFF, 3Fh=Lower 2 LEDs ON.
<br />
<br />During the transfer, all LEDs would blink more or less "randomly" while new data is shifted-in, but that should occur only for very short moments, probably one won't see that at all.
<br />
<br />Ah, okay, didn't knew that 3rd OBJ was intended for in your test program. I don't have transfer "timeouts" yet emulated, so packets in my emu doesn't run in sync with the test program - which caused the 3rd OBJ to jump randomly. Sorry for the confusion.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sun Jun 10, 2012 2:23 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">For the microphones, I'd have expected 3 inputs (though Tim has listed only two pins going to "near receivers") (but I'd guess there might be one more microphone pin somewhere). </div><br />If they're going to the LM324s in the junction box proper, those receiver pins may be the serial send/receive pins for communication with the NES.  This also makes sense because the WR# write pin is reported as tying directly to a LM324 pin, while the RD# read pin is reported as tying to likely some Resistor/Capacitor buffer before entering digital world.  The COP888 does have direct serial I/O capacity.  And in fact, certain write-ups describe that particular series of chips as being pathologically serial, even in the way it reads instructions from its own internal ROM.<br /><br />I also have some doubts that the designers would have necessarily allocated pins for all 3 mics and 2 speakers in parallel given that they only need one speaker/mic pair at a time.  I'd suspect the speakers are in the "from top of glove" pin set (in fact... XMTR is probably [trans]MiTteR).  The microphones are a little bit of a puzzle, but one which may be illuminated if we ask why 8 op-amp 'gates' are needed for 2, or at most 3, lines communicating with the NES, particularly when each mic PCB has its own dual op-amp chip.  My analog EE is very rusty, but I could see a possibility of them hacking together a primitive multiplexor or delay circuit to serialize the mic returns if there's no obvious parallel pin set on the COP888.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The whole NES data, LED data, and MICrophone data is squeezed through the 9pin connector on the junction box: Two pins for VCC and GND, three pins for NES connector, and presumably three pins for the microphones. That would would leave only 1 spare pin. Should be pretty impossible to control the six LEDs through that 1 spare pin...</div><br />I have seen no indication that the LEDs are programmer-accessible; read or write.  They seem to be automatically operated.  But with the serial-to-parallel chip boxed in on the LED PCB, one pin could very easily control all LEDs if the LED state is determined on the microcontroller.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">With "Error Flags" I meant you "occlusion" byte, which would be the last byte transferred (If you are doing it the way as Super Glove Ball). So, in analog mode the LED bits should blink between 3Fh (1 frame; no errors) and FFh (2 frames, not ready).<br /><br />Bit0-3 of that value would be the four "direction-LEDs", bit4-5 would be "start/select" (which have no LEDs), and bit 6-7 would be the two "button LEDs".<br /><br />So, with the 3Fh/FFh values, the upper four LEDs should glow permanently, and lower two LEDs should flimmer (which may look as they are dimmed to medium brightness). At least, I'd think that it'd look like so in Glove Ball. EDIT: Or more likely vice-versa: FFh=All LEDs OFF, 3Fh=Lower 2 LEDs ON.<br /><br />During the transfer, all LEDs would blink more or less "randomly" while new data is shifted-in, but that should occur only for very short moments, probably one won't see that at all. </div>
<br />
<br />If anything, it might make sense if the LEDs reflected <em>every single byte</em> of data output by the glove to the NES, not just one particular "final" field.  That's closer to the actual appearance of the LEDs. Very rarely is one lamp ever solidly illuminated in raw mode; I've only ever seen a combination of solid and flicker when I've gotten into really unorthodox configurations with more static garbage fields than dynamic data.
<br />
<br />But if the glove's output packets are splitting off to drive the LEDs, that's even more evidence that the output packets are serialized by the time they hit the junction box, as nothing in the junction box or frame would serialize the data prior to the LED serial-to-parallel chip.
<br />
<br />Reexamining my photos, it's fairly clear that the wiring through the frame is
<br />
<br />Box 1:
<br />- Hot (red)
<br />- Ground (black)
<br />- Mic1 data (brown)
<br />
<br />Box2:
<br />- all Box1
<br />+ Mic2 data (gray)
<br />+ LED data+clock (green/blue)
<br />
<br />Box3:
<br />- all Box1
<br />- all Box2
<br />+ Mic3 data (mic data likely recolored yellow/orange/pink on exit; not sure which is which without re-opening the box and looking at the trace side)
<br />
<br />From there, it would probably be easy enough to look at the traces on the junction PCB to see if blue/green share any connections with the to-NES port or figure out where yellow/orange/pink go.  I may try that at some point, but it sounds like you could really stand to get your own glove <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nocash</b> [ Mon Jun 11, 2012 8:49 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">one pin could very easily control all LEDs if the LED state is determined on the microcontroller.</div><br />The shift register (on the LED board) needs Data and Clk (two pins). <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If anything, it might make sense if the LEDs reflected every single byte of data output by the glove to the NES, not just one particular "final" field.</div><br />Yes, exactly. Just what I was saying. But you would barely see them (blinking only for very short moments), so only the final ones (which last for longer time) should be visible.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">That's closer to the actual appearance of the LEDs. Very rarely is one lamp ever solidly illuminated in raw mode; I've only ever seen a combination of solid and flicker when I've gotten into really unorthodox configurations with more static garbage fields than dynamic data.<br /></div><br />What's with the Super Glove Ball game? That should be the normal/official case... I couldn't find any videos or descriptions how it should look like.<br /><br />But I would stay with my theory: The two button LEDs should be flimmering, the four direction LEDs should be off - unless you cover the speakers/microphones, then some of the direction LEDs should flimmer, too (in respect to the lower 4 occlusion bits).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">it would probably be easy enough to look at the traces on the junction PCB to see if blue/green share any connections with the to-NES port or figure out where yellow/orange/pink go.</div>
<br />What traces? You've uploaded only component side photos. But, following traces on photos would be a pain anyways (easiest would be using a multimeter to check for 0 ohm connections).
<br />
<br />Yeah, having a glove at hand would be nice... and the NES CompuTrainer from RacerMate... and all the other odd NES controllers. But I don't have the money and storage to buy all that stuff.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Roni</b> [ Tue Jun 19, 2012 10:31 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Well it seems that the power glove does have ring finger control, in addition to thumb, index and middle fingers, but the middle one on mine is broken. (no response, FingersByte bits 2-3 stuck at "10")
<br />
<br />It's probably likeky that the flex sensor in these gloves degrades over time or was just fragile. I wonder if it can be repaired.
<br />
<br />So what's the verdict on the reads? Has it been determined if the glove can send a full packet of reliable data in less than three NTSC frames?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nocash</b> [ Mon Jun 25, 2012 6:32 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Less than 3 frames? No, I think the latest info was 4 frames, and sometimes 3 frames (see <!-- m --><a class="postlink" href="http://nesdev.com/bbs/viewtopic.php?p=92301#92301">http://nesdev.com/bbs/viewtopi ... 2301#92301</a><!-- m -->) the only later news was that there is the "ready byte", if you are polling it once per frame then you should get the possible rate, without getting into unstable situations. If 3 or 4 frames is too slow for your purposes - you could try to poll it more than once per frame; and maybe receive data every 2.5 or 3.5 frames.
<br />
<br />No idea if it's possible to repair the flex sensors, how they do look like, and if one can buy replacement parts. Is it difficult to disassemble them?
<br />If they are actually broken then you are probably in trouble - soldering would probably melt them, and conductive silver would probably break as soon as you flex the fingers. If you are lucky, then it's just a dirty contact between the wire &amp; sensor.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bavi_H</b> [ Sun Mar 03, 2013 2:37 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I don't have a Power Glove, but was reading about it today, and found the technical information in this thread very interesting.<br /><br />One additional thing I'm interested in is if it's possible to manually enter advanced programs on the glove's keypad.<br /><br />In the <a href="http://www.8-bitcentral.com/nintendo/powerGloveManual.html" class="postlink">Power Glove manual</a>, the Problems and Solutions (page 34) says (emphasis mine):<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">P: I would like to use different motions with the game I am playing.<br />S: The glove comes with 14 different programs, each with different moves. [...] Special games like Bad Street Brawler have more programs on them. <strong>There will also be special &quot;editing&quot; codes published in magazines for more games.</strong></div><br />This makes it sound like advanced programs could be manually entered on the glove keypad.<br /><br />I think it is unusual the glove requires you to press ENTER twice to load a program. Wouldn't one ENTER press suffice? I suspect there's a hidden reason two ENTER presses are required. Perhaps you are able to enter advanced programming steps after the first ENTER press and the second ENTER press finally ends the programming mode.<br /><br />Perhaps someone with a Power Glove would be interested in testing if undocumented key sequences in the programming mode have any effect...

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Sat Apr 06, 2013 10:28 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah... I haven't done much with the PowerGlove recently from a research standpoint, although there will be a new release of Nesglovphone with one or two new features as soon as I get around to doing a demo recording.  These days, if anything, my focus is shifting to Virtual Boy ( <!-- m --><a class="postlink" href="http://www.planetvb.com/content/downloads/documents/stsvb.html">http://www.planetvb.com/content/downloa ... stsvb.html</a><!-- m --> ), but that's a discussion for another thread.<br /><br />But so far as I remember, the bottleneck is not so much on sending the data- you can poll it to your heart's content just like any input device- the glove's internals simply can't build new packets instantaneously, so if you ask it to put a lit of data in the packet, you need to give it sufficient time to get ready.  If you want it to be ready faster, ask for fewer data fields.  I have no recollection of how/whether there was a &quot;ready&quot; byte and I'm too lazy to review the whole thread, but it would make a lot of sense if one does exist, and if so, yes, the process would be along the lines of: read header/ready byte -&gt; check &quot;ready&quot; state -&gt; if ready, read more (data packet) bytes.<br /><br />I could conceive of alternate explanations for needing to press Enter twice to change programs- early digital state machine systems were not always the prettiest hacks- but the notion of user-programmability is intriguing.  There is, with certainty, some small microcontroller in the glove, and my experiments with initialization codes seemed to suggest that there were swaths of data in there not necessarily related to normal intended operation.  The riddle which may never be answered is whether the raw data &quot;modes&quot; I discovered were intentional-but-not-yet-documented, or simply artifacts of deterministic program/junk data that was never intended to be indexed into.  That might help clear up whether &quot;programming&quot; modes via the keypad were a fully flexible specification system, or just a hypothetical back-door to get at similar deterministic alternate behavior that wouldn't be worth documenting until someone wanted/needed it.<br /><br />As to repair, I now have 2 Gloves (the one that came with my full setup, and a second which, in isolation, had likely long since been relegated to a costume prop), but I'm still not brave enough to do a teardown until one fails so absolutely that I can't use it for anything else.  The sensors are some manner of thin sheet laminated into the rubber fingers of the glove, so repairing/replacing them would be impossible without destroying the glove as-such (which is not to say that after surgery, you might not find another fabric glove to bond the electronics back onto).  The access screws for the rectangular block on the glove (the &quot;gamepad&quot;/keyboard) are accessible enough, but that's not where the flex sensor leads likely originate, and the screws to get into the oblong emitter nodule (assuming it's not just glued together) are on the far side of the glove fabric.  I'm pretty sure I've seen a few pics of both sets of internals, but didn't glean any earth-shakingly useful information from them at the time.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>slobu</b> [ Tue Apr 09, 2013 1:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Seems to me the boys that played with VR and attaching the PowerGlove to the PC par. port would have figured out the mysteries.  I wonder if any good FAQs still exist from those days..

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Tue Aug 26, 2014 6:13 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><strong><span style="font-size: 200%; line-height: normal">BIG AND I MEAN HUGE NEWS</span></strong><br />When poking around for resources on the Miracle Piano, I stumbled across the website of Paul White, one of the retired original engineers on the Miracle and Power Glove.  After striking up a conversation, he was willing to share the recollections and resources he had accumulated.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The power glove used a special control script to convert various gestures into Nintendo button presses.  I think you would punch in the appropriate code on the PG keypad to select the gesture template for the game you wanted to play.  The PG to Nintendo interface was simple, like a button controller, so standard games would work without modification.  As I see you know, there was also the raw mode, where special software on the Nintendo side could read the various glove parameters directly.</div><br /><br />Of course, that isn't too new.  What is new and merits a big, long, <br /><span style="font-size: 150%; line-height: normal">drumrollllllllllllllllll....</span><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I found some nice Power Glove information for you.  The source code and<br />various utilities are available here:<br /><br />[attached to post]<br /><br />The PG uses a National Semiconductor COP888 microcontroller.<br />You may be able to find info about the assembly language syntax on the<br />web.  If not, I may still have some data books around somewhere.<br /><br />I haven't tried running the NGL.EXE program, but I seem to recall it has<br />something to do with generating gesture templates, or some such.</div><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">ASM888.EXE COP888 assembler<br />HEXLM.EXE Hex to Load Module utility<br />LMHEX.EXE Load Module to Hex utility<br />NGL.EXE Nintendo Glove Language utility ?<br />PG.MAC Main Power Glove source<br />PGCON.INC Power Glove constants<br />PGMEM.INC Power Glove memory definitions<br />PGTEMPL.INC Power Glove template include file<br />COP888.INC COP888 header file </div><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Most of the assembly code is pretty straightforward reading, with the possible exception of the &quot;X&quot; command.  As I recall, the COP processor doesn't have a STORE command as such, but it does have an eXchange command that swaps the accumulator with the specified memory location.<br /><br />Unfortunately I don't have copies of the PG schematic, because it wasn't created on my computer.  I think I must have worked from a printed copy, which I no longer have.  There are references in the code to some &quot;high voltage&quot; stuff.  There was an output pin connected to an inductor/diode/capacitor circuit, and it had to be pulsed periodically to generate a high voltage for the piezoelectric ultrasonic beepers.  They needed a fairly high voltage to get loud enough to provide a reasonable range.  You can probably figure out the rest.</div><br /><br />Yes, to all initial indications, this is <span style="font-size: 150%; line-height: normal">THE SOURCE TO THE EXECUTABLE CODE EMBEDDED ON THE ONBOARD PROCESSOR OF THE POWER GLOVE</span>.  I say &quot;to all initial indications&quot; because I don't have time right now to fully investigate, but the source and comments look believable, and if it is, this is huge and ought to crack the whole apparatus wide open to proper emulation.<br /><br />* editorial note: being in software development myself, I could easily see how this might be an earlier or later version than actually ended up on the Glove if it's just the copy that Paul dropped on a floppy for his own collection.  Still, it's NaN% more than I think we've ever had to work with, and odds are since he did the actual coding and had his hands on the source most readily, even <em>if</em> it isn't the shipped build, it's pretty darn close and ought to at least be concretely testable against actual Glove behavior.

		
			<br clear="all" /><br />

			<table class="tablebg" width="100%" cellspacing="1">
			<tr>
				<td><b class="genmed">Attachments: </b></td>
			</tr>
			
				<tr>
					<td>
			<span class="gensmall"><b>File comment:</b> PowerGlove onboard controller source &amp; tools</span><br />
		
			<span class="genmed">
				<img src="./styles/subsilver2/imageset/icon_topic_attach.gif" width="14" height="18" alt="" title="" /> 
				<a href="./download/file.php?id=1914">PGarchive.zip</a> [96.64 KiB]
			</span><br />
			<span class="gensmall">Downloaded 68 times</span>
		

		<br />
	</td>
				</tr>
			
			</table>
		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Tue Aug 26, 2014 6:57 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />...and of course BATCAVE is the re-entry point to BATLOOP.  Makes perfect sense.  And ye gods this is well-commented.<br /><br />I have not experienced this much happy while reading ASM since digesting the Virtual Boy sacred scrolls  <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> <br /><br /><div class="quotetitle">PG.MAC wrote:</div><div class="quotecontent">; Set up upload pointers<br />;<br />BT:<br />	LD	A,[B]<br />	RLC	A		; Locate bitmap of upload values in template<br />	AND	A,#01E		; mask all but gesture byte count<br />	INC	A		; Add 2 for template header and logic byte<br />	INC	A		; count <br />	ADD	A,#TEMPLATE<br />	X	A,B<br />	LD	A,[B+]		; Save bitmap in GSTAT<br />	X	A,GSTAT1<br />	LD	A,[B+]<br />	X	A,GSTAT2	; <br />; Build list of data addresses following logic in template<br />	LD	A,B		; RAM address in B is transferred to X<br />	PUSH	A<br />	X	A,X		; 	<br />	POP	A<br />	X	A,GBASE		; Save pointer for upload routine to use<br /><br />	LD	CREG,#0		; Initialize bit counter<br />BATLOOP:<br />	LD	A,CREG<br />	JSR	GBX		; Get B pointer to GSTAT1 or 2 and A=bitmask<br />	AND	A,[B]<br />	IFNE	A,#0<br />	JP	PUTONE<br />BATCAVE:<br />	JSR	INCREG		; Increment CREG<br />	IFNE	A,#15		; (value of CREG before incrementing) = 15 ?<br />	JP	BATLOOP<br /><br />	LD	A,#0FF<br />	X	A,[X]		; Put FF marker at end of list<br />	JMP	ZSTAT<br /><br />PUTONE:				; Put a pointer in the table<br />	LD	A,CREG<br />	ADD	A,#L(IATABLE)<br />	LAID<br />	X	A,[X+]<br />	JP	BATCAVE<br /></div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>thefox</b> [ Wed Aug 27, 2014 3:18 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Pretty cool! The tools run fine in DOSBox.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bavi_H</b> [ Tue Feb 03, 2015 9:37 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Previously:<br /><ul><li>The Power Glove manual mentions <a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854&amp;start=45#p108715" class="postlink">&quot;special editing codes&quot;</a>, maybe pressing something between the first and second Enter press would do something?</li><li>The <a href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=5854&amp;start=45#p133125" class="postlink">source code</a> for the Power Glove onboard processor executable code</li></ul><br />I immediately looked over the source code when it was posted, and it does suggest some editing abilities are available from the Power Glove's keypad. I had wanted to re-examine the code to make sure I didn't make any mistakes, but I haven't had time. For now, here are some notes from when I last looked at it (September 2014).<br /><br />In the descriptions below, n is a decimal digit, and x, y, and z are hexadecimal digits. [ ]* means you can press the enclosed sequence 0 or more times. To enter hexadecimal digits, use the following buttons:<br /><br />digit: A B C D E F<br />button: A B Left Up Down Right<br /><br /><br />Press Prog to enter the program mode. In the program mode, you can press:<br /><br /><blockquote style="margin-left: 1%; padding-left: 1%; border-left: 3px solid #555577;">
n Enter<br />Load template n.<br /><br />n n Enter <br />Load template nn.<br /><br />A x Enter y y [z z]* Enter<br />Insert a gap of x bytes starting at offset yy in the template definition bytes, then begin overwriting with bytes zz.<br /><br />B x Enter y y [z z]* Enter<br />Delete x bytes starting at offset yy in the template definition bytes, then begin overwriting with bytes zz.
</blockquote><br />You can press Prog to clear the last digit (or byte? need to check the code again to confirm).<br /><br />You can chain load and edit commands one after another. After your last command, press Enter a second time to exit the program mode.<br /><br />Also, you can press Prog Prog Prog to reset all. (That is, press Prog to enter programming mode, then Prog Prog to reset all.)<br /><br /><br />I may have made some mistakes interpreting the code. And we aren't sure if the code is the same as used on production units.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>LoneKiltedNinja</b> [ Mon May 04, 2015 4:26 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: the Power Glove</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />A new potential side project led me back to my old PG notes, they in turn led me more properly into the PG.MAC source code, and while I didn't find answers to the raw-mode questions I had, I did conclusively find the section related to parsing the input stream for custom joypad processing.  Nocash got remarkably close in his analysis; I can only really provide confirmation.<br /><br />Omitting the very first header byte, packet length, which (perhaps naturally) does not appear to be part of the TEMPLATE data proper, the structure does appear to be a header byte preceding N 16-bit gesture definitions, followed by a second header byte and N 8-bit gesture-logic statements.<br /><br />Specifically,<br /><br />Line 2041 of PG.MAC begins what is likely the parsing section for what were previously termed the “16-bit opcodes”, referring to a “gesture header byte” and a “gesture data byte”<br /><br />I am assuming TEMPLATE is the address of the start of the received message structure.<br /><br />First, an initial gesture address GADDR is computed (1 byte after TEMPLATE) and cached.<br /><br />Then, the contents of address TEMPLATE are loaded, masked with 0x0F, and interpreted as the count of gestures to follow; consistent with earlier reverse-engineering of the “16-bit Block Header.”<br />If &gt;0, this count is stored in NYREG and gesture loop counter GNUM is initialized to 1.<br /><br />Looping over an incrementing GADDR, 2 bytes are read (cached by address) for each gesture entry:<br /><br />The first byte is a header and gets masked by 0x3F prior to processing.  It would appear this mask is used to ignore “last state” and “1-shot” flag bits.<br />The second byte is a data byte; cached in X.<br /><br />If the entire gesture header (after the 3F mask) is 0x00, this is a noop (“A gesture type of 00 would be flex with no fingers set in the bitmap”).<br />otherwise, the header byte is masked with 0x03 and is identified as one of<br />00b = flex-only<br />01b = position<br />10b = orientation<br />11b = “D. POSITION” (unknown term)<br /><br />Values of 0 and 2 (00b and 10b) are explicitly tested to jump to respective GFLEX and GORIENT subroutines; 1 and 3 (01b and 11b) fall through, caching some convenience variables before entering the position subroutine GPOSITION.<br /><br />GPOSITION interprets the cached X data byte as a “vector” lookup.  It RLCs the value (presumably arithmetic rotate-left with carry) to double it, then masks it with 0x06, apparently to isolate vales (in the 2 masked-in bits) of<br />00b = X-axis<br />01b = Y-axis<br />10b = Z-axis<br />11b = don’t-care<br />before adding the masked value to a base address, using the resulting address (by storing it in B and then loading from the addresses contained in “B+” (postincrement) and B) to look up what appears to be the current and old position vectors (on that axis?)<br />Flow then JSRs into GADB, with a comment indicating that the data pointer in B is to the gesture header byte (presumably upon return, as it is not so going in).<br />The header (data at address B) is bit-tested (REL = bit 2, according to PGCON.INC) to determine if an absolute or relative gesture is being specified; relative jumps to subroutine RELATIVE, absolute falls through.<br /><br />ABSOLUTE evaluation logic appears, in a nutshell, to:<br />- check whether the gesture data byte is direction-consistent with the current ongoing direction vector (CURR) sign, aborting/resetting detection otherwise<br />- take the absolute value of the current vector (CURR)<br />- shift-mask the data byte (X) down to 6 bits even: 2 arithmetic right rotations followed by a mask with 0x3E, retaining 2 of the top 4 and 3 of the bottom 4 bits<br />- test/return if the processed data value is greater than the CURR ongoing gesture vector<br /><br />subsequent comments/subroutines indicate that only the largest single-axis (x/y/z) gesture so-detected will return as true/triggered, and only if it was previously false.<br /><br />RELATIVE evaluation logic is trickier, and appears to<br />- look up a “turning point” (cached in TURN) by first masking the data byte (X) by 0x03 to get an axis code (as before) then adding that to TURNX (presumably a table address), and reading the data in the resultant address (via B)<br />- subtract the TURN point from the CURR current vector (cacheing the result in CMT)<br />- GADB-lookup the header and shift-mask it into a “RESET” value: 1 arithmetic right rotate, mask with 0x1C to “Keep 5 bit magnitude, 3 bit resolution” and cache it in CREG.  So apparently the original header was a 2-bit requested data type and a 3-bit reset value of still-ambiguous function.<br />- perform a sophisticated walk down a table of tristate gesture component definitions, continuing to track the gesture I believe so long as the current gesture is positively matched (PTRUE) and the next gesture is not yet evaluated (RFALSE) as opposed to definitively nonmatched (NTRUE); PTRUE and NTRUE being determined by +/- difference from SET (X data value, processed to 6-bit similarly to before)<br />- reset the turn point for detection if the current vector (C===CURR) and turn point (T===CMT===CURR-TURN) both exceed the last vector(?); fail if the difference between the current vector and turn point exceeds the reset threshold CREG as previously computed.  Meaning the original header was a 2-bit requested data type and a 3-bit reset sensitivity, or to borrow the format of subsequent comments:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; Motion gesture Header byte:<br />; Last&nbsp; &nbsp;/1 shot&nbsp; &nbsp;/ RESET (3)&nbsp; &nbsp;/RELATIVE (1)&nbsp; &nbsp;/ 0&nbsp; &nbsp;/ 1&nbsp; &nbsp;;<br />;<br />; Data byte:<br />;&nbsp; SET (5)&nbsp; &nbsp;/&nbsp; DIRECTION / AXIS (2)&nbsp; &nbsp;/<br />;<br /></div><br /><br /><br /><br />Finger gesture processing is probably best summarized by the big comment<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; Flex gesture Header byte:<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- second finger&nbsp; &lt;-- first finger &lt;--<br />; Last&nbsp; &nbsp;/1 shot&nbsp; &nbsp;/THUMB&nbsp; &nbsp;/INDEX&nbsp; &nbsp;/MIDDLE&nbsp; &nbsp;/RING&nbsp; &nbsp;/ 0&nbsp; &nbsp;/ 0&nbsp; &nbsp;;<br />;<br />; Data byte - Set bitmap:&nbsp; 2nd finger / first finger<br />;&nbsp; 3&nbsp; &nbsp;/&nbsp; 2&nbsp; &nbsp;/&nbsp; 1&nbsp; &nbsp;/&nbsp; 0&nbsp; &nbsp;/&nbsp; 3&nbsp; &nbsp;/&nbsp; 2&nbsp; &nbsp;/&nbsp; 1&nbsp; &nbsp;/&nbsp; 0&nbsp; &nbsp;/<br />;<br />; Finger map specifies 1 or 2 fingers.&nbsp; If both are true,<br />; gesture becomes true.&nbsp; If either are false, gesture becomes false.<br /></div><br />indicating a system of looking for “bitmap” levels on either 1 or 2 fingers and returning an AND match<br /><br />likewise with orientation<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Orientation gesture Header byte:<br />;<br />; Last&nbsp; &nbsp;/1 shot&nbsp; &nbsp;/&nbsp; &nbsp;/&nbsp; &nbsp;/&nbsp; &nbsp;/&nbsp; &nbsp;/ 1&nbsp; &nbsp;/ 0&nbsp; &nbsp;;<br />;<br />; Data byte:<br />;<br />; End position &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/ Start position &nbsp; &nbsp;&nbsp; &nbsp;;<br />;<br /></div><br />which match nocash’s analysis rather precisely.<br /><br />The only mystery is whether the single 0x0800 entry present in the gesture block of the “raw mode” packet is anything more significant than a vacuous middle finger.<br /><br /><br />Parsing then proceeds to a “Gesture logic” (line 2499) statement parser/processor which begins with a check of bit 7 of (presumably) what we’ve been calling the 8-bit section header, aborting back to the main loop if true (meaning the “extra 6 bytes” nocash observed are doubly confusing…)<br /><br />From here (line 2506), things begin to get crazy, appearing (as nocash surmised) to be a whole metalanguage of “logic statements,” “indent states,” truth tables, processes, etc., implemented in assembly, to act on bytecode, all for the purpose of chaining the defined gestures (16-bit opcodes) into evaluation sequences to yield true/false button states.<br /><br />The 8-bit opcodes appear to reduce to control codes in the low 3 bits of the high nybble as defined <br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">LOGJMP:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Logic statement jump table<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LTMPN)&nbsp; &nbsp;; 0<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LIFG)&nbsp; &nbsp;&nbsp; &nbsp;; 1<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LTIFG)&nbsp; &nbsp;; 2<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LEIFG)&nbsp; &nbsp;; 3<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LANDG)&nbsp; &nbsp;; 4<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LORG)&nbsp; &nbsp;&nbsp; &nbsp;; 5<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LENDIF)&nbsp; &nbsp;; 6<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(LELSEDO)&nbsp; &nbsp;; 7<br /></div><br />Those 8 control codes jump to handlers with header comments as follows:<br /><br />LTMPN<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Load template N now, then restart.<br /></div><br />editorial note: “template” appears to be the internal term for a set of gestures + logic, or in our nomenclature, 16-bit + 8-bit opcodes<br /><br />LIFG<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;IF (G)&quot;<br />; evaluates the state of gesture G and sets the state<br />; of the current indent level accordingly if the state of the<br />; previous indent level is true.<br />;<br /></div><br /><br />LTIFG<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;THEN IF (G)&quot;<br />; increments the indent level if the indent flag<br />; is clear and then performs an IF (G)<br />;<br /></div><br /><br />LEIFG<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;ELSE IF (G)&quot;<br />; decrements the indent level and clears the indent flag.<br />;<br /></div><br /><br />LANDG<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;AND (G)&quot;<br />; evaluate the state of gesture G and perform a logical<br />; AND with the state of the current indent level<br />;<br /></div><br /><br />LORG<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;OR (G)&quot;<br />; evaluate the state of gesture G and perform a logical<br />; OR with the state of the current indent level<br />;<br /></div><br /><br /><br />LENDIF<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;ENDIF&quot;<br />; decrements the indent level<br />;<br /></div><br /><br />LESLEDO<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; &quot;ELSE DO&quot;<br />; pre-decrement the indent level, set current state,<br />; post-increment the level and set the indent flag.<br />;<br /></div><br /><br />For standard statements (high nybble 0-7), the low nybble is parsed by the EVAL subroutine, which farms the actual parsing off down another rabbit hole, but it looks like it contains a 1-based (1-16 range) index for the 16-bit gesture entry to operate on.  Actual parsing process is<br />- load the byte into A<br />- mask in the low nybble (by AND with 0x0F)<br />- subtract 1<br />- load into B the address of either a (presumably) gesture evaluation state array (GSTAT1) if A&lt;=7 or status flags (GSTAT2) if A&gt;7<br />- mask down to the low 3 bits (AND 0x07)<br />- use headache-inducing indirect lookup magic to compute 2^A and store it back in A<br />- use A as a mask into the data at B (AND A,[B]) and return whether that result is true (0xFF) or false (0x0)<br /><br />A value of 0 in the low nybble appears to just set a flag to trigger a beep.<br /><br />A value of 8 or higher in the high nybble indicates THEN (0x8_-0xB_) or ELSE (0xC_+) commands, which appear at first glance to conditionally increment the “indent” level and proceed based on the truthiness of the previous statement or decrement the “indent” level and update the current truthiness consistent with prior and current level results.  They also both flow through to a further DoAction handler which calls out that 0xB_ or 0xF_ statements invert the referenced gesture.  Subsequent lines seem to indicate this is an inversion of the gesture’s result status or corresponding output bit/byte.<br /><br />The low nybble, if nonzero, triggers actions based on previously defined gestures.<br /><br />If &gt;0x08, special handling (DoSpecial) is invoked.  This turns out to be another straightforward jump table:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">SPECJP:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Jump table for special actions<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(EndAction)&nbsp; &nbsp;; 9<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(CTR1CE)&nbsp; &nbsp;; 10<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(CentAll)&nbsp; &nbsp;; 11<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(CentX)&nbsp; &nbsp;; 12<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(CentY)&nbsp; &nbsp;; 13<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(CentZ)&nbsp; &nbsp;; 14<br />&nbsp; &nbsp;.BYTE&nbsp; &nbsp;L(ResAct)&nbsp; &nbsp;; 15<br /></div><br />for noop (EndAct), conditionally resetting everything if it hasn’t been done before (CTR1CE), centering All/X/Y/Z axes (Cent*), or resetting the flex, center-once and beep flags (ResAct). <br /><br />Otherwise, the corresponding button-bit of the NES joypad is selected (modulo a swap flag which can cause A and B (0x07 and 0x08) to be swapped) and cached on the stack.  The original instruction’s bits masked by 0x30 are then checked to see if the action being defined should be “pulsed 2” (0x20), “pulsed 1” (0x10) or continuous (0x0).  I.e., out of the original high nybble, which by now we have determined to be on the 0x8_-0xF_ range, the codes 0x8_ and 0xC_ are continuous actions, 0x9_ and 0xD_ are “pulsed 1”, and 0xA_ and 0xE_ are “pulsed 2”.  The remaining 0xB_ and 0xF_ were covered earlier in the inversion clause.<br /><br /><br />So basically, again in a representation akin to other source comments,<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">;<br />; Logic Statement<br />;&nbsp; EXT&nbsp; &nbsp;/&nbsp; STATEMENT (3)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/&nbsp; OPSET&nbsp; &nbsp;/&nbsp; OPERAND&nbsp; &nbsp;(3)&nbsp; &nbsp;&nbsp; &nbsp;/<br />;<br /></div><br />If EXT is 0 then STATEMENT is a basic control command, and based on OPSET, the command is evaluated with the current value of either the gesture (OPSET=0) or status flag (OPSET=1) indexed by OPERAND.<br /><br />if EXT is 1 then STATEMENT is an action command as<br />000b = THEN continuous trigger<br />001b = THEN 1-pulse trigger<br />010b = THEN 2-pulse trigger<br />011b = THEN inverted trigger<br />100b = ELSE continuous trigger<br />101b = ELSE 1-pulse trigger<br />110b = ELSE 2-pulse trigger<br />111b = ELSE inverted trigger<br /><br />For further help interpreting, it may be useful to consult a COP888 datasheet.  I found one at  <!-- m --><a class="postlink" href="http://www.engineering.uiowa.edu/sites/default/files/ees/files/NI/pdfs/01/08/DS010830.pdf">http://www.engineering.uiowa.edu/sites/ ... 010830.pdf</a><!-- m -->

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>4</strong> of <strong>4</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>