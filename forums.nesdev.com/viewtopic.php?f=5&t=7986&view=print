<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - How did your programming style develop over time?</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">How did your programming style develop over time?</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=5&amp;t=7986">http://forums.nesdev.com/viewtopic.php?f=5&amp;t=7986</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>psycopathicteen</b> [ Mon Jul 18, 2011 8:08 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>How did your programming style develop over time?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Lately, after a about 9 months of taking a break at programming I am going back into it fully refreshed.  But this time I'm making a few changes to the way I'm doing it.
<br />
<br />
<br />1.) Using simpler graphics, so I have more time to work on game mechanics
<br />
<br />2.) Using the stack pointer more often, so I don't need to waste a register that I'm only going to use once.
<br />
<br />Instead of doing this:
<br />
<br />stx register
<br />clc
<br />adc register
<br />
<br />I now do this:
<br />
<br />phx
<br />clc
<br />adc $01,s
<br />plx
<br />
<br />3.) I check my work for errors before I test it, instead of checking it after.
<br />
<br />4.) I write my subroutines on other docs first so I don't have the navigational confusion of scrolling my code document up and down to find anything.
<br />
<br />5.) I use labels for everything now.  I realized after everybody kept bugging me to label everything, how much easier it is when you start labeling everything from the beginning.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Mon Jul 18, 2011 8:40 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I got a lot better about label and variable names, and having useful comments on the more complicated parts.  I try to have the code be as self-descriptive as possible, and let the comment say why I'm doing something.
<br />
<br />I think I sorta knew what all the best practices were, but didn't really start doing better until I realized most of the code I wrote originally was garbage (when trying to come back to work on it after a long time).  If it takes as long to figure it out and debug it as it does to rewrite it, then it's of no use.
<br />
<br />I started using macros a lot more, building up a little library of often-used bits of code.  But in any other program, if it's something that appears more than once, and isn't a plain subroutine (without parameters), it's probably a candidate for being a macro.  Because then if you change it, you only need to change it in one place.  With CA65 at least, you can do quite a lot with macros.
<br />
<br />3)  Yeah me too, the worst typos are the ones that will still result it in it compiling/assembling, and 'debugging' it mentally can be faster than doing trial-and-error before debugging it.
<br />
<br />4)  Yeah that helps too, usually what I've been doing more often is if some part of the code/data is finished, I move it into an include file so it's no longer in the workspace.
<br />
<br />5) That too, I started naming a lot more of the constants (in all caps too).
<br />
<br />I started using expressions for constants a lot more too, whenever useful, and I try to use labeled constants instead of numbers, that's almost always more descriptive than a number.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Mon Jul 18, 2011 10:05 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: How did your programming style develop over time?</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">psycopathicteen wrote:</div><div class="quotecontent">2.) Using the stack pointer more often, so I don't need to waste a register that I'm only going to use once.<br /><br />Instead of doing this:<br /><br />stx register<br />clc<br />adc register<br /><br />I now do this:<br /><br />phx<br />clc<br />adc $01,s<br />plx</div>
<br />
<br />This only works on 65816 (there's no stack-based addressing modes on 6502); I only point that out cuz this post isn't in the SNESdev forum so I was like "eh?".  :-)  Worse, stack-based addressing is dogshit slow.  You truly are better off using registers if you can.
<br />
<br />On a 3-register architecture like the 65xxx series yeah, every register is important, but don't feel bad storing data in DP/ZP temporarily to free up use of a register.  It's faster than the stack, and most architectures have decent amounts of RAM.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>mic_</b> [ Mon Jul 18, 2011 10:47 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />As has already been mentioned: trying to name things properly, which can be a bit of a challenge in assembly code because you risk overdoing it. If you have an IF/ELSE-type construct, or a SWITCH/CASE, or a small loop, then sometimes ananymous labels can actually be the best thing IMO (instead of having labels like 'check_keypress_not_button_a' or 'delay4').
<br />And trying to use constants/defines to avoid magic numbers.
<br />
<br />Oh, and better indentation. When I first started programming I used zero indentation, which made the code look horrendous. I also used to avoid {} in C whenever I could (think nested if/for/while-statements with no {}), which I'm trying not to do as much anymore.
<br />
<br />I'm still more lax about coding practices for my own projects than when I'm at work though. When I code at work I have to follow a certain code standard so that the code looks the same no matter who the author is, and to make it easier for others to review. When I work on my own projects I usually just hack away, and then I clean it up afterwards if I feel that it's something that I'm ever going to want to revisit.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>qbradq</b> [ Tue Jul 19, 2011 5:08 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I am big on lexical scoping to help out with descriptive names. I'm so big on it that I wrote a CA65-compatible assembler that had proper scope handling just so I could use it <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" />
<br />
<br />Here's an example of what I'm talking about. I have a nearly 400 line subroutine for handling scrolling updates on my NROM project. I have assigned each section of the code to a scope, and each loop within those sections has its own scope as well. This way I can use labels just as loop, next and exit multiple times within the same subroutine without confusion. Also, when using Notepad++ to edit this code I can fold everything up and have a nice synopsis of the code.
<br />
<br />Synopsis View:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Handles level scrolling updates<br />.proc scroll<br />&nbsp; &nbsp;; See if we need to load another column<br />&nbsp; &nbsp;.scope check_need_to_scroll<br />&nbsp; &nbsp;&nbsp; &nbsp;; Load the level data<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope load_data<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;; Update the level data<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope update_data<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;; Blit the left- or right-hand side of a column<br />&nbsp; &nbsp;.scope check_blit<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;.scope do_left<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope do_right<br /><br />&nbsp; &nbsp;.scope check_attr<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Generate the PPU string<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope generate_ppu_string</div><br /><br />Full Listing:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">; Handles level scrolling updates<br />.proc scroll<br />&nbsp; &nbsp;; See if we need to load another column<br />&nbsp; &nbsp;.scope check_need_to_scroll<br />&nbsp; &nbsp;&nbsp; &nbsp;lda scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp #scroll_states.none<br />&nbsp; &nbsp;&nbsp; &nbsp;beq continue<br />&nbsp; &nbsp;&nbsp; &nbsp;jmp check_blit<br />&nbsp; &nbsp;continue:<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; The pixel scroll position / 16 is the tile at the left-hand side of<br />&nbsp; &nbsp;&nbsp; &nbsp;; the screen. Remember that level_pos is a 24-bit number.<br />&nbsp; &nbsp;&nbsp; &nbsp;lda level_pos + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;sta tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;lda level_pos + 2<br />&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;ror tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;ror tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;ror tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;ror tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Add 31 to see what our next column should be, and if it's greater<br />&nbsp; &nbsp;&nbsp; &nbsp;; than map_nextcol we kick off the loading process.<br />&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;lda tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;adc #31<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;bcs load_data<br />&nbsp; &nbsp;&nbsp; &nbsp;rts<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Load the level data<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope load_data<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldx #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;byte_loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;map_ptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;map_ptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;iny<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpy #6<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;bne byte_loop<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Update the map pointer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_ptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #map_file_pitch<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta map_ptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_ptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta map_ptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Update the level data<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope update_data<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Set up our output pointer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$1f<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #&lt;map_buffer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #&gt;map_buffer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Copy everything in<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldx #0<br />&nbsp; &nbsp;&nbsp; &nbsp;byte_loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda load_buffer,x&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Load the tile number<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Load the tile's upper flag bits and<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.flags,y&nbsp; &nbsp;; store them along with the tile index<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$f0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ora tempA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta &#40;fptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpx #map_height_tiles<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;beq exit<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #map_buffer_pitch<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;jmp byte_loop<br />&nbsp; &nbsp;&nbsp; &nbsp;exit:<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Update our load state and return<br />&nbsp; &nbsp;&nbsp; &nbsp;inc scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;rts<br />&nbsp; &nbsp;exit:<br />&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;; Blit the left- or right-hand side of a column<br />&nbsp; &nbsp;.scope check_blit<br />&nbsp; &nbsp;&nbsp; &nbsp;lda scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp #scroll_states.blit1<br />&nbsp; &nbsp;&nbsp; &nbsp;beq continue<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp #scroll_states.blit2<br />&nbsp; &nbsp;&nbsp; &nbsp;beq continue<br />&nbsp; &nbsp;&nbsp; &nbsp;jmp check_attr<br />&nbsp; &nbsp;continue:<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Calculate the base name table address<br />&nbsp; &nbsp;&nbsp; &nbsp;ldx #$20&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Base page for name table 1<br />&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;and #$10<br />&nbsp; &nbsp;&nbsp; &nbsp;beq nt1<br />&nbsp; &nbsp;&nbsp; &nbsp;ldx #$24&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; We are hitting name table 2<br />&nbsp; &nbsp;nt1:<br />&nbsp; &nbsp;&nbsp; &nbsp;stx wordA + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Base column offset is &#40;col % 16&#41; * 2 + 128<br />&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;and #$0f<br />&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;ora #$80<br />&nbsp; &nbsp;&nbsp; &nbsp;sta wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;lda scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp #scroll_states.blit1<br />&nbsp; &nbsp;&nbsp; &nbsp;beq skip_right_offset<br />&nbsp; &nbsp;&nbsp; &nbsp;inc wordA&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Adjust for right-column<br />&nbsp; &nbsp;skip_right_offset:<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Generate PPU string<br />&nbsp; &nbsp;&nbsp; &nbsp;ldx ppu.ppu_string_idx<br />&nbsp; &nbsp;&nbsp; &nbsp;beq skip_head<br />&nbsp; &nbsp;&nbsp; &nbsp;dex<br />&nbsp; &nbsp;skip_head:<br />&nbsp; &nbsp;&nbsp; &nbsp;lda wordA + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;ora #$80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Flag the PPU handler to use 32-byte increments<br />&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;lda wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;lda #map_height_tiles * 2<br />&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;inx<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;lda scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;cmp #scroll_states.blit1<br />&nbsp; &nbsp;&nbsp; &nbsp;beq do_left<br />&nbsp; &nbsp;&nbsp; &nbsp;jmp do_right<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope do_left<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda load_buffer,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;iny<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sty tempY<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.tl,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.bl,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy tempY<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpy #map_height_tiles<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;bne loop<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;jmp do_right.exit<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope do_right<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda load_buffer,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;iny<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sty tempY<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.tr,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.br,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy tempY<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpy #map_height_tiles<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;bne loop<br />&nbsp; &nbsp;&nbsp; &nbsp;exit:<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Complete the PPU string<br />&nbsp; &nbsp;&nbsp; &nbsp;lda #$ff<br />&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;stx ppu.ppu_string_idx<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;; Update our load state and return<br />&nbsp; &nbsp;&nbsp; &nbsp;inc scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;rts<br />&nbsp; &nbsp;.endscope<br /><br />&nbsp; &nbsp;.scope check_attr<br />&nbsp; &nbsp;&nbsp; &nbsp;; Generate attributes in one shot<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope generate_attributes<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Set up our base pointer, which is map_buffer + &#40;map_nextcol &amp; 0x1e&#41;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #&lt;map_buffer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #&gt;map_buffer<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$1e<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Loop through all of the attribute bytes we need<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldx #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;byte_loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Top-left<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;fptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Mask out the flag bits<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.flags,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #data.tileset_flags.palette<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Top-right<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;fptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Mask out the flag bits<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.flags,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #data.tileset_flags.palette<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ora load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Increment pointer to next row<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #map_buffer_pitch<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Bottom-left<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;fptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Mask out the flag bits<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.flags,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #data.tileset_flags.palette<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ora load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Bottom-right<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda &#40;fptr&#41;,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Mask out the flag bits<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tay<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda data.tileset.flags,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #data.tileset_flags.palette<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;asl<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ora load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta load_buffer,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Increment pointer to next row<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #map_buffer_pitch<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta fptr + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Loop check<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpx #map_height_tiles / 2<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;beq done<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;jmp byte_loop<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;done:<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Generate the PPU string<br />&nbsp; &nbsp;&nbsp; &nbsp;.scope generate_ppu_string<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Our attribute base offset is $23c0 + 8 + &#40;map_nextcol &amp; 0x0f&#41; / 2<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$0f<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lsr<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ora #$c8<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Name table selection<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda map_nextcol<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;and #$10<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;beq nt1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #$27<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;jmp nt_done<br />&nbsp; &nbsp;&nbsp; &nbsp;nt1:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #$23<br />&nbsp; &nbsp;&nbsp; &nbsp;nt_done:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta wordA + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Start the PPU string&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldx ppu.ppu_string_idx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;beq skip_head<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;dex<br />&nbsp; &nbsp;&nbsp; &nbsp;skip_head:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Generate the strings to update six attribute bytes<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ldy #0<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;byte_loop:<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Set up the address<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda wordA + 1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #1<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Attribute byte<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda load_buffer,y<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Advance one attribute row down<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;clc<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;adc #8<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta wordA<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Loop<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;iny<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cpy #6<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;bne byte_loop<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Terminate the PPU string<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;lda #$ff<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sta ppu.ppu_string,x<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inx<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;stx ppu.ppu_string_idx<br />&nbsp; &nbsp;&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp;&nbsp; &nbsp;; Update our states<br />&nbsp; &nbsp;&nbsp; &nbsp;lda #0<br />&nbsp; &nbsp;&nbsp; &nbsp;sta scroll_state<br />&nbsp; &nbsp;&nbsp; &nbsp;inc map_nextcol<br />&nbsp; &nbsp;.endscope<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;rts<br />.endproc</div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Ian A</b> [ Tue Jul 19, 2011 7:30 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I use a lot less magic numbers and a lot more constants.
<br />
<br />I've gotten much better at code organization, but I could still improve a lot in that area.  At least now when I have to rewrite a poorly coded section, I only have to rewrite that small section.
<br />
<br />I've gotten into using a lot of macros.  I had chunks of similar code with small changes for speed, or were slightly modified to handle different circumstances.  It's waaaaay more maintainable for me to have them as macros.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>3gengames</b> [ Tue Jul 19, 2011 1:14 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'm still developing. Although, now I'm getting used to just do stuff like:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">CMP #$C0<br />BEQ ExitMove<br />CMP #$80<br />BCS RightPressed<br />Left button pressed code here<br /></div>
<br />
<br />Just got a little tricky with my controller movement program, I've never used CMP to that extent before, but for this last rewrite of my game, I'm going to try more exotic stuff like that.[/quote]

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>koitsu</b> [ Tue Jul 19, 2011 7:36 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Weird question, but probably an okay thread in which to ask it:
<br />
<br />Are there any 6502 opcodes that folks here often find themselves confused when having to use?  Likewise, any opcodes which you "just don't see the point of" and tend to avoid using?
<br />
<br />With regards to me and the latter: ROL/ROR are the two main ones.  I think all these years I've been doing assembly I've only had to use those on a couple occasions, and grudgingly so.  I never found much of a need to rotate bits -- more specifically the MSB back down into the LSB and vice-versa.  ASL/LSR, absolutely use 'em all the time, but not so much ROL/ROR.
<br />
<br />An opcode I do find fantastic is BIT.  Under-utilised.  :-)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>3gengames</b> [ Tue Jul 19, 2011 7:46 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Nope, not really. I use ROL/ROR sometimes, it's not unnecessary. Sometime you just need to get a bit from one place to the other, haha. One I don't get/use often? None, really. What instructions should have been included in the 6502? INA! Increment A! Ugh, so many wasted cycles sometime when I can't get around needing to transfer it somewhere else or adding it it. Argh!
<br />
<br />And a good example of needing ROL/ROR is needing to maintain a value of a 16-bit multiply via shift.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Tue Jul 19, 2011 8:28 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">koitsu wrote:</div><div class="quotecontent">ROL/ROR are the two main ones.  I think all these years I've been doing assembly I've only had to use those on a couple occasions, and grudgingly so.  I never found much of a need to rotate bits -- more specifically the MSB back down into the LSB and vice-versa.</div>
<br />I don't think the point of ROL/ROR is to rotate bits in the same byte (which indeed doesn't look useful at all), specially if you consider that the carry flag is used for intermediary storage, but rather move bits from one byte to another. I use ROL/ROR all the time to shift numbers larger than 8 bits. For the first byte you use ASL/LSR, but in order to carry the shifted out bit over to the next byte you must use ROL/ROR.
<br />
<br />There are also many other occasions when I need to insert a bit into a byte either from the left or the right (such as when texturing the walls in my raycaster, where each bit represents a light or dark pixel in the texture), and these instructions are extremely useful for that (the alternative would be to use temporary variables and ORA bytes together, which would be much slower).
<br />
<br />What I have NEVER used in 6502 is the ($XX, X) addressing mode. I *might* eventually use it for accessing the individual audio streams in a music/sound engine, but other than that I see very little use for it. I also rarely make arithmetical use of the overflow flag, since I don't often do math between signed numbers. Everything else I use fairly often.
<br />
<br />BIT is great. It's probably under-utilized because it has few addressing modes.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Dwedit</b> [ Tue Jul 19, 2011 8:37 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />On the Atari 2600, half of the zero page is System RAM (a whopping 128 bytes), and the other half is hardware registers.  To no surprise, Atari 2600 games often use zpg,x addressing.
<br />The stack is a mirror of the zeropage as well, so that also shares the same 128 bytes of RAM.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Tue Jul 19, 2011 8:45 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah, ROR/ROL normally only comes up for me when I've done serial reading stuff, such as reading controllers or RS232 out of D0 (doing LSR A / ROL variable).
<br />
<br />For a while when I used to use BCC/BCS for greater/less than compares, I had a hard time remembering which to use until I came up with a mnemonic - that C is "less than" S (in the alphabet).  Haven't used it for a while, I hope that's still right. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />  I remember seeing 'BLT' and 'BGT' instructions used somewhere, so I guess that's for the same reason, maybe I should just adopt that too.
<br />
<br />Probably the only time I've used JMP ($xxxx) is when doing JMP ($FFFC).  More often I've put an absolute JMP in RAM and modified it there (it's the first instruction of my IRQ and NMI routines in some of my programs).
<br />
<br />BVS and BVC, I've never used for anything, ever.  I'm doing signed stuff all the time in C (add/subtract in the same operation, hell yea), but I just never did in 6502 for some reason.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Tue Jul 19, 2011 9:10 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Dwedit wrote:</div><div class="quotecontent">To no surprise, Atari 2600 games often use zpg,x addressing.</div><br />Yeah, but I imagine that (zpg, x) is still pretty rare.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The stack is a mirror of the zeropage as well, so that also shares the same 128 bytes of RAM.</div><br />IIRC, a common way to initialize the memory and the registers is to push 256 zeroes to the stack.<br /><br /><div class="quotetitle">Memblers wrote:</div><div class="quotecontent">Probably the only time I've used JMP ($xxxx) is when doing JMP ($FFFC).</div><br />I often JSR to a location that does JMP ($xxxx) as a way to simulate JSR ($xxxx), which doesn't exist.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">BVS and BVC, I've never used for anything, ever.</div><br />Not even for sprite 0 hits? =)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I'm doing signed stuff all the time in C (add/subtract in the same operation, hell yea), but I just never did in 6502 for some reason.</div>
<br />Yeah, I often add signed numbers so that I can also subtract with the same instruction, but the numbers they are added to are not signed, so there's no reason to check for overflows.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Tue Jul 19, 2011 9:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">BVS and BVC, I've never used for anything, ever.</div><br />Not even for sprite 0 hits? =)<br /></div>
<br />
<br />Oh yeah that's true, it's a macro now so I haven't seen it for a while.  And the first time I got it working, I stole it from one of Chris Covell's demos, so even then I never wrote it myself. <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Tue Jul 19, 2011 9:48 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Back to the original question though, I have different programming styles depending on the language and purpose. At work, for example, where I program JavaScript and ActionScript, I tend to name variables and write comments in portuguese, because I share them with my coworkers. For personal stuff I always use english though.
<br />
<br />Regarding 6502 assembly, which is the main focus of this place, I became much more organized with time. All my routines are in separate files, which are named after the routines they contain. I use constants for registers and common values. I declare variables by reserving bytes rather than hardcoding them to specific memory locations. My labels try to summarize what action(s) take(s) place after them.
<br />
<br />More important than all of the above though, is the structure of the program itself. I try to make everything as modular as possible, using as many principles of object-oriented programming as I can. I avoid hacks and exceptions, and try to create rules that are as absolute as possible.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>