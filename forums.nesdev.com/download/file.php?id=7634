#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>

typedef struct CPU6502_struct CPU6502;

struct CPU6502_struct{
	uint16_t program_counter;
	uint8_t stack_pointer;
	bool carry_flag;
	bool zero_flag;
	bool interrupts_disabled_flag;
	bool decimal_mode_flag;
	bool software_interrupt_flag;
	bool overflow_flag;
	bool sign_flag;
	uint8_t accumulator;
	uint8_t x_register;
	uint8_t y_register;
	uint8_t *memory;
	unsigned int numpages;
	unsigned int clock_cycles;
	unsigned int cycles_running;
};

CPU6502 create_6502(){
	CPU6502 output;
	output.memory = malloc(8<<16);
	output.program_counter = 0;
	output.stack_pointer = 0;
	output.carry_flag = false;
	output.zero_flag = false;
	output.interrupts_disabled_flag = false;
	output.decimal_mode_flag = false;
	output.software_interrupt_flag = false;
	output.overflow_flag = false;
	output.sign_flag = false;
	output.accumulator = 0;
	output.x_register = 0;
	output.y_register = 0;
	output.numpages = 16;
	output.clock_cycles = 0;
	output.cycles_running = 0;
	return output;
}

void reset_6502(CPU6502 *cpu){
	cpu->program_counter = ((cpu->memory[0xFFFD])<<8)|(cpu->memory[0xFFFC]);
}

void one_cycle(CPU6502 *cpu){
	if(cpu->clock_cycles == 0){
		execute_6502(cpu);
	}
	//timing thing here
	cpu->clock_cycles -= 1;
}

void push_to_stack_6502(CPU6502 *cpu, uint8_t value){
	cpu->memory[cpu->stack_pointer] = value;
	cpu->stack_pointer -= 1;
}

uint8_t pull_from_stack_6502(CPU6502 *cpu){
	cpu->stack_pointer += 1;
	return cpu->memory[cpu->stack_pointer];
}

uint8_t get_status_6502(CPU6502 *cpu){
	return cpu->carry_flag|(cpu->zero_flag<<1)|(cpu->interrupts_disabled_flag<<2)|(cpu->decimal_mode_flag<<3)|(cpu->software_interrupt_flag<<4)|(1<<5)|(cpu->overflow_flag<<6)|(cpu->sign_flag<<7);
}

void set_status_6502(CPU6502 *cpu, uint8_t status){
	if(status&1){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	if(status&2 != 0){
		cpu->zero_flag = true;
	} else {
		cpu->zero_flag = false;
	}
	if(status&4 != 0){
		cpu->interrupts_disabled_flag = true;
	} else {
		cpu->interrupts_disabled_flag = false;
	}
	if(status&8 != 0){
		cpu->decimal_mode_flag = true;
	} else {
		cpu->decimal_mode_flag = false;
	}
	if(status&16 != 0){
		cpu->software_interrupt_flag = true;
	} else {
		cpu->software_interrupt_flag = false;
	}
	if(status&64 != 0){
		cpu->overflow_flag = true;
	} else {
		cpu->overflow_flag = false;
	}
	if(status&128 != 0){
		cpu->sign_flag = true;
	} else {
		cpu->sign_flag = false;
	}
}

bool crossed_page_6502(CPU6502 *cpu, uint16_t a, uint16_t b){
	int i;
	for(i = 1; i < cpu->numpages-1; i++){
		uint16_t page_boundry = i<<8;
		if((page_boundry > a && page_boundry < b)||(page_boundry < a && page_boundry > b)){
			return true;
		}
	}
	return false;
}

void carry_6502(CPU6502 *cpu, unsigned int opresult){
	if(opresult & 0b100000000){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
}

void zero_6502(CPU6502 *cpu, unsigned int opresult){
	if(opresult == 0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
}

void overflow_6502(CPU6502 *cpu, unsigned int opresult){
	if(opresult > 0xFF){
		cpu->overflow_flag = true;
	} else {
		cpu->overflow_flag = false;
	}
}

void negative_6502(CPU6502 *cpu, unsigned int opresult){
	if(opresult&0b10000000 != 0){
		cpu->sign_flag = true;
	} else {
		cpu->sign_flag = false;
	}
}

void load_rom_6502(CPU6502 *cpu, uint8_t *rom){
	int i;
	for(i = 0x8000; i <= 0xFFFF; i++){
		cpu->memory[i] = rom[i-0x8000];
	}
	reset_6502(cpu);
}

void write_mem_6502(CPU6502 *cpu, uint16_t address, uint8_t value){
	if(address <= 0x1FFF){
		cpu->memory[address&0x07FF] = value;
		cpu->memory[(address&0x07FF)|0x0800] = value;
	}
}

//Addressing modes to return the value

uint8_t zero_page_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[arg1];
}

uint8_t zero_page_x_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint8_t)(arg1 + cpu->x_register)];
}

uint8_t zero_page_y_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint8_t)(arg1 + cpu->y_register)];
}

uint8_t absolute_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint16_t)(arg1|(arg2<<8))];
}

uint8_t absolute_x_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint16_t)((arg1|(arg2<<8)) + cpu->x_register)];
}

uint8_t absolute_y_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint8_t)((arg1|(arg2<<8)) + cpu->y_register)];
}

uint8_t indirect_x_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	uint16_t indirect_value;
	indirect_value = cpu->memory[(uint8_t)(arg1 + cpu->x_register)]|(cpu->memory[(uint8_t)(arg1 + cpu->x_register + 1)]<<8);
	return cpu->memory[indirect_value];
}

uint8_t indirect_y_value_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	uint16_t indirect_value;
	indirect_value = (cpu->memory[arg1]|(cpu->memory[(uint8_t)(arg1+1)]<<8)) + cpu->y_register;
	return cpu->memory[indirect_value];
}

//Addressing modes to return the address

uint16_t zero_page_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return arg1;
}

uint16_t zero_page_x_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (uint8_t)(arg1 + cpu->x_register);
}

uint16_t zero_page_y_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (uint8_t)(arg1 + cpu->y_register);
}

uint16_t absolute_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (uint16_t)(arg1|(arg2<<8));
}

uint16_t absolute_x_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (uint16_t)((arg1|(arg2<<8)) + cpu->x_register);
}

uint16_t absolute_y_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (uint8_t)((arg1|(arg2<<8)) + cpu->y_register);
}

uint16_t indirect_x_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[(uint8_t)(arg1 + cpu->x_register)]|(cpu->memory[(uint8_t)(arg1 + cpu->x_register + 1)]<<8);
}

uint16_t indirect_y_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return (cpu->memory[arg1]|(cpu->memory[(uint8_t)(arg1+1)]<<8)) + cpu->y_register;
}

uint16_t indirect_address_6502(CPU6502 *cpu, uint8_t arg1, uint8_t arg2){
	return cpu->memory[arg1|(arg2<<8)]|(cpu->memory[(arg1|(arg2<<8))+1]<<8);
}

void ADC_6502(CPU6502 *cpu, uint8_t oper){
	unsigned int result;
	result = cpu->carry_flag + oper + cpu->accumulator;
	carry_6502(cpu, result);
	zero_6502(cpu, result);
	negative_6502(cpu, result);
	unsigned int signage;
	signage = ((cpu->carry_flag + oper)^cpu->accumulator)&0b10000000;
	if((signage != 1)&&((result&0b10000000) != (cpu->accumulator&0b10000000))){
		cpu->overflow_flag = true;
	} else {
		cpu->overflow_flag = false;
	}
	cpu->accumulator = result;
}

void AND_6502(CPU6502 *cpu, uint8_t oper){
	cpu->accumulator &= oper;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void ASL_A_6502(CPU6502 *cpu){
	if((cpu->accumulator&0b10000000)!=0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	cpu->accumulator <<= 1;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void ASL_6502(CPU6502 *cpu, uint16_t oper){
	if((cpu->memory[oper]&0b10000000)!=0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	write_mem_6502(cpu, oper, cpu->memory[oper]<<1);
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

bool BCC_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(!cpu->carry_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

bool BCS_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(cpu->carry_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

bool BEQ_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(cpu->zero_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

void BIT_6502(CPU6502 *cpu, uint8_t oper){
	uint8_t result = oper&cpu->accumulator;
	zero_6502(cpu, result);
	negative_6502(cpu, result);
	if((result&0b01000000)!=0){
		cpu->overflow_flag = true;
	} else {
		cpu->overflow_flag = false;
	}
}

bool BMI_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(cpu->sign_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

bool BNE_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(!cpu->zero_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

bool BPL_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(!cpu->sign_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

void BRK_6502(CPU6502 *cpu){
	push_to_stack_6502(cpu, (cpu->program_counter&(((1<<8)-1)<<8))>>8);
	push_to_stack_6502(cpu, cpu->program_counter&((1<<8)-1));
	push_to_stack_6502(cpu, get_status_6502(cpu));
	cpu->program_counter = (cpu->memory[0xFFFE])|(cpu->memory[0xFFFF]<<8);
	cpu->clock_cycles = 7;
}

bool BVC_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(!cpu->overflow_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

bool BVS_6502(CPU6502 *cpu, uint8_t oper){
	int change;
	if(cpu->overflow_flag){
		if((oper&0b10000000)!=0){
			change = -(oper^0b10000000);
		} else {
			change = oper;
		}
		if(crossed_page_6502(cpu, cpu->program_counter, cpu->program_counter + change)){
			cpu->program_counter += change;
			return true;
		} else {
			cpu->program_counter += change;
			return false;
		}
	}
	return false;
}

void CLC_6502(CPU6502 *cpu){
	cpu->carry_flag = false;
}

void CLD_6502(CPU6502 *cpu){
	cpu->decimal_mode_flag = false;
}

void CLI_6502(CPU6502 *cpu){
	cpu->interrupts_disabled_flag = false;
}

void CLV_6502(CPU6502 *cpu){
	cpu->overflow_flag = false;
}

void CMP_6502(CPU6502 *cpu, uint8_t oper){
	if(cpu->accumulator > oper){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	uint8_t result = cpu->accumulator - oper;
	zero_6502(cpu, result);
	negative_6502(cpu, result);
}

void CPX_6502(CPU6502 *cpu, uint8_t oper){
	if(cpu->x_register > oper){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	uint8_t result = cpu->x_register - oper;
	zero_6502(cpu, result);
	negative_6502(cpu, result);
}

void CPY_6502(CPU6502 *cpu, uint8_t oper){
	if(cpu->y_register > oper){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	uint8_t result = cpu->y_register - oper;
	zero_6502(cpu, result);
	negative_6502(cpu, result);
}

void DEC_6502(CPU6502 *cpu, uint16_t oper){
	write_mem_6502(cpu, oper, cpu->memory[oper] - 1);
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

void DEX_6502(CPU6502 *cpu){
	cpu->x_register -= 1;
	zero_6502(cpu, cpu->x_register);
	negative_6502(cpu, cpu->x_register);
}

void DEY_6502(CPU6502 *cpu){
	cpu->y_register -= 1;
	zero_6502(cpu, cpu->y_register);
	negative_6502(cpu, cpu->y_register);
}

void EOR_6502(CPU6502 *cpu, uint8_t oper){
	cpu->accumulator ^= oper;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void INC_6502(CPU6502 *cpu, uint16_t oper){
	write_mem_6502(cpu, oper, cpu->memory[oper] + 1);
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

void INX_6502(CPU6502 *cpu){
	cpu->x_register += 1;
	zero_6502(cpu, cpu->x_register);
	negative_6502(cpu, cpu->x_register);
}

void INY_6502(CPU6502 *cpu){
	cpu->y_register += 1;
	zero_6502(cpu, cpu->y_register);
	negative_6502(cpu, cpu->y_register);
}

void JMP_6502(CPU6502 *cpu, uint16_t oper){
	cpu->program_counter = oper;
}

void JSR_6502(CPU6502 *cpu, uint16_t oper){
	push_to_stack_6502(cpu, ((cpu->program_counter+2)&(((1<<8)-1)<<8))>>8);
	push_to_stack_6502(cpu, (cpu->program_counter+2)&((1<<8)-1));
	cpu->program_counter = oper;
}

void LDA_6502(CPU6502 *cpu, uint8_t oper){
	cpu->accumulator = oper;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void LDX_6502(CPU6502 *cpu, uint8_t oper){
	cpu->x_register = oper;
	zero_6502(cpu, cpu->x_register);
	negative_6502(cpu, cpu->x_register);
}

void LDY_6502(CPU6502 *cpu, uint8_t oper){
	cpu->y_register = oper;
	zero_6502(cpu, cpu->y_register);
	negative_6502(cpu, cpu->y_register);
}

void LSR_A_6502(CPU6502 *cpu){
	if(cpu->accumulator&1){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	cpu->accumulator >>= 1;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void LSR_6502(CPU6502 *cpu, uint16_t oper){
	if(cpu->memory[oper]&1){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	write_mem_6502(cpu, oper, cpu->memory[oper]>>1);
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

void ORA_6502(CPU6502 *cpu, uint8_t oper){
	cpu->accumulator |= oper;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void PHA_6502(CPU6502 *cpu){
	push_to_stack_6502(cpu, cpu->accumulator);
}

void PHP_6502(CPU6502 *cpu){
	push_to_stack_6502(cpu, get_status_6502(cpu));
}

void PLA_6502(CPU6502 *cpu){
	cpu->accumulator = pull_from_stack_6502(cpu);
}

void PLP_6502(CPU6502 *cpu){
	set_status_6502(cpu, pull_from_stack_6502(cpu));
}

void ROL_A_6502(CPU6502 *cpu){
	uint8_t carry;
	carry = cpu->accumulator & 0b10000000;
	if(carry != 0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	cpu->accumulator <<= 1;
	cpu->accumulator |= carry>>7;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void ROL_6502(CPU6502 *cpu, uint16_t oper){
	uint8_t carry;
	carry = cpu->memory[oper] & 0b10000000;
	if(carry != 0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	write_mem_6502(cpu, oper, (cpu->memory[oper]<<1)|(carry>>7));
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

void ROR_A_6502(CPU6502 *cpu){
	uint8_t carry;
	carry = cpu->accumulator & 1;
	if(carry != 0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	cpu->accumulator >>= 1;
	cpu->accumulator |= carry<<7;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void ROR_6502(CPU6502 *cpu, uint16_t oper){
	uint8_t carry;
	carry = cpu->memory[oper] & 1;
	if(carry != 0){
		cpu->carry_flag = true;
	} else {
		cpu->carry_flag = false;
	}
	write_mem_6502(cpu, oper, (cpu->memory[oper]>>1)|(carry<<7));
	zero_6502(cpu, cpu->memory[oper]);
	negative_6502(cpu, cpu->memory[oper]);
}

void RTI_6502(CPU6502 *cpu){
	set_status_6502(cpu, pull_from_stack_6502(cpu));
	cpu->program_counter = pull_from_stack_6502(cpu);
	cpu->program_counter |= pull_from_stack_6502(cpu)<<8;
}

void RTS_6502(CPU6502 *cpu){
	cpu->program_counter = pull_from_stack_6502(cpu);
	cpu->program_counter |= pull_from_stack_6502(cpu)<<8;
	cpu->program_counter += 1;
}

void SBC_6502(CPU6502 *cpu, uint8_t oper){
	ADC_6502(cpu, ~oper);
}

void SEC_6502(CPU6502 *cpu){
	cpu->carry_flag = true;
}

void SED_6502(CPU6502 *cpu){
	cpu->decimal_mode_flag = true;
}

void SEI_6502(CPU6502 *cpu){
	cpu->interrupts_disabled_flag = true;
}

void STA_6502(CPU6502 *cpu, uint8_t oper){
	cpu->accumulator = oper;
}

void STX_6502(CPU6502 *cpu, uint16_t oper){
	write_mem_6502(cpu, oper, cpu->x_register);
}

void STY_6502(CPU6502 *cpu, uint16_t oper){
	write_mem_6502(cpu, oper, cpu->y_register);
}

void TAX_6502(CPU6502 *cpu){
	cpu->x_register = cpu->accumulator;
	zero_6502(cpu, cpu->x_register);
	negative_6502(cpu, cpu->x_register);
}

void TAY_6502(CPU6502 *cpu){
	cpu->y_register = cpu->accumulator;
	zero_6502(cpu, cpu->y_register);
	negative_6502(cpu, cpu->y_register);
}

void TSX_6502(CPU6502 *cpu){
	cpu->x_register = cpu->stack_pointer;
	zero_6502(cpu, cpu->x_register);
	negative_6502(cpu, cpu->x_register);
}

void TXA_6502(CPU6502 *cpu){
	cpu->accumulator = cpu->x_register;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void TXS_6502(CPU6502 *cpu){
	cpu->stack_pointer = cpu->x_register;
}

void TYA_6502(CPU6502 *cpu){
	cpu->accumulator = cpu->y_register;
	zero_6502(cpu, cpu->accumulator);
	negative_6502(cpu, cpu->accumulator);
}

void execute_6502(CPU6502 *cpu){
	uint8_t opcode = cpu->memory[cpu->program_counter];
	uint8_t arg1 = cpu->memory[cpu->program_counter + 1];
	uint8_t arg2 = cpu->memory[cpu->program_counter + 2];
	uint16_t absolute_address = arg1|(arg2<<8);
	unsigned int opresult;
	uint16_t indirect_address;
	uint16_t indirect_value;
	uint16_t before;
	switch(opcode){
		
		//ADC - Add with carry
		
		case 0x69: //ADC #Oper (immediate)
			ADC_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0x65: //ADC Oper (zero page)
			ADC_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0x75: //ADC Oper,X (zero page, x)
			ADC_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0x6D: //ADC Oper (absolute)
			ADC_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0x7D: //ADC Oper,X (absolute, x)
			ADC_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x79: //ADC Oper,Y (absolute, y)
			ADC_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x61: //ADC (Oper,X) (indirect, x)
			ADC_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x71: //ADC (Oper),Y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			ADC_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//AND "AND" memory with accumulator
		
		case 0x29: //AND #Oper (immediate)
			AND_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0x25: //AND Oper (zero page)
			AND_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0x35: //AND Oper,X (zero page, x)
			AND_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0x2D: //AND Oper (absolute)
			AND_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0x3D: //AND Oper,X (absolute, x)
			AND_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 4;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		case 0x39: //AND Oper,Y (absolute, y)
			AND_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 4;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		case 0x21: //AND (Oper, X) (indirect, x)
			AND_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x31: //AND (Oper),y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			AND_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//ASL Shift left one bit (memory or accumulator)
		
		case 0x0A: //ASL A (accumulator)
			ASL_A_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		case 0x06: //ASL Oper (zero page)
			ASL_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0x16: //ASL Oper,x (zero page, x)
			ASL_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x0E: //ASL Oper (absolute)
			ASL_6502(cpu, absolute_address);
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x1E: //ASL Oper,x (absolute, x)
			ASL_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 7;
			break;
		
		//BCC Branch on carry clear
		
		case 0x90:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BCC_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BCS Branch on carry set
		
		case 0xB0:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BCS_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BEQ Branch on result equals zero
		
		case 0xF0:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BEQ_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BIT Test bits in memory with accumulator
		
		case 0x24: //BIT Oper (zero page)
			BIT_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0x2C: //BIT Oper (absolute)
			BIT_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		
		//BMI Branch if minus
		
		case 0x30:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BMI_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BNE Branch on zero flag not set
		
		case 0xD0:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BNE_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BPL Branch if positive
		
		case 0x10:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BPL_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BRK Force Interupt
		
		case 0x00:
			BRK_6502(cpu);
			break;
		
		//BVC Branch if overflow clear
		
		case 0x50:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BVC_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//BVS Branch if overflow set
		
		case 0x70:
			before = cpu->program_counter;
			cpu->clock_cycles = 2;
			if(BVS_6502(cpu, arg1)){
				cpu->clock_cycles += 1;
				if(before != cpu->program_counter){
					cpu->clock_cycles += 1;
				}
			}
			break;
		
		//CLC Clear carry flag
		
		case 0x18:
			CLC_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//CLD Clear decimal mode
		
		case 0xD8:
			CLD_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//CLI Clear interrupt disable
		
		case 0x58:
			CLI_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//CLV Clear overflow flag
		
		case 0xB8:
			CLV_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//CMP Compare memory and accumulator
		
		case 0xC9: //CMP #Oper (immediate)
			CMP_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xC5: //CMP Oper (zero page)
			CMP_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xD5: //CMP Oper,x (zero page, x)
			CMP_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0xCD: //CMP Oper (absolute)
			CMP_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0xDD: //CMP Oper,x (absolute, x)
			CMP_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles += 1;
			}
			break;
		case 0xD9: //CMP Oper,y (absolute, y)
			CMP_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles += 1;
			}
			break;
		case 0xC1: //CMP (Oper,x) (indirect, x)
			CMP_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0xD1: //CMP (Oper),y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			CMP_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//CPX Compare memory and x register
		
		case 0xE0: //CPX #Oper (immediate)
			CPX_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xE4: //CPX Oper (zero page)
			CPX_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xEC: //CPX Oper (absolute)
			CPX_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		
		//CPY Compare memory and y register
		
		case 0xC0: //CPY #Oper (immediate)
			CPY_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xC4: //CPY Oper (zero page)
			CPY_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xCC: //CPY Oper (absolute)
			CPY_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		
		//DEC Decrement memory by one
		
		case 0xC6: //DEC Oper (zero page)
			DEC_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0xD6: //DEC Oper,x (zero page, x)
			DEC_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0xCE: //DEC Oper (absolute)
			DEC_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 6;
			break;
		case 0xDE: //DEC Oper (absolute, x)
			DEC_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 7;
			break;
		
		//DEX Decrement X register
		
		case 0xCA:
			DEX_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//DEY Decrement Y register
		
		case 0x88:
			DEY_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//EOR "Exclusive-Or" memory with accumulator
		
		case 0x49: //EOR #Oper (immediate)
			EOR_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0x45: //EOR Oper (zero page)
			EOR_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0x55: //EOR Oper,x (zero page, x)
			EOR_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0x4D: //EOR Oper (absolute)
			EOR_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0x5D: //EOR Oper,x (absolute, x)
			EOR_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x59: //EOR Oper,y (absolute, y)
			EOR_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x41: //EOR (Oper,x) (indirect, x)
			EOR_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x51: //EOR (Oper),y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			EOR_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//INC Increment memory by one
		
		case 0xE6: //INC Oper (zero page)
			INC_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0xF6: //INC Oper,x (zero page, x)
			INC_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0xEE: //INC Oper (absolute)
			INC_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 6;
			break;
		case 0xFE: //INC Oper,x (absolute)
			INC_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 7;
			break;
		
		//INX Increment index x by one
		
		case 0xE8:
			INX_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//INY Increment index y by one
		
		case 0xC8:
			INY_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		
		//JMP Jump to a new location
		
		case 0x4C: //JMP Oper (absolute)
			JMP_6502(cpu, absolute_address_6502(cpu, arg1, arg2));
			cpu->clock_cycles = 3;
			break;
		case 0x6C: //JMP (Oper) (indirect)
			JMP_6502(cpu, indirect_address_6502(cpu, arg1, arg2));
			cpu->clock_cycles = 5;
			break;
		
		//JSR Jump subroutine
		
		case 0x20:
			JSR_6502(cpu, absolute_address);
			cpu->clock_cycles = 6;
			break;
		
		//LDA Load Accumulator with memory
		
		case 0xA9: //LDA #Oper (immediate)
			LDA_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xA5: //LDA Oper (zero page)
			LDA_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xB5: //LDA Oper,x (zero page, x)
			LDA_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0xAD: //LDA Oper (absolute)
			LDA_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0xBD: //LDA Oper,x (absolute, x)
			LDA_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0xB9: //LDA Oper,y (absolute, y)
			LDA_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0xA1: //LDA (Oper,x) (indirect, x)
			LDA_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0xB1: //LDA (Oper),y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			LDA_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//LDX Load index x with memory
		
		case 0xA2: //LDX #Oper (immediate)
			LDX_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xA6: //LDX Oper (zero page)
			LDX_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xB6: //LDX Oper,y (zero page, y)
			LDX_6502(cpu, zero_page_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0xAE: //LDX Oper (absolute)
			LDX_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0xBE: //LDX Oper,y (absolute, y)
			LDX_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		
		//LDY Load index Y with memory
		
		case 0xA0: //LDY #Oper (immediate)
			LDY_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xA4: //LDY Oper (zero page)
			LDY_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xB4: //LDY Oper,x (zero page, x)
			LDY_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0xAC: //LDY Oper (absolute)
			LDY_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0xBC: //LDY Oper,x (absolute, x)
			LDY_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		
		//LSR Shift right one bit
		
		case 0x4A: //LSR A (accumulator)
			LSR_A_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		case 0x46: //LSR Oper (zero page)
			LSR_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0x56: //LSR Oper,x (zero page, x)
			LSR_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x4E: //LSR Oper (absolute)
			LSR_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 6;
			break;
		case 0x5E: //LSR Oper,x (absolute, x)
			LSR_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 7;
			break;
		
		//NOP No Operation
		
		case 0xEA:
			//Hey, I can put anything I want here! Hi curious person. I started this project yesterday and am already to this point.
			//I like math
			break;
		
		//ORA "OR" Memory with accumulator
		
		case 0x09: //ORA #Oper (immediate)
			ORA_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0x05: //ORA Oper (zero page)
			ORA_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0x15: //ORA Oper,x (zero page, x)
			ORA_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0x0D: //ORA Oper (absolute)
			ORA_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0x1D: //ORA Oper,x (absolute, x)
			ORA_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x19: //ORA Oper,y (absolute, y)
			ORA_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0x01: //ORA (Oper,x) (indirect, x)
			ORA_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x11: //ORA (Oper),y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			ORA_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address - cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//PHA Push accumulator on stack
		
		case 0x48:
			PHA_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 3;
		
		//PHP Push processor status on stack
		
		case 0x08:
			PHP_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 3;
		
		//PLA Pull accumulator from stack
		
		case 0x68:
			PLA_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 4;
		
		//PLP Pull processor status from stack
		
		case 0x28:
			PLP_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 4;
		
		//ROL Rotate one bit left (memory or accumulator)
		
		case 0x2A: //ROL A (accumulator)
			ROL_A_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		case 0x26: //ROL Oper (zero page)
			ROL_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0x36: //ROL Oper,x (zero page, x)
			ROL_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x2E: //ROL Oper (absolute)
			ROL_6502(cpu, absolute_address);
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x3E: //ROL Oper,x (absolute, x)
			ROL_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 7;
			break;
		
		//ROR Rotate one bit right (memory or accumulator)
		
		case 0x6A: //ROR A (accumulator)
			ROR_A_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
			break;
		case 0x66: //ROR Oper (zero page)
			ROR_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 5;
			break;
		case 0x76: //ROR Oper,x (zero page, x)
			ROR_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0x6E: //ROR Oper (absolute)
			ROR_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 6;
			break;
		case 0x7E: //ROR Oper,x (absolute, x)
			ROR_6502(cpu, absolute_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 7;
			break;
		
		//RTI Return from interrupt
		
		case 0x40:
			RTI_6502(cpu);
			cpu->clock_cycles = 6;
		
		//RTS Return from subroutine
		
		case 0x60:
			RTS_6502(cpu);
			cpu->clock_cycles = 6;
		
		//SBC Subract with carry
		
		case 0xe9: //SBC #Oper (immediate)
			SBC_6502(cpu, arg1);
			cpu->program_counter += 2;
			cpu->clock_cycles = 2;
			break;
		case 0xE5: //SBC Oper (zero page)
			SBC_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
			break;
		case 0xF5: //SBC Oper,X (zero page, x)
			SBC_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
			break;
		case 0xED: //SBC Oper (absolute)
			SBC_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
			break;
		case 0xFD: //SBC Oper,X (absolute, x)
			SBC_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->x_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0xF9: //SBC Oper,Y (absolute, y)
			SBC_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			if(crossed_page_6502(cpu, absolute_address, absolute_address + cpu->y_register)){
				cpu->clock_cycles = 5;
			} else {
				cpu->clock_cycles = 4;
			}
			break;
		case 0xE1: //SBC (Oper,X) (indirect, x)
			SBC_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
			break;
		case 0xF1: //SBC (Oper),Y (indirect)
			indirect_address = indirect_y_address_6502(cpu, arg1, arg2);
			SBC_6502(cpu, cpu->memory[indirect_address]);
			cpu->program_counter += 2;
			if(crossed_page_6502(cpu, indirect_address, indirect_address + cpu->y_register)){
				cpu->clock_cycles = 6;
			} else {
				cpu->clock_cycles = 5;
			}
			break;
		
		//SEC Set carry flag
		
		case 0x38:
			SEC_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//SED Set decimal flag
		
		case 0XF8:
			SED_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//SEI Set interrupt disable
		
		case 0x78:
			SEI_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//STA Store accumulator
		
		case 0x85: //STA oper (zero page)
			STA_6502(cpu, zero_page_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
		case 0x95: //STA Oper,x (zero page, x)
			STA_6502(cpu, zero_page_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
		case 0x8D: //STA Oper (absolute)
			STA_6502(cpu, absolute_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
		case 0x9D: //STA Oper,x (absolute, x)
			STA_6502(cpu, absolute_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 5;
		case 0x99: //STA Oper,y (absolute, y)
			STA_6502(cpu, absolute_y_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 3;
			cpu->clock_cycles = 5;
		case 0x81: //STA (Oper,x) (indirect, x)
			STA_6502(cpu, indirect_x_value_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
		case 0x91: //STA (Oper),y (indirect)
			STA_6502(cpu, indirect_y_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 6;
		
		//STX Store X Register
		
		case 0x86: //STX Oper (zero page)
			STX_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
		case 0x96: //STX Oper, y (zero page, y)
			STX_6502(cpu, zero_page_y_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
		case 0x8E: //STX Oper (absolute)
			STX_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
		
		//STY Store Y Register
		
		case 0x84: //STY Oper (zero page)
			STY_6502(cpu, zero_page_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 3;
		case 0x94: //STY Oper, x (zero page, x)
			STY_6502(cpu, zero_page_x_address_6502(cpu, arg1, arg2));
			cpu->program_counter += 2;
			cpu->clock_cycles = 4;
		case 0x8C: //STY Oper (absolute)
			STY_6502(cpu, absolute_address);
			cpu->program_counter += 3;
			cpu->clock_cycles = 4;
		
		//TAX Transfer Accumulator to X
		
		case 0xAA:
			TAX_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//TAY Transfer Accumulator to Y
		
		case 0xA8:
			TAY_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//TSX Transfer Stack Pointer to X
		
		case 0xBA:
			TSX_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//TXA Transfer X to Accumulator
		
		case 0x8A:
			TXA_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//TXS Transfer X to Stack Pointer
		
		case 0x9A:
			TXS_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
		
		//TYA Transfer Y to Accumulator
		
		case 0x98:
			TYA_6502(cpu);
			cpu->program_counter += 1;
			cpu->clock_cycles = 2;
	}
}

int main(){
	return 0;
}