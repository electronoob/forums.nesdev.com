<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - basic register question</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">basic register question</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=3&amp;t=5281">http://forums.nesdev.com/viewtopic.php?f=3&amp;t=5281</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>1</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>jjpeerless</b> [ Sat Jun 06, 2009 2:42 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>basic register question</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hey all,
<br />
<br />   I am new here and new to emulator programming but its something I've always been interested in pursuing.  I finally took the plunge after reading these forums and some docs on nes hardware and started my cpu emulator.
<br />
<br />   I am using BombSweeper.nes for now (recommended as a simple game on these forums) but I think since im still only working with the CPU maybe theres a better test rom floating around.
<br />
<br />anyways, how i've been doing it is as follows:
<br />
<br />    in an infinite loop, I read an opcode, if i have defined the operation, i perform it.  if its not defined yet, I print out which opcode it was and halt execution so I can go implement it.  I also print out some debug information to see what its doing.
<br />
<br />   finally, on to my question.
<br />
<br />   The operation I just encountered is: DEX (Decrement the X Register by 1).  My X Register is defined as a uint8_t in c.  Before this operation the value of the X Register is 0, what is supposed to happen on a decrement here?  Should my registers not be unsigned?  Should this flip to 255 and set the negative flag in the status register?  A little advice or information about the registers in this context would be great help.
<br />
<br />Thanks.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sat Jun 06, 2009 3:49 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: basic register question</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">   The operation I just encountered is: DEX (Decrement the X Register by 1).  My X Register is defined as a uint8_t in c.  Before this operation the value of the X Register is 0, what is supposed to happen on a decrement here?</div>
<br />X becomes $FF, flags.N is turned on (because a value &gt;= $80 was written to a register) and flags.Z is turned off (because a value != $00 was written to a register).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>cpow</b> [ Sat Jun 06, 2009 4:50 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: basic register question</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">   The operation I just encountered is: DEX (Decrement the X Register by 1).  My X Register is defined as a uint8_t in c.  Before this operation the value of the X Register is 0, what is supposed to happen on a decrement here?</div>
<br />I actually found the C=64 Programmer's Reference Guide to be useful for the basic instruction micro-ops (available online).  There are some gaping holes in it though, specifically what exactly the oVerflow flag should set to.
<br />A <strong>very good</strong> demo ROM to try to see if you've implemented all your opcodes correctly (I just found out about this myself a week or so ago!) is on the Wiki.  
<br />
<br /><a href="http://nesdevwiki.org/wiki/Emulator_Tests" class="postlink">http://nesdevwiki.org/wiki/Emulator_Tests</a>.  (It is the nestest one under CPU).
<br />
<br />From the readme.txt file:
<br />This test program, when run on "automation", (i.e. set your program counter
<br />to 0c000h) will perform all tests in sequence and shove the results of
<br />the tests into locations 02h and 03h.  
<br />
<br />-----
<br />So, if you haven't implemented the screen yet it's okay...you can just look at your memory, bytes 2 and 3 after running the program.  Beware though that if you haven't implemented some instructions correctly the program may go on a fishing expedition.
<br />
<br />EDIT 
<br />Here's what it looks like on-screen:
<br /><a href="http://nesdev.com/bbs/viewtopic.php?t=5224&amp;highlight=" class="postlink">http://nesdev.com/bbs/viewtopic.php?t=5224&amp;highlight=</a>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>jjpeerless</b> [ Sun Jun 07, 2009 10:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />thanks for the replies guys, they were great help.  As I continue implementing all these damn opcodes I have another question I'd like to address before I continue.  A lot of these opcodes require checking/updating of the status register.  I currently have it implemented as just another 1 byte uint and I made some functions to set_bit() clear_bit() get_bit() using bitwise operations to work with the status register.  Since these things are happening a lot, I was thinking it might be better to just implement the status register as separate flags instead of just a one byte register.  This would let me check,set,clear the flags directly instead of having to manipulate a single byte.  Is this a better idea? what is the consensus on this?
<br />
<br />Also, I was doing some reading on older posts about implementing the cpu memory and I'm not positive I understand why my approach is bad.  
<br />
<br />I simply have a 64KB byte array: uint8_t  cpu_mem[0x10000];
<br />
<br />so say I want to read the next opcode I can do it with cpu_mem[cpu.PC];
<br />
<br />say for STA_ZP (Store Accumulator using Zero Page addressing)
<br />
<br />my program counter is pointing to the byte which represents the 8-bit address where we want to store the acc, my code looks like this:
<br />
<br />cpu_mem[cpu_mem[cpu.PC++]] = cpu.ACC;
<br />
<br />the inner cpu_mem[cpu.PC] gets the 8 bit address, and then it indexes into the mem again to point to the place I need to store the acc.
<br />
<br />is this a really bad idea?  this just makes sense to me to do it this way.
<br />
<br />
<br />----
<br />
<br />and my last question for this post is about JSR / RTS (Jump to SubRoutine and Return From SubRoutine).  So I look at it like this:
<br />              
<br />[opcode (JSR)] [low order address] [high order address] [opcode2]
<br />
<br />so originally my PC is pointing to the first opcode (JSR) and once I read it, I increment my PC so its now pointing to the low order byte of the address to jump to.  Once I realize the opcode was a JSR, I am supposed to store my PC address (minus 1) on the stack.  First off, why minus 1? Why not store the address of [opcode2] since thats where we want to be once we return anyways?  Anyways, given my block above, which address am I supposed to store, the JSR opcode address? the one before it? 
<br />
<br />Just curious, to me the logical thing to do would be to store the address of [opcode2] where we want to be whenever we reach the RTS call.  
<br />
<br />
<br />thanks for your input, sorry for the long post!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Disch</b> [ Sun Jun 07, 2009 10:58 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">Is this a better idea?</div><br />Yes.  Status flags need only be in bit form when they're pushed to the stack (via IRQ/NMI/PHP/BRK).  Since those occur much less frequently than individual flag changes, it pays to have flag settings as quick as possible.<br /><br />EDIT:  Here are some misc points:<br /><br />- the B and R flags do not really exist (status bits 5, 6).  You do not need to keep track of their state.  When you put status on the stack (PHP/IRQ/NMI/BRK), bit 6 (R) is <em>always</em> pushed as set.  bit 5 (B) is pushed as set for BRK/PHP, but is pushed as clear for IRQ/NMI.<br /><br />- you do not have to have boolean true/false or 0/1 for flag state indications.  You can have any nonzero value indicate one thing and zero indicate something else.  Or have only the high bit indicate something.  For instance if you want to shortcut setting/clearing of N, you can say that only bit 7 of your flgN member is significant.  That way when you do something like LDA you can do:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">flgN = A;<br /></div><br /><br />No need for any bitwise or logic operation.  Just a simple copy.  Then to see if N is set you can just do this:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">if&#40;flgN &amp; 0x80&#41;&nbsp; // N is set<br /></div><br /><br />Z can be done similarly.  Just say that flgZ==0 when Z is set, and flgZ!=0 when Z is clear.  Then setting it is just as simple:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">flgN = flgZ = A;&nbsp; // set N and Z<br /><br />//&nbsp; to see if Z is set<br />if&#40;flgZ&#41;&nbsp; // Z is CLEAR<br />if&#40;!flgZ&#41; // Z is SET &#40;notice it's backwards&#41;<br /></div><br /><br />There are also tricks blargg came up with that you can use to combine N and Z into a single variable, since N and Z are set together so often.  But I'll not mention it here because I'm rambling already.  If you're really interested lemme know and I'll post it later.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Also, I was doing some reading on older posts about implementing the cpu memory and I'm not positive I understand why my approach is bad.  <br /><br />I simply have a 64KB byte array: uint8_t  cpu_mem[0x10000];<br /><br />so say I want to read the next opcode I can do it with cpu_mem[cpu.PC];<br /></div><br /><br />This is bad because:<br /><br />- It doesn't write protect PRG-ROM (writes to $8000-FFFF might change PRG, which shouldn't happen!)<br /><br />- It makes bankswitching much more difficult because you have to perform bulk memory copies instead of a simple pointer change<br /><br />- A lot of that space is mirrored.  IE, LDA $1000 should read the same byte of memory as LDA $0000.<br /><br />- A lot of that space is open bus (ie:  addresses $5xxx)<br /><br />- It makes it weirder to catch register reads/writes.<br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">is this a really bad idea?</div><br /><br />It's not REALLY bad, no.  It's just that it will make adding future functionality more difficult.  You'll end up with a lot of spaghetti code with a bunch of little hacks worked in to get a specific feature working.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">First off, why minus 1? Why not store the address of [opcode2] since thats where we want to be once we return anyways?</div><br /><br />Because the high byte of the PC is pushed before the second jump-to byte is fetched.  I cannot explain the rationale of why the 6502 works that way -- it just does.  Perhaps it was the only way to get it to work within the 6 cycles (though I doubt it)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Anyways, given my block above, which address am I supposed to store, the JSR opcode address? the one before it?</div><br /><br />assuming PC=$8000 and you hit a JSR, $80 and $02 are pushed to the stack (in that order).  On RTS, you'll pull these to get $8002, <em>then</em> increment by 1 to get $8003 (the next opcode)<br /><br />You only do this -1 business for JSR/RTS.  IRQ/NMI/RTI/etc all work "normally".<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Just curious, to me the logical thing to do would be to store the address of [opcode2] where we want to be whenever we reach the RTS call.</div><br /><br />That is logical, but it is not how the 6502 works.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">sorry for the long post!</div>
<br />
<br />don't be  =)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>jjpeerless</b> [ Sun Jun 07, 2009 11:31 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />thanks for the quick reply! few more questions for you =)
<br />
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">This is bad because: <br /><br />- It doesn't write protect PRG-ROM (writes to $8000-FFFF might change PRG, which shouldn't happen!) <br /><br /></div><br /><br />Isn't it safe to assume games won't do this, someone would have to write 'malicious' app to do things like that?  (though if I was going for an exact replica of the nes then one should stop things like this).  <br /><br />Anyways, so would a better approach be to have read_memory(16 bit address) and write_memory(addr) functions?  in the write_memory I could add checks to the addr to make sure its not in read-only memory? is that the idea?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- It makes bankswitching much more difficult because you have to perform bulk memory copies instead of a simple pointer change <br /><br /></div><br /><br />As I have very limited knowledge of what I am doing, I was just going at this project on a 'as-i-go' basis, I've only been working on implementing the cpu.  I am not even sure what/why bankswitching refers to?  <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />- A lot of that space is mirrored. IE, LDA $1000 should read the same byte of memory as LDA $0000. <br /><br /></div><br /><br />Yeah, I noticed that when looking at the memory map.  How do people handle these mirrorings? Does it make sense to just store one copy and just translate addresses to the one copy? or do people actually mirror it and just update all mirrors on writes?<br /><br /><br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">- It makes it weirder to catch register reads/writes.<br /><br /></div><br /><br />Im guessing you are talking about I/O registers?  Haven't really thought about these things yet. :/<br /><br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />It's not REALLY bad, no. It's just that it will make adding future functionality more difficult. You'll end up with a lot of spaghetti code with a bunch of little hacks worked in to get a specific feature working. <br /><br /></div><br /><br />Ok so if I am going to restructure my memory implementation Id like to do it now before I get too far into this.  <br /><br />The only other way I could think to implement memory would be to do something like this:<br /><br />Allocate bytes for each section of memory to their own byte pointers?<br /><br />uint8_t * internalRAM =  malloc(0x800);<br />uint8_t * prgROM = malloc(size of rom); <br /><br />etc etc<br /><br />this just seems really messy, would also have to store the start addresses for each section.  <br /><br />what about having my 64KB byte array and just add pointers to the start of specific sections?  <br /><br />like uint8_t * prg_rom_bank1 = &amp;cpu_mem[0x8000]; <br /><br />I dunno, at this point I guess I cant see how this would help or be easier than my original plan.<br /><br /><br /><br />Also, if I dont use my memory implementation then it seems like reads/writes will be messier, requiring lots of checks of where the address is to find out which pointers to use, instead of just indexing right into the spot?<br /><br /><br /><br />----<br /><br />about the JSR stuff<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Because the high byte of the PC is pushed before the second jump-to byte is fetched<br /><br /></div>
<br />
<br />Why does the order matter?  I was using a 'read_address()' function when absolute addressing, which returned the 16 bit address starting at the current PC.  After this call I just manually increment the PC by 2.  Should I always just be going one byte at a time and having a function to "fetch" the byte AND increment the PC?
<br />
<br />I want to clarify this before I go on, because these sorts of things are happening ALL the time, reading a byte, incrementing PC, etc.
<br />
<br />Thanks again!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Disch</b> [ Sun Jun 07, 2009 12:17 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">Isn't it safe to assume games won't do this,</div><br /><br />NO!<br /><br />Most mappers put their write-only regs at $8000-FFFF, so therefore the game will write there every time it wants to swap PRG or CHR (several times per frame).  Other games are malicious in that they check for antipiracy purposes (to see if the ROM is being run on a copier, which might allow overwriting ROM).<br /><br />Assume games can and will do everything.  Because they can.  And they do.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Anyways, so would a better approach be to have read_memory(16 bit address) and write_memory(addr) functions?  in the write_memory I could add checks to the addr to make sure its not in read-only memory? is that the idea?<br /></div><br /><br />Generally yeah that's the idea.<br /><br />A common variant is instead of one overall read and write function group, you split it up so that you have 16 function pointers (one for each $1000 bytes of addressing space) and assign the function pointers to different read/write functions.  ie, ReadFunc[0] and ReadFunc[1] would point to ReadRAM, ReadFunc[2],3 would point to ReadPPU, Read[8]+ would point to ReadROM, etc.  This allows for easy mapper intervention, as well (just change a pointer)... which is nice because you'll need to catch reads and writes for various mappers.<br /><br />Blargg propsed a hybrid solution where you have an overall read/write function first which deals with system RAM (0x0000-1FFF) and then does the 16 callbacks method if the address is outside that range.  The idea is that this is benefitial because RAM reads/writes occur very frequently.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As I have very limited knowledge of what I am doing, I was just going at this project on a 'as-i-go' basis,<br /></div><br /><br />Heh.  Yeah we've all been there.  It's hard to plan ahead for eveyrthing when you don't know what "everything" is.  Just prepare to do a lot of rewrites, or hit a few snags/walls.  Because it's bound to happen.  Don't let it discourage you though!<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> I've only been working on implementing the cpu.  I am not even sure what/why bankswitching refers to?</div><br /><br />Since there's only 32k of PRG space available (addresses $8000-FFFF) for games to have more than this, they employ bankswapping to "swaps out" different pages of PRG allowing for the overall game to be larger.  This is where you get into mappers and stuff.  Right now you're probably just dealing with mapper 0 games which have no swapping.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Yeah, I noticed that when looking at the memory map.  How do people handle these mirrorings?<br /></div><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">// to read RAM &#40;assume addr is between 0-0x1FFF&#41;<br />v = RAM&#91; addr &amp; 0x07FF &#93;;<br /></div><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Im guessing you are talking about I/O registers?  Haven't really thought about these things yet. :/<br /></div><br /><br />Yup.  This is a very important part.  After all you can't make games if you can't output anything.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Ok so if I am going to restructure my memory implementation Id like to do it now before I get too far into this.  <br /><br />The only other way I could think to implement memory would be to do something like this:<br /><br />Allocate bytes for each section of memory to their own byte pointers?<br />[snip]<br />this just seems really messy, would also have to store the start addresses for each section.  <br /></div><br /><br />That is typically what is done.  And it's actually much more organized (not messy) because each block of memory is clearly labelled (ie:  you have RAM, ROM buffers instead of just a big "memory" buffer which could be anything or nothing).  Keep in mind that when you get into bankswitching and stuff, the "big 64k clump" just isn't practical and you're much better off with separate buffers.<br /><br />You might want to look at some bankswitching info before you go further.  Once you see how it works you'll better understand what I'm talking about.<br /><br />For an example -- let's take a simple "mapper 2"-ish example:<br /><br />- PRG-ROM is 128K (0x20000 bytes)<br />- this is broken up into 8 "pages", each 16K (0x4000) in size.<br />- $C000-FFFF is mapped to the last page (page 7: 0x1C000-0x1FFFF)<br />- $8000-BFFF is swappable, so it can reflect any of the 8 pages in the ROM.<br /><br />Basically, when the games "swaps" PRG, it's changing which page is "visible" in that slot.  IE:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">JSR SwapToPage_0<br />LDA $8000&nbsp; &nbsp; ; reads from PRG offset 0x00000<br />JSR SwapToPage_2<br />LDA $8000&nbsp; &nbsp; ; reads from PRG offset 0x08000<br /></div><br /><br />For this to work with the "big 64K clump" you'd need to copy the full 16K page to your memory block every time a swap occurs.  Since swaps occur repeatedly and rapidly (several times per frame) this is very wasteful.<br /><br />The general approach to this is to have pointers.  Like one pointer for each $1000 bytes.  These pointers would then point to different areas in the main PRG buffer.  That way to swap all you have to do is change where the pointer(s) point(s).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Also, if I dont use my memory implementation then it seems like reads/writes will be messier, requiring lots of checks of where the address is to find out which pointers to use, instead of just indexing right into the spot?</div><br /><br />Hence why function pointers are a common solution.  They make it sort of like a jump table.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">v = ReadFunc&#91; addr&gt;&gt;12 &#93;&#40;addr&#41;;<br /></div><br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Why does the order matter?<br /></div>
<br />
<br />It doesn't really.  All that matters is that you emulate the desired output behavior.  I was just saying why the 6502 does it the way it does.  Your emu need not do it that way.
<br />
<br />It also depends on the level of accuracy you want.  If you want your CPU core to be cycle accurate, then you'd want to do the reads and writes in the exact right order and have them spaced out one cycle apart.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>cpow</b> [ Sun Jun 07, 2009 12:20 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">thanks for the quick reply! few more questions for you =)<br /></div>
<br />I just implemented separate classes.  My CPU class has internal 2KB memory.  My PPU class has internal 8KB memory (nametable), 256B memory (for OAM), and 32B memory (for palettes).  My ROM (cartridge) class has internal 8KB SRAM, EXRAM [still working this], and Nx16KB PRG banks and Nx8KB CHR-ROM banks.  The ROM is filled with data when a .nes file is loaded.  The ROM class takes care of all memory mapping by subclassing the ROM class for different mapper implementations.  
<br />
<br />Then my emulator has memory read/write functions that check the address and forward the request to the appropriate class based on address range. Start at the top and work your way down...ie. 
<br />
<br />if ( addr &gt; 0x8000 ) ROM::read(addr)
<br />else if ( addr &gt; 0x6000 ) ROM::sram(addr)
<br />else if ( addr &gt; 0x4020 ) ROM::extra(addr)
<br />else if ( addr &gt; 0x4000 ) IO::read(addr)
<br />else if ( addr &gt; 0x2000 ) PPU::read(addr)
<br />else CPU::read(addr)
<br />
<br />Internally the classes know whether the address read is a register, memory, etc and return the appropriate result or cause the appropriate behavior (such as joypad strobe in IO class on write to 0x4016).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tanoatnd</b> [ Sun Jun 07, 2009 12:41 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Personally, I use this tip in my cpu emulator (I did not realize much
<br />of ppu, for now), represent flags as separate variable that
<br />assume 0 if cleared, and the corresponding psr bit if set.
<br />Example:
<br />
<br />uint8_t c_flag, n_flag, ecc..
<br />
<br />#define C_FLAG 0x01
<br />..
<br />#define N_FLAG 0x80
<br />
<br />c_flag = 0;                  /* clear carry */
<br />c_flag = C_FLAG;         /* set carry */
<br />
<br />when you need the value of the psr, or (|) all the variables together.
<br />Bye,
<br />             tano

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>jjpeerless</b> [ Sun Jun 07, 2009 3:10 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />ok so I have read and re-read your replies a bunch of times to try to grasp it all.  
<br />
<br />I am pretty sure I get the PRG bank swapping and understand that it would make sense to have pointers to PRG_LOW_BANK and PRG_HIGH_BANK which point to whichever PRG_ROM page I need (say there are 8 pages, your example) I could do PRG_LOW_BANK = &amp;PRG_ROM[7];  PRG_HIGH_BANK = &amp;PRG_ROM[0]; or whichever page I need the banks to be pointing to.  where each PRG_ROM page is 16KB.
<br />
<br />aside from that I don't really see why I shouldnt just lump the rest of memory into one chunk.
<br />
<br />also, for the read/write functions..
<br />
<br />say im doing something like:
<br />
<br />if(addr &lt; 0x0800)
<br />{
<br />     read_RAM(addr);
<br />}
<br />
<br />if(addr &lt; 0x2000)
<br />{
<br />    read_RAM(map_addr_to_actual_ram_since_its_accessing_a_mirror);
<br />}
<br />
<br />if(addr &lt; 0x8000)
<br />{
<br />   read_??(addr);
<br />}
<br />
<br />
<br />if the cpu memory was divided into its own chunks, then the address passed into the function would be indexing into the "whole thing" but we only have a chunk from 0--&gt;size_of_chunk, so would there also need to be some address translation so it indexes correctly?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Disch</b> [ Sun Jun 07, 2009 4:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />preface:
<br />
<br />I might sound like I'm lecturing you here and/or telling you how to build your emu.  I don't mean to sound too pushy, I'm just trying to share my experience with you so you don't have to go through all the trial and error hardships I did.
<br />
<br />Remember that this is your project, and I'm only giving you input.  Feel free to tell me to shove it and code the project your own way.  Remember that it's all about fun and if doing it your way is more fun, then that's how you should do it!  Don't let me bully you.  I really don't want to!
<br />
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I am pretty sure I get the PRG bank swapping and understand that it would make sense to have pointers to PRG_LOW_BANK and PRG_HIGH_BANK</div><br /><br />You'll want to go finer than 16K, though.  I just used 16K in my example.  There's also 8K swapping on many mappers (in fact it's probably the most common).  NSFs go with 4K, so if you want NSF support you'll need to go at least that low.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">aside from that I don't really see why I shouldnt just lump the rest of memory into one chunk.</div><br /><br />Rather than ask "why shouldn't I?"  Try asking "why <em>should</em> I?"  I already listed several reasons why you shouldn't.<br /><br />Also note that $6000-7FFF may also be swappable (RAM <em>or</em> ROM)<br /><br />What good does having a 64K chunk do you?  All you really need to gut it is:<br /><br />1)  a system RAM buffer (2K for RAM at $0000-07FF)<br />2)  a PRG ROM buffer (variable size, for game's PRG-ROM)<br />3)  a PRG RAM buffer (variable size, typically 0 or 8K for on cartridge RAM / SRAM -- typically $6000-7FFF)<br />4)  a sane way to perform reads/writes<br /><br />1 is hardly anything big<br />2 and 3 you need anyway because of swapping issues<br />and 4 you should have anyway otherwise adding IO regs and mapper stuff will be a complete nightmare.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">if the cpu memory was divided into its own chunks, then the address passed into the function would be indexing into the "whole thing" but we only have a chunk from 0--&gt;size_of_chunk, so would there also need to be some address translation so it indexes correctly?</div>
<br />
<br />side note:  notice that it's called an "address" and not an "index".  This is because you're not really indexing anything.  Different addresses get mapped to different areas.  Some areas contain RAM, others ROM, others IO regs, and others nothing at all.  This is the concept you and I seem to be clashing on.  You want to shove everything in a big array so indexing is quick, but that's not really logical when you look at what's actually going on.
<br />
<br />As for translating addresses, this is pretty much always a quick mask.  You can think of it as the high bits of the address tell the NES where to go, and the low bits tell it what address within that area to read from.  So for example address $8123 would go to PRG because the high bit is set, and the low bits indicate it wants address $0123 from within the PRG.  All you need to do to extract those low bits is an AND operation.
<br />
<br />I really think I might be able to sell you on the function pointer idea.  Here's a simplistic example of how you could use function pointers to sanely handle reading -- simple bankswitching ability is included:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">typedef u8 &#40;*ReadProc&#41;&#40;u16&#41;;&nbsp; // read function pointer typedef<br /><br />u8&nbsp; &nbsp;RAM&#91;0x0800&#93;;&nbsp; // 2K system RAM<br />u8*&nbsp; PRGROM;&nbsp; &nbsp; &nbsp; &nbsp;// dynamically allocated PRG ROM<br />u8*&nbsp; PRG&#91;0x10&#93;;&nbsp; &nbsp; // bankswapping PRG pointers &#40;each represents 4K&#41;<br />ReadProc Rd&#91;0x10&#93;; // read procs &#40;each represents 4K address space&#41;<br /><br />u8 Read_RAM&#40;u16 a&#41;<br />&#123;<br />&nbsp; return RAM&#91;a &amp; 0x07FF&#93;;&nbsp; // mask to handle mirroring<br />&#125;<br /><br />u8 Read_Nothing&#40;u16 a&#41;<br />&#123;<br />&nbsp; return 0;&nbsp; // junk return value<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp; technical note:&nbsp; you never actually return 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp; closest to &quot;nothing&quot; you return is open bus<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp; but don't worry too much about that.<br />&#125;<br /><br />u8 Read_PRG&#40;u16 a&#41;<br />&#123;<br />&nbsp; return PRG&#91;a &gt;&gt; 12&#93;&#91;a &amp; 0x0FFF&#93;;// right shift to get the 4K &quot;slot&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; and mask to get index within that slot<br />&#125;<br /><br />//----------------------------<br /><br />void WhenYouInit&#40;&#41;<br />&#123;<br />&nbsp; // set up your function pointers to read from the desired area<br />&nbsp; Rd&#91;0x0&#93; = &amp;Read_RAM; // $0xxx = RAM<br />&nbsp; Rd&#91;0x1&#93; = &amp;Read_RAM; // $1xxx = RAM<br /><br />&nbsp; Rd&#91;0x2&#93; = &amp;Read_Nothing; // $2xxx - $7xxx = nothing<br />&nbsp; Rd&#91;0x3&#93; = &amp;Read_Nothing; //&nbsp; note $6xxx,$7xxx typically<br />&nbsp; Rd&#91;0x4&#93; = &amp;Read_Nothing; //&nbsp; &nbsp; have PRG RAM, but that's omitted<br />&nbsp; Rd&#91;0x5&#93; = &amp;Read_Nothing; //&nbsp; &nbsp; for this example<br />&nbsp; Rd&#91;0x6&#93; = &amp;Read_Nothing;<br />&nbsp; Rd&#91;0x7&#93; = &amp;Read_Nothing;<br /><br />&nbsp; Rd&#91;0x8&#93; = &amp;Read_PRG; // the rest = PRG ROM<br />&nbsp; Rd&#91;0x9&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xA&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xB&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xC&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xD&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xE&#93; = &amp;Read_PRG;<br />&nbsp; Rd&#91;0xF&#93; = &amp;Read_PRG;<br />&#125;<br /><br />//-----------------------<br /><br />u8 WhenYouNeedToRead&#40;u16 addr&#41;<br />&#123;<br />&nbsp; // right shift the address to figure out which read function<br />&nbsp; //&nbsp; to call.&nbsp; Then call it<br />&nbsp; return Rd&#91;addr &gt;&gt; 12&#93;&#40;addr&#41;;<br />&#125;<br /><br />//-----------------------<br /><br />void SwapPRG16K&#40;int page&#41;<br />&#123;<br />&nbsp; // swap to put a new page at $8000-BFFF<br />&nbsp; // you'd probably want more generic routines than this<br />&nbsp; //&nbsp; this is just an example<br /><br />&nbsp; page *= 0x4000;<br />&nbsp; PRG&#91;0x8&#93; = &amp;PRGROM&#91;page&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#93;;<br />&nbsp; PRG&#91;0x9&#93; = &amp;PRGROM&#91;page + 0x1000&#93;;<br />&nbsp; PRG&#91;0xA&#93; = &amp;PRGROM&#91;page + 0x2000&#93;;<br />&nbsp; PRG&#91;0xB&#93; = &amp;PRGROM&#91;page + 0x3000&#93;;<br />&#125;<br /></div>
<br />
<br />Writing could be done the same way.  You just make another set of function pointers.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>jjpeerless</b> [ Sun Jun 07, 2009 5:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hey,
<br />
<br />    Thanks for the simple example, should clear up a lot of the confusion I was having.  My only question regarding your code is this:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">u8*&nbsp; PRG&#91;0x10&#93;;&nbsp; &nbsp; // bankswapping PRG pointers &#40;each represents 4K&#41; <br /></div>
<br />
<br />if each pointer points to 4KB of PRG_RAM, and there are 16 pointers, this is 64KB of PRG_RAM pointers when the nes is supposed to only have room for 32KB of addressable PRG_RAM at a time? From 0x8000 to 0xFFFF?  
<br />
<br />
<br />Anyways, I am going to go ahead and work on getting all the opcodes implemented first..should take a while given the amount of them and use dummy read_memory write_memory place holders in them.  
<br />
<br />Once I finish all of them I'll implement a similar memory access system as described in your sample and see where I'm at.
<br />
<br />Quick extra question though regarding the stack pointer. The stack address range from 0x0100 to 0x01FF.  In the opcode TXS we set the stack pointer to the value stored in X register.  If the X register is 8 bit then it can't possibly address a valid stack address?  This opcode seems strange to me anyways, shouldnt the stack pointer just be initialized to 0x01FF and decremented/incremented whenever something is push'd or pop'd?  Do we just do something like SP = (0x0100 | X)? and make the SP a 16bit address?
<br />
<br />Anyways, thanks again for the help.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Sun Jun 07, 2009 5:34 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />If you know what LDA $0100,X means, then stack accesses are like LDA $0100,SP. That's how an 8-bit stack pointer can point between $0100 and $01FF.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Disch</b> [ Sun Jun 07, 2009 5:35 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">jjpeerless wrote:</div><div class="quotecontent">if each pointer points to 4KB of PRG_RAM, and there are 16 pointers, this is 64KB of PRG_RAM pointers when the nes is supposed to only have room for 32KB of addressable PRG_RAM at a time? From 0x8000 to 0xFFFF? <br /></div><br /><br />Some mappers put it at $6000-FFFF, so you'd need at least 10.  But yeah you don't need all of them.  Having 16 pointers just makes the computation easier (don't have to subtract or anything)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Quick extra question though regarding the stack pointer. The stack address range from 0x0100 to 0x01FF.  In the opcode TXS we set the stack pointer to the value stored in X register.  If the X register is 8 bit then it can't possibly address a valid stack address?<br />[snip]<br />Do we just do something like SP = (0x0100 | X)? and make the SP a 16bit address?<br /></div><br /><br />Stack pointer is only 8 bits.  When you do a push/pop operation it accesses ($0100 | SP).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">This opcode seems strange to me anyways, shouldnt the stack pointer just be initialized to 0x01FF and decremented/incremented whenever something is push'd or pop'd?</div><br /><br />It's important to be able to set all regs to a known state.  Games will TSX once at program startup to ensure that the stack is where they want it to be (some games move the stack down to $0180 so they can use $01Fx for other things).  Other games have multiple stacks and use TXS/TSX to switch between them.<br /><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">thanks again for the help.</div>
<br />
<br />np

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>1</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>