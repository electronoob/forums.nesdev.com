<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=12&amp;t=2919" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2007-02-09T13:59:43-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=12&amp;t=2919</id>
<entry>
<author><name><![CDATA[James]]></name></author>
<updated>2007-02-09T13:59:43-07:00</updated>
<published>2007-02-09T13:59:43-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21888#p21888</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21888#p21888"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21888#p21888"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />you can interpolate per sample rather than outright drop frames. I've been completely unable to think of how to do this, however.<br /></div><br />My NES emulator does just what you're talking about.  The emulation loop is synced to 60Hz (using my monitor's vsync rate, but it could use any timer).  Every other frame, I check how full the DirectSound buffer is and adjust the playback frequency to compensate.  I keep the buffer about 70% full so I never have to drop video frames to catch up or block waiting for the buffer to accept more data.  The adjustments are small enough that there's no (obvious) audible frequency changes.  This is with an 80ms buffer (at 70% full, an average of 3-4 frames latency) on a SoundBlaster X-Fi (so not sure how well it works with onboard audio).<br /><br />If you're intersted, I'll clean up and post the current version of the code I use (the version on the web site uses a different technique, though the idea is similar).<br /><br />James<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=88">James</a> — Fri Feb 09, 2007 1:59 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2007-02-07T13:26:57-07:00</updated>
<published>2007-02-07T13:26:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21872#p21872</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21872#p21872"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21872#p21872"><![CDATA[
Cubic and Hermite are often used to mean the same thing: interpolation based on the value and first differential at the start and end of each interval.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Wed Feb 07, 2007 1:26 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-07T09:47:47-07:00</updated>
<published>2007-02-07T09:47:47-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21871#p21871</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21871#p21871"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21871#p21871"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Can't you just add another pseudo hardware device to the emuated SNES that claims to be able to affect the CPU just after the beginning of every frame? Then that device would get control at the right spot every frame, without adding any checks in the emulator (since I'm assuming you already have the framework for this sort of event).<br /></div><br /><br />I like the idea. However, I have kind of an odd setup. I wanted to account for the possibly adding special clockrate chips to the emulator in the future (eg DSP-1, SuperFX, SA-1, etc ... though they mostly use the S-CPU clock rate fed to the cartridge pins anyway). So what I have is one variable for each two clocks that need to synchronize. Right now, there's just one for S-CPU &lt;&gt; S-SMP. Since the S-PPU1/2 and S-DSP are not emulated at the clock level, they are just enslaved to the CPU and SMP. Therefore, for CPU&lt;&gt;SMP, I keep one 64-bit variable. Whenever the CPU adds clocks, I subtract from this value by clocks * smpclockrate. Whenever the SMP adds clocks, I add to it by clocks *cpuclockrate. If the clocks were identical (eg CPU&lt;&gt;PPU), then the multiplication wouldn't be necessary.<br />I can detect if one processor is ahead by seeing if this value is &gt;=0 or &lt;0, respectively.<br />Now, the fun part is that to save speed, when I ask one processor to sync to the other, it will run nonstop until that processor needs to access the other processor, in which case it switches contexts and runs the other processor.<br />The way I break out, is that each time the S-CPU vcounter reaches 240 (where no video can be rendered, regardless of region or overscan settings), I context switch back to the main thread to end the "run_frame();" call.<br />I could add a function that does something like "keep running the SMP until the clock rate is as close to equal as possible", but the only way I could prevent it from running forever and/or switching back to the other processor is to add a check to break out when even right inside the core "add_clocks();" function for each processor. This would add a ton of overhead, since these functions are called millions of times a second. Same thing if I substituted the function with a function pointer that I switched out, indirect function call overhead would then add up. Right now the add_clocks functions that sync the two processors are force inlined and mainly consist of one add, mul and compare.<br />Lastly, this could get a lot more complex if and when more clock syncs were thrown into the mix. Still, it's a good idea, and the most viable one ...<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Could this be because your application is asking for another page flip before the first one has occurred, and the API must block that thread until the first completes?<br /></div><br /><br />That's a very real possibility, however neither DDraw nor D3D give you a way to see if you already have a page flip that is pending, so you can hold off. If it did, that would be absolutely perfect.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />This always happens to me when I don't want to slow down and approach the problem in isolation from the main project. At some point in the future I eventually do that, then spend a week or more experimenting with the concepts alone and figure it out. I have to become interested in the topic for its own sake, rather than as a mere problem to be solved and forgotten.<br /></div><br /><br />If you're still interested in this topic, then I certainly don't mind continuing to discuss it with you. I'd like to have a definitive solution for this problem as well :D<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The number of samples have to vary by one or two, since there is some fraction of a sample extra each frame.<br /></div><br /><br />For the aforementioned reasons, I'm getting a lot more than that, sadly. Resampling by one sample or two per 25ms audio buffer should be quite easy.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Cosine introduces discontinuities at each point, and it shows in frequency graphs. Here are the four compared (FIR using 11 point kernels), using a sweep from 16 kHz to 0 kHz in a 32 kHz sampled stream, resampled to 44.1 kHz by these.<br /><br />...<br /><br />You can see the low frequency aliases in linear and cosine (cosine comes out worse in some ways), while Hermite and FIR have one that is mostly inaudible in the upper range.<br /></div><br /><br />To be honest, I really don't understand the graph or what you're meaning, but I have virtually no experience with audio. No need to explain it in layman's terms, though. I'll take your word (and picture) for it that the FIR resampler is best. By the way, how does cubic look on that graph? Comparable, or worse than hermite?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Wed Feb 07, 2007 9:47 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2007-02-04T12:28:49-07:00</updated>
<published>2007-02-04T12:28:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21841#p21841</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21841#p21841"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21841#p21841"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I simply can't reliably detect the start of vblank and have the video code blitted to the screen. No matter how many places I tell bsnes to check to see if we've reached vblank (over 40,000 times a second), it's still not enough and I miss entire vblank periods 20% of the time. Most likely, there are too many parts in bsnes that eat up so much CPU time that it jumps right over vblank.<br /></div><br />Can't you just add another pseudo hardware device to the emuated SNES that claims to be able to affect the CPU just after the beginning of every frame? Then that device would get control at the right spot every frame, without adding any checks in the emulator (since I'm assuming you already have the framework for this sort of event).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />It's too bad video drivers and/or API developers are too incompetent to design APIs that handle page flipping completely transparently in the background without deadlocking your applications when you request to blit the image to the screen.<br /></div><br />Could this be because your application is asking for another page flip before the first one has occurred, and the API must block that thread until the first completes?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Anyway, I've given up, sadly. I can't think of any way to do this, and I've exceeded my patience and run out of ideas.<br /></div><br />This always happens to me when I don't want to slow down and approach the problem in isolation from the main project. At some point in the future I eventually do that, then spend a week or more experimenting with the concepts alone and figure it out. I have to become interested in the topic for its own sake, rather than as a mere problem to be solved and forgotten.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Funny that I just now realized that when sinimas made the comment that the number of audio samples generated per video frame should be constant, and while immediately thinking "no, that's not true", realized, "wait... actually, yes, that should be true".<br /></div><br />The number of samples have to vary by one or two, since there is some fraction of a sample extra each frame.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I like cosine, because the graphs for it are prettier, they look almost identical to hermite, and besides the end points, very similar to cubic as well.<br /></div><br />Cosine introduces discontinuities at each point, and it shows in frequency graphs. Here are the four compared (FIR using 11 point kernels), using a sweep from 16 kHz to 0 kHz in a 32 kHz sampled stream, resampled to 44.1 kHz by these.<br /><br /><img src="it's now http://h1.ripway.com/blargg/temp/resamplers.png" alt="Image" /><br /><br />You can see the low frequency aliases in linear and cosine (cosine comes out worse in some ways), while Hermite and FIR have one that is mostly inaudible in the upper range.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sun Feb 04, 2007 12:28 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-04T03:36:29-07:00</updated>
<published>2007-02-04T03:36:29-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21834#p21834</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21834#p21834"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21834#p21834"><![CDATA[
Well, I just realized something very stupid.<br /><br />I had forgotten about the way I implemented cothreads in bsnes: I basically take advantage of the fact that I don't have to back out of the CPU or SMP like normal emulators do, since I can swap between the two at any time thanks to cothreads; and so I run the currently active core as long as possible: either until one accesses the other, or until ~300,000 clock ticks have passed on one or the other (and even that is only to keep the audio buffer from emptying and the difference counters from overflowing).<br /><br />This of course means that the CPU and SMP can be desynchronized by up to 1/8th of a second at any given time. Hence, the wildly fluctuating samples generated per video frame.<br /><br />I can disable this behavior, but I will lose much of the benefits of cooperative multithreading and take a massive speed hit, especially on platforms where libco doesn't run as fast. At least I'll still get the cleaner code benefits. I guess I can give it a try, though I still think the resampling rate will be too sporadic to sound good.<br /><br />Funny that I just now realized that when sinimas made the comment that the number of audio samples generated per video frame should be constant, and while immediately thinking "no, that's not true", realized, "wait... actually, yes, that should be true". Oh well.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Sun Feb 04, 2007 3:36 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-04T01:50:41-07:00</updated>
<published>2007-02-04T01:50:41-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21832#p21832</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21832#p21832"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21832#p21832"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The answer is probably that you're trying to solve it in a way that goes beyond your skills (remember, debugging takes twice the effort as coding). First thing, write a minimal app from scratch that manifests the problem. If possible, write all the relevant code from scratch and keep it damn simple. Real-time behavior can get complex very easily. From what you're written, it sounds like you're debugging all this in bsnes. I know the urge to hack away and put off doing a clean prototype.<br /></div><br /><br />You're correct, I am not skilled enough to debug code running in realtime like this. I think I see the problem, however. I simply can't reliably detect the start of vblank and have the video code blitted to the screen. No matter how many places I tell bsnes to check to see if we've reached vblank (over 40,000 times a second), it's still not enough and I miss entire vblank periods 20% of the time. Most likely, there are too many parts in bsnes that eat up so much CPU time that it jumps right over vblank. I patched all the obvious ones, adding checks to every scanline rendered both by the PPU and the filter, to every audio sample generated, and during every wait state inside the audio sync code. I even removed all Sleep(1) calls in case that 1ms were to kick me out of vblank. Still wasn't good enough.<br /><br />It's too bad video drivers and/or API developers are too incompetent to design APIs that handle page flipping completely transparently in the background without deadlocking your applications when you request to blit the image to the screen. Realistically, all you need is a hardware interrupt to trigger the second vblank edge is reached. It's amazing the way a twenty year old video game system has such a device (NES NMI, etc), and yet modern computers still lack this very useful functionality.<br /><br />Anyway, I've given up, sadly. I can't think of any way to do this, and I've exceeded my patience and run out of ideas. Thanks for trying to help, though. I really wish I knew how other emulators managed to do this, but the answer is probably something I wouldn't be willing to do anyway (eg force emulation to generate more samples, which would be visible to the system's sound registers).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I've also done more work on resamplers (did you get the ones I e-mailed yesterday?) and linear is quite fine for SNES. I just did an all-integer implementation of cosine interpolation, which is a bit better than linear. I love this fast sin approximation:<br /></div><br /><br />I like cosine, because the graphs for it are prettier, they look almost identical to hermite, and besides the end points, very similar to cubic as well. Whereas linear looks very mechanical and unnatural, even though I agree that it sounds just fine.<br /><br />Hmm, I like the sin algorithm. Perhaps I can take advantage of it. How do you convert that value to cosine again?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Sun Feb 04, 2007 1:50 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2007-02-03T17:27:51-07:00</updated>
<published>2007-02-03T17:27:51-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21829#p21829</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21829#p21829"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21829#p21829"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Darn, seems no one knows why my code isn't working :/<br /></div><br />The answer is probably that you're trying to solve it in a way that goes beyond your skills (remember, debugging takes twice the effort as coding). First thing, write a minimal app from scratch that manifests the problem. If possible, write all the relevant code from scratch and keep it damn simple. Real-time behavior can get complex very easily. From what you're written, it sounds like you're debugging all this in bsnes. I know the urge to hack away and put off doing a clean prototype.<br /><br />I've also done more work on resamplers (did you get the ones I e-mailed yesterday?) and linear is quite fine for SNES. I just did an all-integer implementation of cosine interpolation, which is a bit better than linear. I love this fast sin approximation:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">double fast_sin&#40; double x &#41;<br />&#123;<br />    double pi = 3.14159265358979323846;<br />    assert&#40; -pi &lt;= x &amp;&amp; x &lt;= pi &#41;;<br />    <br />    x /= pi;<br />    return &#40;1 - fabs&#40; x &#41;&#41; * x * 4;<br />&#125;</div><p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Feb 03, 2007 5:27 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-03T16:16:28-07:00</updated>
<published>2007-02-03T16:16:28-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21828#p21828</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21828#p21828"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21828#p21828"><![CDATA[
Darn, seems no one knows why my code isn't working :/<br /><br />tepples, there are two crystal clocks inside the SNES. There's one shared by S-CPU, S-PPU1, S-PPU2 and S-WRAM at ~315/88*6mhz, and another one shared by the S-SMP (SPC700), S-DSP and the 64k WRAM they share (don't know if that one has a name or not), running at ~32040*768hz.<br /><br />Although both clocks obviously have precision variances in real life, in emulation I can at least guarantee a constant ratio of clock cycles between the two processors.<br /><br />I really don't wish to to fake the emulated speeds of either processor to get them more synced up (in fact, EWJ2 sound effects break if you change the sound clock enough to get 32khz output). Though I realize that since I don't (and really can't) emulate a true crystal clock's variance in realtime, the 32040*768hz approach is still more accurate than 32000*768hz. I will have to resample the audio output <em>and</em> drop video frames, sadly.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Sat Feb 03, 2007 4:16 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2007-02-03T12:43:59-07:00</updated>
<published>2007-02-03T12:43:59-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21827#p21827</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21827#p21827"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21827#p21827"><![CDATA[
tepples, I'm guessing that you're going to suggest to take advantage of variations to simplify the task at hand. As in, if the SPC is clocked by a separate crystal (which it is), then make slight adjustments to the emulated crystal's rate rather than trying to resample the output. I took advantage of something similar in my NTSC filter regarding the output aspect ratio, since TVs can vary.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Sat Feb 03, 2007 12:43 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2007-02-03T12:12:41-07:00</updated>
<published>2007-02-03T12:12:41-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21826#p21826</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21826#p21826"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21826#p21826"><![CDATA[
In the Super NES hardware, are the 65C816 CPU, the SPC700 CPU, and the DSP clocked from the same crystal, such that there are exactly 32040.00000 samples per 3579545.454 CPU cycles? Or is there unit-to-unit variation in their clock speeds?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Sat Feb 03, 2007 12:12 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-03T06:15:57-07:00</updated>
<published>2007-02-03T06:15:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21814#p21814</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21814#p21814"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21814#p21814"><![CDATA[
Ok, I've tried again for the 67th time to get the audio working plus the video syncing to vblank and dropping frames it can't possibly draw without tearing.<br /><br />It's basically your method, blargg, but I haven't enabled the audio resampling to try and even out the audio&lt;&gt;video refresh rate ratio just yet (I actually tried it using a quick hack, and it helped a tiny bit, but there's a much larger problem somewhere making the whole thing not work).<br /><br />I posted the code I was using, and an explanation of how it works, here:<br /><!-- m --><a class="postlink" href="http://board.zsnes.com/phpBB2/viewtopic.php?p=139973#139973">http://board.zsnes.com/phpBB2/viewtopic ... 973#139973</a><!-- m --><br /><br />I don't suppose anyone sees any obvious flaws with this? I don't even know where things are going wrong, sadly :(<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Sat Feb 03, 2007 6:15 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-02T11:53:42-07:00</updated>
<published>2007-02-02T11:53:42-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21805#p21805</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21805#p21805"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21805#p21805"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />By 100%, do you mean how fast it's running relative to a SNES? I don't think you're going to have much luck handling a situation where the emulator drops to 80% real-time for a second without a significant audio glitches, unless you add a lot of latency. I can imagine it. Start emulating a game and see "buffering..."<br /></div><br /><br />Aww :(<br />And the problem with the buffering is that it delays input responsiveness. Not to mention, video buffering eats up a ton of memory. So, I guess I'll just have to specify that if you want clear audio, you'll have to cap emulation speeds at 50% for P4s, 25% for P2s, or for 486s that people still insist on running, 10%, heh.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />If you're averaging values, then they will vary <em>less</em> between readings, not more. Averaging is a form of low-pass filtering.<br /></div><br /><br />Hmm, my averaging technique was: instead of testing every sample to see when we hit the next audio buffer, we test every 256 SNES audio samples generated. So the # of samples-&gt;output samples is always mod 256. It was cleaning out the audio a little more, but the differences seemed more extreme as a result (eg instead of 4,4,5,5,5,4,5; you get 4,4,4,4,4,4,8).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I've been working on my polyphase (FIR) resampler again and will put some time into allowing really fine ratio adjustment.<br /></div><br /><br />Sounds interesting. I already can't tell the difference between linear and cubic, despite it being very evident on graphs (hence I didn't bother writing a 4-tap hermite resampler), but I'm really not resampling by more than 50%, either.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Fri Feb 02, 2007 11:53 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2007-02-02T08:57:25-07:00</updated>
<published>2007-02-02T08:57:25-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21802#p21802</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21802#p21802"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21802#p21802"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />While I should hopefully be able to stay within that range when emulation stays at 100%, I would like to cover cases when speed drops below 100%.<br /></div><br />By 100%, do you mean how fast it's running relative to a SNES? I don't think you're going to have much luck handling a situation where the emulator drops to 80% real-time for a second without a significant audio glitches, unless you add a lot of latency. I can imagine it. Start emulating a game and see "buffering..."<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I guess I'm just worried that resampling audio to any inconsistent rate will be audibly noticeable.<br /></div><br />An inconsistent rate? You should be resampling the audio to a consistent rate, as in, an equal time delay between each sample.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You should probably look at the average of several buffer readings so you don't change the rate really often (in case the reading itself jumps around often).<br /></div><br />Doing this causes more severe rounding, and pitch rate changes even more drastically, but less frequently: <br />eg instead of 31119, 32007, 32002, 32003; now you have: <br />32000, 32000, 32000, 32011</div><br />If you're averaging values, then they will vary <em>less</em> between readings, not more. Averaging is a form of low-pass filtering.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Ah, ok. So what you want me to do is get the best resampling rate possible, and then always resample to that constant rate, and occasionally add/drop a video frame. This will at least make dropped frames far, far less frequent than once every ten seconds.<br /></div><br />Right. But one frame glitch every 10 seconds is already pretty good, in my opinion.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I was thinking you were aiming for always resampling the audio so that the SNES is always synchronized to the video refresh rate; hence never any dropped frames.<br /></div><br />That's what <em>you</em> want(ed) to do, and what I was mostly offering ideas about. The simpler solution is what I prefer, since it's mostly self-explanatory.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I was hoping to offer two modes, one that always guarantees no resampling of audio, but will have video frame dropping; and one that guarantees no dropped frames, but will always resample audio. Are these two impractical / impossible?<br /></div><br />I doubt you'll frame glitches on a general-purpose operating system. If you really want to give it a fair chance, write some simple test applications that find out whether it's possible at all. One of them shouldn't do any audio, just video.<br /><br />I've been working on my polyphase (FIR) resampler again and will put some time into allowing really fine ratio adjustment.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Fri Feb 02, 2007 8:57 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[byuu]]></name></author>
<updated>2007-02-02T08:33:19-07:00</updated>
<published>2007-02-02T08:33:19-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21801#p21801</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21801#p21801"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21801#p21801"><![CDATA[
Sorry for the delayed response.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />And if you adjust the audio to be faster/slower in just the right proportion, the buffer never becomes completely empty or full. This would be a closed-loop system, where the adjustments are in response to how full the buffer is.<br /></div><br /><br />That's what I was hoping to do, but it seems that according to tepples, I cannot adjust by more than 100 samples/second, or the audio pitch will noticeably change. While I should hopefully be able to stay within that range when emulation stays at 100%, I would like to cover cases when speed drops below 100%. The differences between every audio block is far too great for just resampling block by block. Example: with 750ms latency (eg a massive latency buffer): format = req:resampledfrom@32khz<br />8000:7850<br />8000:8200<br />8000:7400<br />... etc.<br /><br />I would like to avoid locking the emulation speed to the lowest known frequency; in the above case, slowing emulation down 7400/8000% permanently.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Adjust the slave's data rate by speeding up/slowing down the data that the emulator produces. For video, you change the delay between frames. For audio, you resample it. In either case you ultimately go from X to Y data units per second (frames or samples). Since these transformations are done after emulation, accuracy is not affected.<br /></div><br /><br />I guess I'm just worried that resampling audio to <em>any</em> inconsistent rate will be audibly noticeable. I suppose I can write a test application too to test the 0.35% thing. I do know that when I was getting variances of ~1% due to triple buffering being locking (haven't rewritten it to poll the video card vblank or added high resolution timers to test audio position yet), it was unbelievably noticeable. You could clearly hear when each buffer started playing at a different pitch rate.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />You should probably look at the average of several buffer readings so you don't change the rate really often (in case the reading itself jumps around often).<br /></div><br /><br />Doing this causes more severe rounding, and pitch rate changes even more drastically, but less frequently:<br />eg instead of 31119, 32007, 32002, 32003; now you have:<br />32000, 32000, 32000, 32011<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Pitch change (change in resample ratio) will be much more noticeable if you're not using a high-quality resampler, as the artifacts introduced by lower-quality methods can change a lot when even small changes are made to the ratio. So the ratio change problem might not be due to pitch change alone.<br /></div><br /><br />Ok, I'm using these filters now:<br /><!-- m --><a class="postlink" href="http://byuu.cinnamonpirate.com/temp/audio.txt">http://byuu.cinnamonpirate.com/temp/audio.txt</a><!-- m --><br /><br />Aside from the small issue of no clamping in the cubic filter, they seem to sound ok. I can fix the cubic one, I was just running out of time when I wrote the above code.<br /><br />Should cubic or cosine be sufficient for resampling? It still sounds just as noticeable to me when pitch change &gt;= 1%.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Here's an example of the above: say your emulated SNES generates 60.09 frames and 32040 stereo samples per second, and your host PC's monitor runs at 60.10 Hz and audio card at 31900 Hz (even though it claims 32000 Hz). For the fewest dropped/doubled video frames, you'd want to resample the audio to 31905.31 Hz. Played at 31900 Hz, this would use 32045.332 SNES stereo samples per second, resulting in 60.1 video frames per second, which matches the host rate. Invariably, the host rates will vary a tiny bit over time, so there would be an occasional dropped or doubled video frame.<br /></div><br /><br />Ah, ok. So what you want me to do is get the best resampling rate possible, and then always resample to that constant rate, and occasionally add/drop a video frame. This will at least make dropped frames far, far less frequent than once every ten seconds. I was thinking you were aiming for always resampling the audio so that the SNES is always synchronized to the video refresh rate; hence never any dropped frames.<br />I was hoping to offer two modes, one that always guarantees no resampling of audio, but will have video frame dropping; and one that guarantees no dropped frames, but will always resample audio. Are these two impractical / impossible?<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=375">byuu</a> — Fri Feb 02, 2007 8:33 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2007-01-31T17:07:57-07:00</updated>
<published>2007-01-31T17:07:57-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21747#p21747</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21747#p21747"/>
<title type="html"><![CDATA[Emulation and streaming asynchronous audio resampling]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=2919&amp;p=21747#p21747"><![CDATA[
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />a)If audio is always slower than video, then the audio buffer continues to drain until it is empty. If it's faster, then it will overflow.<br /></div><br />And if you adjust the audio to be faster/slower in just the right proportion, the buffer never becomes completely empty or full. This would be a closed-loop system, where the adjustments are in response to how full the buffer is.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The SNES outputs the same video frames to samples ratio (which changes based on runtime toggleable interlace setting), but the PC is where the variance comes into play. The PC can make it so that one is always faster or slower than the other, and to compensate, eventually you have to resample or drop/skip data.<br /></div><br />Exactly. So another way of stating the solution is that you resample the audio or video so that the resulting audio/video ratio matches that of the PC (again, using feedback).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />How can I adjust the slave's data rate without affecting accuracy? You mean I should constantly ask the host to change the playback frequency?<br /></div><br />Adjust the slave's data rate by speeding up/slowing down the data that the emulator produces. For video, you change the delay between frames. For audio, you resample it. In either case you ultimately go from X to Y data units per second (frames or samples). Since these transformations are done after emulation, accuracy is not affected.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Also, I can't make my audio buffer that big. The bigger the buffering, the longer the latency. It's already barely perceptible at 75ms.<br /></div><br />As long as the audio buffer is several times the resolution of the "how full is the buffer?" function, you can get enough feedback to adjust the audio rate. For example, if buffer is 1/2 full, resample output to 32000 Hz. If buffer is less than 1/3 full, resample output to 31950 Hz. If buffer is more than 2/3 full, resample output to 32050 Hz. You should probably look at the average of several buffer readings so you don't change the rate really often (in case the reading itself jumps around often).<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />So now, here's what I've come up with: the pitch change, fluttering, is detectable even with the lowest possible latency setting (~25ms ring buffers x 3).<br /></div><br />Pitch change (change in resample ratio) will be much more noticeable if you're not using a high-quality resampler, as the artifacts introduced by lower-quality methods can change a lot when even small changes are made to the ratio. So the ratio change problem might not be due to pitch change alone.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I was reading a forum post where someone was resampling 7999hz to 8000hz, and the one sample difference was audible for them as a clicking sound. The person was duplicating the last sample, as that was really his only choice.<br /></div><br />Duplicating the last sample is not merely changing the pitch by 1/8000; it's doing a lot more things (like adding noise/harmonics to the signal). It is possible to resample by that amount, it's just not as cheap as duplicating the last sample.<br /><br />I think slaving the video to audio is a far superior solution that's a ton simpler, and necessary when the monitor's refresh rate isn't exactly 60.whatever Hz. To do this, you adjust the frame rate based on how full the audio buffer is, on average. To reduce consistent frame dropping/doubling, you should resample the audio to an unchanging rate based on the audio card's actual rate and the monitor's actual frame rate.<br /><br />Here's an example of the above: say your emulated SNES generates 60.09 frames and 32040 stereo samples per second, and your host PC's monitor runs at 60.10 Hz and audio card at 31900 Hz (even though it claims 32000 Hz). For the fewest dropped/doubled video frames, you'd want to resample the audio to 31905.31 Hz. Played at 31900 Hz, this would use 32045.332 SNES stereo samples per second, resulting in 60.1 video frames per second, which matches the host rate. Invariably, the host rates will vary a tiny bit over time, so there would be an occasional dropped or doubled video frame.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Wed Jan 31, 2007 5:07 pm</p><hr />
]]></content>
</entry>
</feed>