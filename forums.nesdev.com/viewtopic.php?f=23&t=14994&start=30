<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-gb" xml:lang="en-gb">
<head>

<link rel="icon" href="/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta http-equiv="content-language" content="en-gb" />
<meta http-equiv="content-style-type" content="text/css" />
<meta http-equiv="imagetoolbar" content="no" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="keywords" content="" />
<meta name="description" content="" />

<title>nesdev.com &bull; View topic - Z80 T-cycle timing: what the hell damn guy?</title>

<link rel="alternate" type="application/atom+xml" title="Feed - nesdev.com" href="http://forums.nesdev.com/feed.php" /><link rel="alternate" type="application/atom+xml" title="Feed - News" href="http://forums.nesdev.com/feed.php?mode=news" /><link rel="alternate" type="application/atom+xml" title="Feed - All forums" href="http://forums.nesdev.com/feed.php?mode=forums" /><link rel="alternate" type="application/atom+xml" title="Feed - New Topics" href="http://forums.nesdev.com/feed.php?mode=topics" /><link rel="alternate" type="application/atom+xml" title="Feed - Active Topics" href="http://forums.nesdev.com/feed.php?mode=topics_active" /><link rel="alternate" type="application/atom+xml" title="Feed - Forum - Other Retro Dev" href="http://forums.nesdev.com/feed.php?f=23" /><link rel="alternate" type="application/atom+xml" title="Feed - Topic - Z80 T-cycle timing: what the hell damn guy?" href="http://forums.nesdev.com/feed.php?f=23&amp;t=14994" />

<link rel="stylesheet" href="./style.php?id=1&amp;lang=en" type="text/css" />

<script type="text/javascript">
// <![CDATA[


function popup(url, width, height, name)
{
	if (!name)
	{
		name = '_popup';
	}

	window.open(url.replace(/&amp;/g, '&'), name, 'height=' + height + ',resizable=yes,scrollbars=yes,width=' + width);
	return false;
}

function jumpto()
{
	var page = prompt('Enter the page number you wish to go to:', '3');
	var per_page = '15';
	var base_url = './viewtopic.php?f=23&amp;t=14994';

	if (page !== null && !isNaN(page) && page == Math.floor(page) && page > 0)
	{
		if (base_url.indexOf('?') == -1)
		{
			document.location.href = base_url + '?start=' + ((page - 1) * per_page);
		}
		else
		{
			document.location.href = base_url.replace(/&amp;/g, '&') + '&start=' + ((page - 1) * per_page);
		}
	}
}

/**
* Find a member
*/
function find_username(url)
{
	popup(url, 760, 570, '_usersearch');
	return false;
}

/**
* Mark/unmark checklist
* id = ID of parent container, name = name prefix, state = state [true/false]
*/
function marklist(id, name, state)
{
	var parent = document.getElementById(id);
	if (!parent)
	{
		eval('parent = document.' + id);
	}

	if (!parent)
	{
		return;
	}

	var rb = parent.getElementsByTagName('input');
	
	for (var r = 0; r < rb.length; r++)
	{
		if (rb[r].name.substr(0, name.length) == name)
		{
			rb[r].checked = state;
		}
	}
}



	/**
	* Play quicktime file by determining it's width/height
	* from the displayed rectangle area
	*
	* Only defined if there is a file block present.
	*/
	function play_qt_file(obj)
	{
		var rectangle = obj.GetRectangle();

		if (rectangle)
		{
			rectangle = rectangle.split(',')
			var x1 = parseInt(rectangle[0]);
			var x2 = parseInt(rectangle[2]);
			var y1 = parseInt(rectangle[1]);
			var y2 = parseInt(rectangle[3]);

			var width = (x1 < 0) ? (x1 * -1) + x2 : x2 - x1;
			var height = (y1 < 0) ? (y1 * -1) + y2 : y2 - y1;
		}
		else
		{
			var width = 200;
			var height = 0;
		}

		obj.width = width;
		obj.height = height + 16;

		obj.SetControllerVisible(true);

		obj.Play();
	}


// ]]>
</script>
</head>
<body class="ltr">

<a name="top"></a>

<div id="wrapheader">

	<div id="logodesc">
	</div>

	<div id="menubar">

		<table width="100%" cellspacing="0">
		<tr>
			<td rowspan="2"><a href="./index.php"><img src="./styles/subsilver2/imageset/site_logo.gif" alt="" title="" /></a></td>
			<td width="100%" align="center"><h1>nesdev.com</h1><span class="gen">NES Development and Strangulation Records message boards</span></td>
		</tr>
		<tr>
			<td align="center">
				<!--<div style="float: right;">
					<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
					<input type="hidden" name="cmd" value="_s-xclick">
					<input type="hidden" name="hosted_button_id" value="X2HM4WNR5YT8S">
					<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
					<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
					</form>
				</div>-->
				<a href="./faq.php"><img src="./styles/prosilver/theme/images/icon_mini_faq.gif" width="12" height="13" alt="*" /> FAQ</a>
				&nbsp; &nbsp;<a href="./search.php"><img src="./styles/prosilver/theme/images/icon_mini_search.gif" width="12" height="13" alt="*" /> Search</a>
				<br />	
				 &nbsp;<a href="./ucp.php?mode=minion"><img src="./styles/prosilver/theme/images/icon_mini_register.gif" width="12" height="13" alt="*" /> Register</a>
					&nbsp; &nbsp;<a href="./ucp.php?mode=login"><img src="./styles/prosilver/theme/images/icon_mini_login.gif" width="12" height="13" alt="*" /> Login</a>&nbsp;
			</td>
		</tr>
		</table>
	</div>

	<div id="datebar">
		<table width="100%" cellspacing="0">
		<tr>
			<td class="gensmall"></td>
			<td class="gensmall" align="right">It is currently Fri Aug 17, 2018 12:25 am<br /></td>
		</tr>
		</table>
	</div>

</div>

<div id="wrapcentre">

	
	<p class="searchbar">
		<span style="float: left;"><a href="./search.php?search_id=unanswered">View unanswered posts</a> | <a href="./search.php?search_id=active_topics">View active topics</a></span>
		
	</p>
	

	<br style="clear: both;" />

	<table class="tablebg" width="100%" cellspacing="1" cellpadding="0" style="margin-top: 5px;">
	<tr>
		<td class="row1">
			<p class="breadcrumbs"><a href="./index.php">Board index</a> &#187; <a href="./viewforum.php?f=25">Other</a> &#187; <a href="./viewforum.php?f=23">Other Retro Dev</a></p>
			<p class="datetime">All times are UTC - 7 hours </p>
		</td>
	</tr>
	</table>

	<br />
	

					<center>
					<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- NesDev Forums -->
					<ins class="adsbygoogle"
						 style="display:block"
						 data-ad-client="ca-pub-7801010229099644"
						 data-ad-slot="7979066809"
						 data-ad-format="auto"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>
					</center>
	<br />


<div id="pageheader">
	<h2><a class="titles" href="./viewtopic.php?f=23&amp;t=14994&amp;start=30">Z80 T-cycle timing: what the hell damn guy?</a></h2>


</div>

<br clear="all" /><br />

<div id="pagecontent">

	<table width="100%" cellspacing="1">
	<tr>
		<td align="left" valign="middle" nowrap="nowrap">
		<a href="./posting.php?mode=post&amp;f=23"><img src="./styles/subsilver2/imageset/en/button_topic_new.gif" alt="Post new topic" title="Post new topic" /></a>&nbsp;<a href="./posting.php?mode=reply&amp;f=23&amp;t=14994"><img src="./styles/subsilver2/imageset/en/button_topic_reply.gif" alt="Reply to topic" title="Reply to topic" /></a>
		</td>
		
			<td class="nav" valign="middle" nowrap="nowrap">&nbsp;Page <strong>3</strong> of <strong>3</strong><br /></td>
			<td class="gensmall" nowrap="nowrap">&nbsp;[ 37 posts ]&nbsp;</td>
			<td class="gensmall" width="100%" align="right" nowrap="nowrap"><b><a href="#" onclick="jumpto(); return false;" title="Click to jump to pageâ€¦">Go to page</a> <a href="./viewtopic.php?f=23&amp;t=14994&amp;start=15">Previous</a>&nbsp;&nbsp;<a href="./viewtopic.php?f=23&amp;t=14994">1</a><span class="page-sep">, </span><a href="./viewtopic.php?f=23&amp;t=14994&amp;start=15">2</a><span class="page-sep">, </span><strong>3</strong></b></td>
		
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr>
		<td class="cat">
			<table width="100%" cellspacing="0">
			<tr>
				<td class="nav" nowrap="nowrap">&nbsp;
				<a href="./viewtopic.php?f=23&amp;t=14994&amp;start=30&amp;view=print" title="Print view">Print view</a>
				</td>
				<td class="nav" align="right" nowrap="nowrap"><a href="./viewtopic.php?f=23&amp;t=14994&amp;view=previous">Previous topic</a> | <a href="./viewtopic.php?f=23&amp;t=14994&amp;view=next">Next topic</a>&nbsp;</td>
			</tr>
			</table>
		</td>
	</tr>

	</table>


	<table class="tablebg" width="100%" cellspacing="1">
	
		<tr>
			<th>Author</th>
			<th>Message</th>
		</tr>
	<tr class="row1">

			<td align="center" valign="middle">
				<a name="p187512"></a>
				<b class="postauthor">TOUKO</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187512">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187512#p187512"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Jan 23, 2017 1:27 am&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Mon Mar 30, 2015 10:14 am<br /><b>Posts:</b> 275
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">There's no documentation anywhere on this.</div><br />I don't know if you already knew this :<br /><!-- m --><a class="postlink" href="http://www.archaicpixels.com/Main_Page#Hardware">http://www.archaicpixels.com/Main_Page#Hardware</a><!-- m --><br /><br />you have also the charles MacDonald's pcetech doc:<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">  Table of contents:<br /><br /> 1.) Introduction<br /> 2.) HuC6280 - CPU<br /> 2.1) Interrupts<br /> 2.2) Timer<br /> 2.3) T flag<br /> 2.4) Timing<br /> 3.) Memory map<br /> 4.) I/O port<br /> 5.) HuC6260 - Video Display Controller<br /> 5.1) Register reference<br /> 5.2) Background<br /> 5.3) Sprites<br /> 5.4) DMA<br /> 6.) HuC6270 - Video Color Encoder<br /> 7.) Display details<br /> 8.) CD-ROM<br /> 8.1) Super System Card<br /> 9.) Display parameter settings<br /> 10.) Programmable Sound Generator<br /> 11.) Acknowledgements<br /> 12.) Contact<br /> 13.) Disclaimer<br /><br /> ----------------------------------------------------------------------------<br /> 1.) Introduction<br /> ----------------------------------------------------------------------------<br /><br /> This document is in a very preliminary state and is subject to change.<br /> Everything within has been tested and verified on a TurboGrafx-16 console,<br /> but please be aware that my testing methods or interpretations of<br /> results could be flawed. I can't guarantee that everything is 100% accurate.<br /><br /> At the moment, some parts of this document are simply a compilation of<br /> notes and test results, while others are detailed descriptions of the<br /> hardware. I'll try to get everything coordinated as time progresses.<br /><br /> ----------------------------------------------------------------------------<br /> 2.) HuC6280 - CPU <br /> ----------------------------------------------------------------------------<br /><br /> - Block transfer instructions push Y, A, X to the stack in that order, and<br />   then pop X, A, Y from the stack in that order when finished.<br /><br /> - For the alternating block transfer instructions (TAI and TIA), they<br />   alternate the source or destination address by adding and then<br />   subtracting one; not by inverting bit 0 of the address.<br /><br /> - The length parameter to a block transfer instruction specifies the<br />   number of bytes to transfer. For example, $0010 will transfer 16 bytes,<br />   and $0000 will transfer 64K bytes, not zero.<br /><br /> - Block transfer instructions cannot be interrupted. If an interrupt<br />   is supposed to occur, it occurs once the instruction finishes.<br /><br /> - When using any block transfer instruction to read addresses $0800 through<br />   $1400 in the I/O page, the value zero is always returned for every<br />   address, regardless of the CPU speed. (So you can't read the joystick<br />   port, timer, or IRQ registers) The I/O buffer is not changed either.<br /><br />   Writing to the same range of addresses using the block transfer<br />   instructions will work, and the I/O buffer will be modified.<br /><br /> - Stack and zero page operations always use logical addresses $2000-$21FF.<br />   For example, ROM data can be read by using instructions that access the<br />   zero page or stack.<br /><br /> - On power-up, MPR 7 is set to zero, and the other MPRs are loaded<br />   with random values.<br /><br /> - The TMA instruction transfers the contents of an MPR register to the<br />   accumulator. Bits 7 to 0 in the operand specify which MPR register to<br />   read from, bit 7 is MPR #7 and bit 0 is MPR #0.<br /><br />   If an operand of $00 is used, the accumulator is loaded with the last<br />   value that was written with TAM (only if one or more of it's operand bits<br />   were set), or the last value that was read with TMA. I think the CPU<br />   treats zero as a 'no change' value and the MPR selecting logic isn't<br />   updated from the last time it was set.<br /><br />   If multiple bits are set in the operand to TMA, the values from several<br />   MPRs are combined together and returned. However, I have not figured out<br />   exactly how this works.<br /><br /> - The TAM instruction transfers the contents of the accumulator to an MPR<br />   register. Bits 7 to 0 in the operand specify which MPR register to write<br />   to, bit 7 is MPR #7 and bit 0 is MPR #0.<br /><br />   If an operand of $00 is used, none of the MPR registers are written to.<br />   This does not change the last MPR value that can be read by TMA #$00.<br /><br />   If multiple bits are set in the operand to TAM, each MPR register selected<br />   is loaded with the accumulator. For example, an operand of $FF would load<br />   all MPR registers.<br /><br /> - ST0, ST1, ST2 write immediate data directly to the VDC (at physical<br />   addresses $1FE000-$1FE003), the address is not translated through the<br />   CPUs memory mapping hardware.<br /><br /> - When an interrupt occurs (I've tested the timer and IRQ1), P is pushed<br />   with the current state of D and T. Within the interrupt subroutine, the<br />   CPU clears D, T and sets I, preventing further interrupts from occuring.<br /><br /> - The B flag is set at all times. The only exception is when an interrupt<br />   occurs, (I've tested the timer and IRQ1) in this case the value of P<br />   pushed to the stack has B cleared. (but B is set if P is read again<br />   within the interrupt subroutine) The BRK instruction pushes P with B set.<br /><br /> - BRK pushes the return address plus one to the stack; the next byte after<br />   the BRK instruction is always skipped.<br /><br /> - The CSL and CSH instructions change the CPU's clock speed. CSL selects<br />   low speed mode which is 1.78 MHz, CSH selects high speed mode which is<br />   7.16 MHz. On power-up the CPU is in low speed mode.<br /><br />   CSH and CSL take 3 cycles each, but that was tested with the CPU already<br />   set to the respective clock speed. It currently isn't known if either<br />   instruction takes more or less time when switching between different<br />   speeds.<br /><br /> - On power-up, the timer count is set to zero and the IRQ disable mask is<br />   set to zero.<br /><br /> 6502/65C02 bugs and features compared against the HuC6280:<br /><br /> - On power-up, A, X, Y, and S hold random values. P always has T and D<br />   cleared, I and B set, and N, Z, V, C are random.<br /><br /> - A branch instruction that crosses a 256-byte or 8192-byte boundary does<br />   not take any additional cycles.<br /><br /> - An indirect JMP instruction with the low byte of the address set to $FF<br />   will correctly read the high byte at the next address, instead of wrapping<br />   to address 0 like the 6502 does. (so jmp [$FEFF] reads the MSB from<br />   address $FF00, not $FE00)<br /><br /> - Illegal opcodes are treated as a NOP, and take 2 cycles each.<br />   They do not change the state of the A, X, Y, S, or P registers, with the<br />   exception that the T flag will be cleared if set prior to executing an<br />   illegal opcode (check the section on the T flag for more information).<br /><br />   I tested the following opcodes:<br /><br />   E2, 63, 33, 0B, 2B, 4B, 6B, 8B, AB, CB, EB, 1B, 3B, 5B, 7B, 9B,<br />   BB, DB, FB, 5C, DC, FC<br /><br /> - Read-modify-write instructions read the effective address once, then<br />   write the modified value. There are no dummy writes (like the 6502) or<br />   reads. (like the 65C02)<br /><br /> - The decimal mode versions of ADC and SBC do not change the state of the<br />   overflow flag.<br /><br /> Flag calculation<br /><br /> I haven't tested all of the instructions, just those that I wasn't sure<br /> about.<br /><br /> Logical Shift Right (LSR)<br /><br /> N = 0<br /> C = Bit 0 of operand<br /> Z = Set if result is zero<br /><br /> Pull X, Pull Y (PHX, PHY)<br /><br /> N = Bit 7 of pulled byte<br /> Z = Set if pulled byte is zero<br /><br /> Rotate Left (ROL)<br /><br /> C = Bit 7 of operand<br /> N = Bit 6 of operand<br /> Z = Set if result is zero<br /><br /> Rotate right (ROR)<br /><br /> N = Set if carry is set<br /> C = Bit 1 of operand<br /> Z = Set if result is zero<br /><br /> Test and Set Bits (TSB)<br /> Test and Reset Bits (TRB)<br /><br /> N = Bit 7 of result<br /> V = Bit 6 of result<br /> Z = If result is zero<br /><br /> Test (TST)<br /><br /> N = Bit 7 of operand<br /> V = Bit 6 of operand<br /> Z = Set if if operand &amp; immediate byte is equal to zero<br /><br /> Bit (BIT)<br /><br /> N = Bit 7 of operand<br /> V = Bit 6 of operand<br /> Z = Set if if operand &amp; accumulator is equal to zero<br /><br /> For the immediate form of this instruction, the flags are still calculated<br /> in the same way. So 'BIT #$C0' would set N and V, for example.<br /><br /> ----------------------------------------------------------------------------<br /> 2.1) Interrupts<br /> ----------------------------------------------------------------------------<br /><br /> The HuC6280 has several interrupt sources:<br /><br /> NMI   - Not used. It isn't connected to anything internally nor is it<br />         available on any connector.<br /><br /> IRQ2  - Available on the HuCard and backplane connectors. It's used by the<br />         CD-ROM's ADPCM hardware, and the BRK instruction also uses the IRQ2<br />         vector.<br /><br /> IRQ1  - Connected to the VDC.<br /><br /> Timer - Generated by the HuC6280's internal timer.<br />         The patents mention an external input used to test timer interrupts,<br />         but I believe this isn't used in the TurboGrafx-16.<br /><br /> Interrupts can be disabled through the CPU, the I flag of the P register<br /> disabled interrupts (except NMI, BRK) when set. In addition, there are<br /> four registers, two of which are usable, that control interrupts:<br /><br /> $1400 : Writes do nothing, reads return the I/O buffer contents.<br /><br /> $1401 : Writes do nothing, reads return the I/O buffer contents.<br /><br /> $1402 : Bits 2-0 are interrupt enable/disable bits, which can be read as<br />         well as written.<br /><br />         bit 2 - 1= Disable timer interrupt, 0= Enable timer interrupt<br />         bit 1 - 1= Disable IRQ1 interrupt, 0= Enable IRQ1 interrupt<br />         bit 0 - 1= Disable IRQ2 interrupt, 0= Enable IRQ2 interrupt<br /><br />         Bits 7-3 return the I/O buffer contents.<br /><br /> $1403 : Writing any value acknowledges the timer interrupt.<br />         Reads return the interrupt state in bits 2-0:<br /><br />         bit 2 - 1= Timer interrupt pending, 0= No timer interrupt<br />         bit 1 - 1= IRQ1 interrupt pending, 0= No IRQ1 interrupt<br />         bit 0 - 1= IRQ2 interrupt pending, 0= No IRQ2 interrupt<br /><br />         Bits 7-3 return the I/O buffer contents.<br /><br /> The enable/disable register does not actually stop the interrupt from<br /> occuring; for example if the VDC asserts the IRQ1 line, and bit 1 of $1402<br /> is set, then an interrupt isn't generated. But you can still read the state<br /> of the IRQ1 line through $1403, and bit 1 would be set in this case.<br /><br /> All interrupts need to be acknowledged. If not, the interrupt in question<br /> occurs after every instruction that is executed (unless the I flag or<br /> interrupt disable registers are used)<br /><br /> ----------------------------------------------------------------------------<br /> 2.2) Timer<br /> ----------------------------------------------------------------------------<br /><br /> The HuC6280 has a 7-bit timer that is decremented once every 1024 clock<br /> cycles. This is based on a 7.16 MHz clock, and is unrelated to the CPU<br /> speed determined by CSL/CSH.<br /><br /> The timer is controlled by two registers:<br /><br /> $0C00 : Timer value (bits 6-0)<br />         A value of $00 counts as 1, $7F counts as 128.<br />         Bit 7 is unused.<br /><br /> $0C01 : Timer enable (bit 0)<br />         Bits 7-1 are unused.<br /><br /> Data written to $0C00 is copied to a 7-bit latch. When the timer is<br /> enabled, a 7-bit counter is loaded with the contents of the latch. The<br /> counter is decremented once every 1024 clock cycles, and the timer<br /> interrupt request line is asserted when the counter underflows from zero<br /> to $7F. (not when the timer goes from one to zero) However, when this<br /> occurs the counter is reloaded, so after reading zero from the timer<br /> registers you will read the value that's been reloaded into the counter,<br /> not $7F.<br /><br /> The interrupt can then be acknowledged by writing any value to $1403. If<br /> this is not done an interrupt will occur after every instruction.<br /><br /> Reading $0C00 or $0C01 returns the current value in the counter, or if the<br /> timer is disabled, then the last value the counter had prior to it being<br /> disabled. If the timer is disabled and then enabled again, it is reloaded<br /> with the last value written to $0C00.<br /><br /> When the timer expires, it is reloaded with the last value written to $0C00.<br /> The timer begins to count down immediately, it does not wait for the<br /> interrupt to be acknowledged. (so the timer is reloaded and counts down<br /> within the timer interrupt routine)<br /><br /> Bit 7 of $0C00 and $0C01 return the contents of the I/O buffer.<br /><br /> ----------------------------------------------------------------------------<br /> 2.3) T flag<br /> ----------------------------------------------------------------------------<br /><br /> The HuC6280 assigns the T flag to bit 5 of the processor status register.<br /> It allows all forms of the ADC, AND, ORA and EOR instructions to be<br /> processed differently, while the other instructions execute normally.<br /><br /> When the T flag is set, the accumulator is replaced with a zero page memory<br /> location indexed by the X register. The operation defined by the<br /> instruction is performed using the memory location as one operand, and the<br /> effective address as the other. The result is stored in the memory<br /> location, leaving the accumulator undisturbed.<br /><br /> It seems that the T flag is cleared each time the CPU fetches an<br /> instruction. For example, both BRK and PHP (which save the status of P on<br /> the stack) always push it with the T flag cleared when prefixed by SET.<br /> T can be set by the SET instruction, or by pushing a byte with bit 5 set<br /> and pulling it into P via PLP (in which case the instruction after PLP<br /> will be affected as if SET came before it).<br /><br /> If you want to use this feature with ADC for processing BCD numbers,<br /> you must execute SED before SET, otherwise the T flag will be cleared.<br /><br /> Like PLP, RTI keeps the T flag set. If an interrupt occurs after a SET<br /> instruction which causes P to be pushed with T set, or if the stack<br /> is manipulated to have T set, the instruction following the return address<br /> used by RTI will be affected as if it was prefixed with SET.<br /><br /> The Mitsubishi 740 series of 65C02-derived CPUs also have a similar<br /> feature, with some differences. The T flag remains set until cleared with<br /> a CLT instruction or when P is modified. It also supports SBC, LDA and CMP<br /> as valid instructions to use with the T flag.<br /><br /> ---------------------------------------------------------------------------<br /> 2.4) Timing<br /> ----------------------------------------------------------------------------<br /><br /> The TurboGrafx-16 has a 21.47727 MHz master clock which is used to drive<br /> several components:<br /><br /> - Divided by three in high speed mode (7.16 MHz) or twelve in low speed<br />   mode (1.78 MHz) to provide the CPU clock. This is controlled by the<br />   CSL and CSH instructions.<br /><br /> - Divided by three to run the timer. (7.16 MHz)<br /><br /> - Divided by six for the PSG clock. (3.58 MHz)<br />   The PSG patents say the clock is 7.16 MHz, but all of the formulas for<br />   determining frequency multiply the result by two, effectively making<br />   the clock 3.58 MHz.<br /><br /> - The VCE divides the master clock by 2, 3, or 4, for 10.8 MHz, 7.16 MHz,<br />   and 5.36 MHz dot clocks. The VDC presumably runs at whatever speed the<br />   VCE does.<br /><br /> ---------------------------------------------------------------------------<br /> 3.) Memory map<br /> ----------------------------------------------------------------------------<br /><br /> The HuC6280 has a 21-bit address bus. All of the address decoding is<br /> handled internally by the CPU.<br /><br /> The address space is divided into 256 8K pages, and the following memory<br /> map refers to the page number only:<br /><br /> $00-$7F : HuCard ROM (1)<br /> $80-$F7 : Unused (always returns $FF) (2)<br /> $F8-$FB : Work RAM (pages $F9-$FB mirror page $F8)<br /> $FC-$FE : Unused (always returns $FF)<br /> $FF     : Hardware page<br />                                     <br /> 1. Depending on the configuration of the HuCard, ROMs smaller<br />    than 1MB may be mirrored within this range.<br /><br /> 2. See the CD-ROM section for more details.<br /><br /> Hardware page ($FF)<br /><br /> $0000-$03FF : VDC (registers mirrored every 4 bytes) (3)<br /> $0400-$07FF : VCE (registers mirrored every 8 bytes) (3) <br /> $0800-$0BFF : PSG (1)<br /> $0C00-$0FFF : Timer (registers mirrored every 2 bytes) (1)<br /> $1000-$13FF : I/O port (mirrored every byte) (1)<br /> $1400-$17FF : Interrupt control (registers mirrored every four bytes) (1)<br /> $1800-$1BFF : Always returns $FF (2)<br /> $1C00-$1FFF : Always returns $FF<br /><br /> 1. The last value read from or written to $0800-$17FF is saved in an<br />    internal 8-bit buffer. Reading $0800-$17FF will return this value,<br />    though readable locations will modify certain bits in the buffer.<br />    Here are some details:<br /><br />    $0800-$080F : All addresses return the buffer value in full.<br />    $0C00-$0C01 : Both locations return the buffer value in bit 7.<br />    $1000-$1000 : Always returns the I/O port value. (no bits are from<br />                  the buffer)<br />    $1400-$1403 : $1400/$1401 return the buffer value in full, $1402/$1403<br />                  return the buffer value in the upper five bits.<br /><br />    Some example code to illustrate how the buffer works:<br /><br />        stz     $0C01   ; Buffer = $00<br />        stz     $0C00   ; Buffer = $00<br />        lda     #$05<br />        sta     $1402   ; Buffer = $05<br />        lda     #$FF<br />        sta     $080F   ; Buffer = $FF<br />        lda     $1400   ; Read $FF, Buffer = $FF<br />        lda     $1402   ; Read $FD, Buffer = $FD<br />        sta     $1000   ; Buffer = $FD<br />        lda     $0C00   ; Read = $80, Buffer = $80<br /><br /> 2. See the CD-ROM section for more details.<br /><br /> 3. When accessing the VDC or VCE, an additional cycle is taken. This occurs<br />    for reads and writes (regardless of addressing mode) and instruction<br />    execution. (e.g. jsr $0002) I figured this had something to do with the<br />    VDC and VCE being external to the CPU, however the CD-ROM registers are<br />    not affected.<br /><br /> ----------------------------------------------------------------------------<br /> 4.) I/O port<br /> ----------------------------------------------------------------------------<br /><br /> Here is the layout of the I/O port bits:<br /><br /> D7 : CD-ROM base unit sense bit (1= Not attached, 0= attached)<br /> D6 : Country detection (1= PC-Engine, 0= TurboGrafx-16)<br /> D5 : Always returns '1'<br /> D4 : Always returns '1'<br /> D3 : Joypad port pin 5 (read)<br /> D2 : Joypad port pin 4 (read) <br /> D1 : Joypad port pin 3 (read) / pin 7 (write) <br /> D0 : Joypad port pin 2 (read) / pin 6 (write)<br /><br /> The TurboGrafx-16 uses a 9-pin connector for peripherals. I use the naming<br /> conventions from the Develo Box schematics:<br /><br /> Pin 1 - Vcc<br /> Pin 2 - D0     <br /> Pin 3 - D1     <br /> Pin 4 - D2     <br /> Pin 5 - D3     <br /> Pin 6 - SEL<br /> Pin 7 - CLR<br /> Pin 8 - Gnd<br /> Pin 9 - Gnd<br /><br /> 2-button controller details:<br /><br /> The 2-button controller has a four-way directional pad and four buttons:<br /> Select, Run, II and I. A multiplexer is used to determine which values<br /> (directions or buttons) are returned when D3-D0 are read. The SEL line of<br /> the I/O port selects directions when high, and buttons when low. The state<br /> of D3-D0 are inverted, so '0' means a switch is closed and '1' means a<br /> switch is open.<br /><br />        SEL = 0                SEL = 1<br /> D3 :   Run                    Left<br /> D2 :   Select                 Right<br /> D1 :   Button II              Down<br /> D0 :   Button I               Up<br /><br /> Games use a small delay after changing the SEL line, before the new data is<br /> read (a common sequence is PHA PLA NOP NOP). This ensures the multiplexer<br /> has had enough time to change it's state and return the right data.<br /><br /> When the CLR line is low, the joypad can be read normally. When CLR is<br /> high, input from the joypad is disabled and D3-D0 always return '0'.<br /><br /> Turbo Tap details:<br /><br /> The Turbo Tap is a 5-player adapter that plugs into the joypad port. It<br /> allows five controllers to be read in a serial fashion, one after the other.<br /> This is handled by an internal counter that is incremented each time there<br /> is a zero-to-one transition of the SEL line while CLR is zero.<br /><br /> The counter can be reset by holding SEL high and doing a zero-to-one<br /> transition on CLR. At this point, you can then strobe SEL five times<br /> to read each controller. Once all five controllers have been read,<br /> the Turbo Tap will return $00 in D3-D0 until the counter is reset again.<br /> Unconnected controllers always return $0F in D3-D0.<br /><br /> There is also a quirk in how the data is returned during the reset<br /> sequence. When $01 is written to $1000, D3-D0 are returned as zero,<br /> even though the CLR line isn't high. When $03 is written to $1000, D3-D0<br /> now return the direction pad data for controller #1, although now the CLR<br /> line is high and should disable joypad input.<br /><br /> After resetting the Turbo Tap, reading continues normally. You can set<br /> SEL high to read the directions, low to read the buttons, and the next high<br /> transition will increment the counter and return data from controller #2,<br /> and so on up to controller #5.<br /><br /> ----------------------------------------------------------------------------<br /> 5.) HuC6260 - Video Display Controller<br /> ----------------------------------------------------------------------------<br /><br /> The Video Display Controller (VDC) manages a background layer, sprites,<br /> and display generation. It has 20 internal 16-bit registers, and can<br /> address up to 128K of video RAM (VRAM).<br /><br /> The TurboGrafx-16 only has 64K VRAM available, so the latter half of<br /> the 128K area mirrors the former half. Sometimes reading mirrored VRAM<br /> returns corrupted data, and writes to the mirrored half of VRAM are always<br /> ignored (this includes VWR access or through VRAM to VRAM DMA).<br /><br /> The VDC is mapped to addresses $0000-0003 in the hardware page, and these<br /> locations are repeatedly mirrored throughout the $0000-03FF area.<br /><br /> VDC addresses:<br /><br /> $0000 : VDC register latch<br /> $0001 : Unused (writes do nothing, reads return $00)<br /> $0002 : VDC data (LSB)<br /> $0003 : VDC data (MSB)<br /><br /> The lower five bits of $0000 select which register will be accessed<br /> at $0002 and $0003. Only registers $00-$02, $05-$13 are valid; selecting<br /> registers $03-$04 or $14-1F and trying to access them has no effect.<br /><br /> Likewise, reading $0002 or $0003 when any other register but VRR is<br /> selected will return the contents of the read buffer; but reading $0003<br /> will not update MARR.<br /><br /> You can update registers in part by writing to the LSB or MSB; the new<br /> data written will immediately have an effect. Some registers have special<br /> properities when the MSB is written to. See the register reference section<br /> for more details.<br /><br /> Reading $0000 returns a set of status flags. The letters in parenthesis<br /> are the names of the flags from the Develo Book (I think):<br /><br /> D7 : Unused, always returns '0'<br /> D6 : Set when the VDC is waiting for a CPU access slot during<br />      the active display area. (BSY)<br /> D5 : Set when the vertical blank interrupt occurs. (VD)<br /> D4 : Set when the VRAM to VRAM DMA completion interrupt occurs. (DV)<br /> D3 : Set when the VRAM to SAT DMA completion interrupt occurs. (DS)<br /> D2 : Set when the raster compare interrupt occurs. (RR)<br /> D1 : Set when the sprite overflow occurance interrupt occurs. (OR)<br /> D0 : Set when the sprite #0 collision detection interrupt occurs. (CR)<br /><br /> Bit 6 is set when the VDC is waiting to read or write data requested by<br /> the CPU when it accesses VRR/VWR. For more information, see register $09<br /> in the register reference section.<br /><br /> Bits 5-0 are set when a condition occurs which would trigger an interrupt,<br /> as dictated by the corresponding interrupt enable bits in register $05<br /> and $0F. If the interrupt enable bits are not set, the matching status<br /> bits will not be set, even if the condition occurs. Bits 5-0 are cleared<br /> after the status port is read.<br /><br /> Bit 5 is set on the first line after the active display area ends, which<br /> signifies the vertical blanking period has started. This will occur even<br /> if the line after the active display area is off-screen, such as within<br /> the first 14 lines of the frame (top blanking) or the bottomost 7 (bottom<br /> blanking and vertical sync)<br /><br /> If the active display area uses more than 261 lines (assuming VSW and VDS<br /> are zero) the interrupt will always occur on line 261, which is the next<br /> to last line in the frame. So even if VDW was set to something unusual<br /> like $1FF, the interrupt would occur on line 261 within the frame.<br /><br /> Bit 4 is set when a VRAM to VRAM DMA transfer has finished.<br /><br /> Bit 3 is set when a VRAM to SAT transfer has finished, which seems to<br /> always happen four lines after the last line in the active display period.<br /> It's not known when the transfer actually starts. The exact line affected<br /> depends on the setting of VSW, VDS and VSW.<br /><br /> Bit 2 is set when the current scanline matches the value in register $06.<br /> See the register reference section for more details.<br /><br /> Bit 1 is set when there are more than 16 sprites on the current scanline.<br /> See the sprite section for more details.<br /><br /> Bit 0 is set when an opaque pixel in sprite #0 overlaps another opaque<br /> pixel from any other sprite. See the sprite section for more details.<br /><br /> All interrupts caused by the VDC must be acknowledged by reading the<br /> status flags once within the IRQ handler. If this is not done, the IRQ<br /> line is not lowered and the interrupt occurs as soon as the handler RTIs.<br /><br /> ----------------------------------------------------------------------------<br /> 5.1) Register reference<br /> ----------------------------------------------------------------------------<br /><br /> $00 - Memory Address Write Register (MAWR)<br /><br /> Bits 15-0 select a word offset in VRAM that will be used for VRAM writes.<br /><br /> $01 - Memory Address Read Register (MARR)<br /><br /> Bits 15-0 select a word offset in VRAM that will be used for VRAM reads.<br /> After you have written the MSB of this value, a word from VRAM is read<br /> and stored in the read buffer. On power-up, the contents of the read<br /> buffer are indeterminate. (usually $FFFF)<br /><br /> $02 - VRAM Read Register / VRAM Write Register (VRR/VWR)<br /><br /> When you write to the LSB of this register, the CPU data is stored in a<br /> temporary location called the write latch. When the MSB is written, the<br /> entire 16-bit value composed of the write latch and MSB are written into<br /> the VRAM address specified by MAWR. MAWR is then incremented by the<br /> increment factor selected by register $05.<br /><br /> Writing to the LSB multiple times only updates the lower half of the<br /> write latch and does not change MAWR or VRAM data. Writing to the MSB<br /> multiple times will write the previously latched LSB data along with the<br /> new MSB.<br /><br /> Reading the LSB will return the lower byte of the read buffer, and<br /> reading the MSB will return the upper byte of the read buffer. MARR is<br /> then incremented by the increment factor selected by register $05, and<br /> a word of VRAM is read from the new address into the read buffer.<br /><br /> $03 - Unused<br /><br /> This register doesn't seem to have any effect when written to.<br /><br /> $04 - Unused<br /><br /> This register doesn't seem to have any effect when written to.<br /><br /> $05 - Control Register (CR)<br /><br /> D16-D15 : Unused<br />     D12 : Increment width select (bit 1)<br />     D11 : Increment width select (bit 0)<br />     D10 : 1= DRAM refresh enable<br />      D9 : DISP terminal output mode (bit 1)<br />      D8 : DISP terminal output mode (bit 0)<br />      D7 : 1= Background enable<br />      D6 : 1= Sprite enable <br />      D5 : External sync (bit 1)<br />      D4 : External sync (bit 0)<br />      D3 : 1= Enable interrupt for vertical blanking<br />      D2 : 1= Enable interrupt for raster compare<br />      D1 : 1= Enable interrupt for sprite overflow<br />      D0 : 1= Enable interrupt for sprite #0 collision<br /><br /> Bits 7 and 6 enable and disable the background and sprite layers, and<br /> can be changed at any time. Games use these to clip sprites within a region<br /> of the display, or to give a letterboxed effect to the background layer.<br /><br /> Within a single frame, the overscan area outside of the active display<br /> period is filled with color #0 from sprite palette #0, and the active<br /> display area is filled with color #0 from background palette #0.<br /> So even if only the sprites were enabled, they would still be drawn over<br /> color #0 from background palette #0.<br /><br /> If bits 7 and 6 are cleared by the time the next frame starts (1), they are<br /> locked for the duration of the frame. Changes to them will not be taken<br /> into effect until the next frame. During this time, every line in the<br /> active display area is filled with color #0 of sprite palette #0.<br /><br /> The VDC patent refers to this as &quot;BURST&quot; mode, where the VDC does not<br /> read VRAM for background and sprite rendering. The CPU has unlimited<br /> access to VRAM, and in addition VRAM to VRAM DMA can be done during<br /> this time. Simply clearing both bits during the active display area does<br /> not cause BURST mode to become enabled, it only happens as soon as the<br /> active display period ends (which is incidentally when VRAM to SAT DMA<br /> occurs), and remains effective in the next frame only if both bits remain<br /> reset before the next frame starts.<br /><br /> 1. I'm not sure if they are locked when the next frame starts, or when the<br />    next active display period starts. I'm assuming the former for now.<br /><br /> Bits 3-0 will, when set, allow status flags to be set when a certain<br /> condition occurs. In addition the VDC will generate an IRQ1 interrupt,<br /> though interrupts can always be disabled through the CPUs IRQ control<br /> registers or the P register's I flag.<br /><br /> $06 - Raster Compare Register (RCR)<br /><br /> The value stored in this register is compared to the current scanline.<br /> If there is a match and the raster compare interrupt enable bit in register<br /> $05 is set, then bit 2 of the status flags is set and an interrupt occurs.<br /><br /> The range of the RCR is 263 lines, relative to the start of the active<br /> display period. (defined by VSW, VDS, and VCR) The VDC treats the first<br /> scanline of the active display period as $0040, so the valid ranges for<br /> the RCR register are $0040 to $0146.<br /><br /> For example, assume VSW=$02, VDS=$17. This positions the first line of<br /> the active display period at line 25 of the frame. An RCR value of $0040<br /> (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an<br /> interrupt at line 24 of the next frame.<br /><br /> Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never<br /> result in a successful line compare.<br /><br /> $09 - Memory Width Register (MWR)<br /><br /> D15-D8 : Unused<br />     D7 : CG mode<br />     D6 : Virtual screen height<br />     D5 : Virtual screen width (bit 1)<br />     D4 : Virtual screen width (bit 0)<br />     D3 : Sprite dot period (bit 1)<br />     D2 : Sprite dot period (bit 0)<br />     D1 : VRAM dot width (bit 1)<br />     D0 : VRAM dot width (bit 0)<br /><br /> The VDC was designed to work with slower video memory. The TurboGrafx-16<br /> happens to use the fastest kind available, but you can still set up the VDC<br /> to handle VRAM as if it was slower.<br /><br /> During the active display period of a scanline, the VDC can do one 16-bit<br /> access to VRAM on each cycle of the dot clock. Bits 1-0 of MWR tell the VDC<br /> how to divide this amongst several sources:<br /><br /> 1. CPU (reading or writing a word via register $02)<br /> 2. Background character pattern generator data (one read is for bitplanes<br />    0 and 1, another is for bitplanes 2 and 3, either one or two are needed<br />    per character)<br /> 3. BAT data (character name and palette, one fetch needed per character)<br /><br /> Bit   Dot   Dot cycles within an 8-dot unit<br /> 1 0  Width   0   1   2   3   4   5   6   7<br /> -------------------------------------------<br /> 0 0    1    CPU BAT CPU ??? CPU CG0 CPU CG1<br /> 0 1    2    --BAT-- --CPU-- --CG0-- --CG1--<br /> 1 0    2    --BAT-- --CPU-- --CG0-- --CG0--<br /> 1 1    4    ------BAT------ ----CG0/CG1----<br /><br /> CPU - A read or write to register $02<br /> BAT - The palette block and character name from the BAT<br /> ??? - Unknown, possibly an unused 'dummy' access<br /> CG0 - Bitplanes 0, 1 from the character generator<br /> CG1 - Bitplanes 2, 3 from the character generator<br /><br /> The default mode all games use is 0, as far as I can tell, modes 1, 2 are<br /> identical, and mode 3 enables the CG mode bit as described later.<br /> <br /> Bits 5-4 select the width of the virtual screen:<br /><br /> 00 - 32 characters<br /> 01 - 64 characters<br /> 10 - 128 characters<br /> 11 - 128 characters<br /><br /> Bit 6 selects the height of the virtual screen:<br /><br /> 0 - 32 rows<br /> 1 - 64 rows<br /><br /> There are no limits on the size of the BAT, at it's largest setting of<br /> 128x64 characters, the BAT is 16K.<br /><br /> Bit 7 selects which character generator bitplanes are read by the VDC<br /> when the VRAM dot width is 3.<br /><br /> 0 - Read bitplanes 0, 1, treat 2, 3 as zero<br /> 1 - Read bitplanes 2, 3, treat 0, 1 as zero<br /><br /> In either setting, background characters can only display four colors<br /> out of 16 at any given time.<br /><br /> ----------------------------------------------------------------------------<br /> 5.2) Background           <br /> ----------------------------------------------------------------------------<br /><br /> The background generated by the VDC is a tiled layer composed of 8x8<br /> characters. The background can be scrolled horizontally and vertically, and<br /> it's size is definable in units of 32 characters in either direction,<br /> from 32x32 up to 128x64.<br /><br /> The pattern data used by the characters is stored in a planar format.<br /> Because the VDC always accesses VRAM in word units, the organization<br /> of bitplanes reflect this. It takes 32 bytes of VRAM to define one tile;<br /> the first eight words are bitplanes 0 and 1 for lines 0-7, and the next<br /> eight words are bitplanes 2 and 3 for lines 0-7.<br /><br /> The background itself is defined by the block attribute table (BAT), which<br /> starts at address zero in VRAM. Each word-wide entry in the BAT defines<br /> a single character, and has the following layout:<br /><br />    MSB          LSB<br />    ppppnnnnnnnnnnnn<br /><br />    p : Color palette (0-15)<br />    n : Character name (0-4095)<br /><br /> Notice that there are no provisions for tile flipping or priority control.<br /><br /> Because the TurboGrafx-16 only has 64K of VRAM, only patterns 0-2047 should<br /> be used. Patterns 2048-4096 are filled with 'garbage' data.<br /><br /> The color palette selects one of sixteen 16-color palettes for the<br /> character to use. The background layer always uses the first 256 colors<br /> in the 512-color VCE palette.<br /><br /> The BAT doesn't necessarily have to match the same size of the display.<br /> If the BAT is too small, (e.g. it's 32x32 and the display is 40x28), then<br /> the offset into the BAT wraps around and the graphics are repeated. In<br /> the same vein, you don't have to use up the entire BAT space if the display<br /> won't show all of it (e.g. it's 64x32 and the display is 32x16, you<br /> wouldn't need to define entries for rows 17-31).<br /><br /> For more information about scrolling, see registers $07 and $08 in<br /> the register reference section.<br /><br /> ----------------------------------------------------------------------------<br /> 5.3) Sprites              <br /> ----------------------------------------------------------------------------<br /><br /> The VDC can control 64 sprites up to 32x64 in size, composed of 16x16<br /> patterns.<br /><br /> Each sprite is defined by a four-word entry in the sprite attribute<br /> table, (SAT) a memory area internal to the VDC that can only be written to<br /> via VRAM to SAT DMA.<br /><br /> On power-up, the SAT is filled with garbage data and should either be<br /> initialized or sprites should be turned off. See the register reference<br /> section for more details about VRAM to SAT DMA.<br /><br /> Each SAT entry has the following format:<br /><br /> Word 0 : ------aaaaaaaaaa<br /> Word 1 : ------bbbbbbbbbb<br /> Word 2 : -----ccccccccccd<br /> Word 3 : e-ffg--hi---jjjj<br /><br /> a = Sprite Y position (0-1023)<br /> b = Sprite X position (0-1023)<br /> c = Pattern index (0-1023)<br /> d = CG mode bit (0= Read bitplanes 0/1, 1= Read bitplanes 2/3)<br /> e = Vertical flip flag <br /> f = Sprite height (CGY) (0=16 pixels, 1=32, 2/3=64)<br /> g = Horizontal flip flag<br /> h = Sprite width (CGX) (0=16 pixels, 1=32)<br /> i = Sprite priority flag (1= high priority, 0= low priority)<br /> j = Sprite palette (0-15)<br /><br /> Sprites are positioned in a virtual 1024x1024 space. The active display<br /> area starts at offset (32, 64), allowing sprites to be partially shown<br /> at the left and top edges, as well as giving sprites a place to be<br /> hidden at when their coordinates are set to (0, 0).<br /><br /> The pattern index selects one of 1024 patterns, however the TurboGrafx-16<br /> only has 64K of VRAM, so the first 512 should be used. Patterns 512-1023<br /> are filled with 'garbage' data.<br /><br /> Each sprite pattern takes 128 bytes, and is arranged in four groups of<br /> 16 words. Each word corresponds to one 16-pixel line, and each group<br /> corresponds to one bitplane. For example, words 0-15 define bitplane 0,<br /> words 16-31 define bitplane 1, etc.<br /><br /> The CG mode bit is only valid when the sprite dot width field of the MWR<br /> register is set to 2 or 3. When clear, bitplanes 0 and 1 are read, 2 and 3<br /> are treated as zero. When set, bitplanes 2 and 3 are read, 0 and 1 are<br /> treated as zero.<br /><br /> The vertical and horziontal flip flags flip an entire sprite (not just<br /> one 16x16 pattern).<br /><br /> The CGX and CGY fields define the size of a sprite. Sprites larger than<br /> 16x16 use neighboring patterns to make up the rest of the sprite. Depending<br /> on the size, the lower 3 bits of the pattern index are masked out. If CGX<br /> is set, bit 0 of the pattern index is forced to zero. If CGY is 1, bit 1 of<br /> the pattern index is forced to zero. If CGY is 2 or 3, bits 2 and 1 of the<br /> pattern index are forced to zero. For example, a 16x16 sprite can use any<br /> patterns, a 32x16 sprite can use every second pattern, and a 32x64 sprite<br /> can only use every eighth pattern.<br /><br /> The priority and palette fields are discussed later on.<br /><br /> Sprite attribute table parsing:<br /><br /> During the horizontal blanking period of each scanline, the VDC parses the<br /> SAT to collect information about what sprites will be displayed on the<br /> next line. It progresses through the SAT one sprite at a time, working from<br /> sprite #0 to #63. If a sprite is found that has the right Y coordinate<br /> and height to make it fall on the next line, the sprite is added to an<br /> internal 16-entry buffer. The VDC continues to parse the SAT until the<br /> following conditions occur:<br /><br /> - All 64 sprite entries have been examined.<br /> - All 16 buffer entries have been used.<br /> - The horizontal blanking period ends. (1)<br /> <br /> Sprites that are 32 pixels wide count as two sprites; in the event<br /> that such a sprite is found but there is only one buffer position left,<br /> then the left half of the sprite is added to the buffer, and the right half<br /> is not displayed.<br /><br /> If all 16 buffer entries are used but there are more sprites that fall on<br /> the line, an overflow condition occurs. If the interrupt enable bit of CR<br /> is set, the overflow bit in the status register is set and the VDC will<br /> generate an interrupt. Overflows can occur anywhere within a scanline in<br /> the active display period, even if the sprites are off-screen.<br /><br /> During the next scanline, the VDC compares a counter (incremented by<br /> the dot clock) to the X position of each buffered sprite. When the X<br /> position is within range, the sprite bitplane data is shifted out serially,<br /> forming a single four bit pixel. Only the first opaque pixel is shown,<br /> pixel data from subsequent sprites is ignored. This is what defines the<br /> priority when multiple sprites overlap each other; for example if sprites<br /> 0 through 3 were transparent, but 4 and 5 were not, only pixels from sprite<br /> 4 would be shown.<br /><br /> At this point, collisions between sprite #0 and any other sprite are<br /> checked. If the bitplane data from sprite #0 is an opaque pixel, and any<br /> other of the 16 buffered sprites also output an opaque pixel, a collision<br /> occurs. If the interrupt enable bit of CR is set, the collision bit in the<br /> status register is set and the VDC will generate an interrupt. Collisions do<br /> not occur outside of the active display period.<br /> <br /><br /> The sprite pixel is then compared to the current background layer pixel<br /> (or backdrop color) at the same location. If the sprite's priority flag<br /> is set, then the sprite pixel overwrites the background pixel. If the<br /> priority flag is clear, then the sprite pixel is only shown if the<br /> background pixel is transparent.<br /><br /> Note that the background priority flag has no effect inter-sprite priority.<br /> For example, if sprite #2 has it's priority flag cleared, it would appear<br /> under a section of the background. If sprite #3 partially overlapped sprite<br /> #2 and had it's priority flag set, it's pixels which shared the same<br /> location as opaque pixels in sprite #2 would not be shown. (since sprite #2<br /> comes first in the 16-entry buffer)<br /><br /> This technique is used in many games (Y's, Neutopia, Dungeon Explorer) to<br /> force sections of the background to appear in front of sprites that have<br /> their priority flag set but are of a lower sprite priority.<br /><br /> Notes:<br /><br /> 1. This happens when the width of the display is modified. If the display<br />    is made smaller than 32 characters, two sprites at a time starting from<br />    sprite 64 are dropped. This is why the Image 15-in-1 Collection does<br />    not use sprites, it uses very small resolutions which reduce how many<br />    sprites are available. (either the programmer didn't realize this was<br />    happening, or simply chose to not use sprites) In the same vein, making<br />    the display too wide cuts out multiple ranges of sprites at a time,<br />    though the exact relation of which sprites are dropped based on the<br />    display size is unclear.<br /><br /> ----------------------------------------------------------------------------<br /> 5.4.) DMA<br /> ----------------------------------------------------------------------------<br /><br /> The VDC has two kinds of DMA: VRAM to VRAM copy, and VRAM to SAT transfer.<br /><br /> - The contents of MAWR, MARR, the read buffer, and the write latch, are<br />   not changed by doing VRAM to VRAM DMA.<br /><br /> - The IW bits in CR do not change the value added to the source or<br />   destination address during VRAM to VRAM DMA, this value is always one.<br /><br /> - LENR specifies how many words to transfer, 0=1 byte, $FFFF=64K.<br />   Writing to the MSB triggers the transfer.<br /><br /> - During VRAM to VRAM DMA, SOUR, LENR, and DESR are modified (they act as<br />   counters which are incremented and/or decremented in the course of a<br />   transfer) At the end of the transfer, the registers retain their new<br />   states instead the original values written. LENR is set to $FFFF, not<br />   zero, when a transfer completes.<br /><br /> - VRAM to VRAM DMA can only occur outside of the active display period.<br />   It seems to me that if it is still running when the active display<br />   period starts, DMA is halted (not aborted), and resumes when the active<br />   display period ends.<br /><br /> - Both VRAM to VRAM DMA and VRAM to SAT DMA can run at the same time.<br />   I don't know which one has priority if they both access the same range<br />   of addresses, however.<br /><br /> - The VRAM to SAT DMA transfer end interrupt occurs four scanlines after<br />   the end of the active display period. (e.g. if the last line of the<br />   active display is $DF, it happens happens at $E3)<br /><br /> ----------------------------------------------------------------------------<br /> 6.) HuC6270 - Video Color Encoder<br /> ----------------------------------------------------------------------------<br /><br /> The VCE manages a palette used for the background and sprite layers.<br /> The palette is composed of 512 9-bit entries, each entry being divided<br /> into three groups of three bits for each of the red, green, and blue color<br /> components, giving a total range of 512 possible colors.<br /><br /> The first 256 colors are used for the background layer, and the remaining<br /> 256 are used for sprites. Within these two groups, the palette can be<br /> divided further into 16 groups of 16-color palettes; each palette is<br /> selected by a 4-bit field in the BAT or SAT.<br /><br /> A pixel in a background character or sprite pattern with a value of zero<br /> is treated as transparent. For sprites, this means the underlying background<br /> data or backdrop color is shown. For background characters, this means<br /> the underlying backdrop color is shown.<br /><br /> The backdrop color is displayed in the active display area if the sprites,<br /> background, or both are enabled. This color is picked from color #0 from<br /> background palette #0.<br /><br /> The overscan color is displayed outside of the active display area, and<br /> only inside the active display area when both the background and sprites<br /> are turned off. This color is picked from color #0 in sprite palette #0.<br /> See the register reference section for more details.<br /><br /> Color #0 of the remaining 15 palettes in the background and sprite sections<br /> cannot be displayed.<br /><br /> The VCE is mapped to $0400-0407, and these locations are repeatedly<br /> mirrored throughout the $0400-07FF range in the hardware page.<br /><br /> $0400 - VCE control<br /> (Write only, reads return $FF)<br /><br />    D7 : 1= Black and white video, 0= Color video<br />    D6 : No effect<br />    D5 : No effect<br />    D4 : No effect<br />    D3 : No effect<br />    D2 : 1= Blur edges of graphics. (some games use this bit)<br />    D1 : 1= 10 MHz dot clock. <br />    D0 : 1= 7 MHz dot clock, 0= 5 MHz dot clock<br /><br /> Bits 1-0 select the dot clock. This determines how many pixels are displayed<br /> on each horizontal line, but does not affect how many lines are shown per<br /> frame. If bit 0 is set while the 10 MHz dot clock is used, the color<br /> artifacting around the edges of characters is more prominent, while having<br /> the bit cleared minimizes artifacting.<br /><br /> Bit 2 seems to blur the edges of the sprites and background characters.<br /> This reduces artifacting between pixels, especially in the higher<br /> resolutions.<br /><br /> In my opinion, it almost seems that when bit 2 is cleared, every other<br /> line is offset horizontally by half a pixel. When bit 2 is set,<br /> this is applied to either odd or even lines on odd or even frames.<br /><br /> This is especially noticable with vertically scrolling graphics; if a sprite<br /> is moved vertically at the rate of one line per frame, the 'interlacing'<br /> effect described above is lost, and the edges appear jagged. When the<br /> sprite is stationary, the edges look smooth.<br /><br /> For what it's worth, the PC-FX patents describe this exact same feature;<br /> though it's only usable for an interlaced display and is controlled through<br /> a different register of the VCE (which is loosely based on the original<br /> one used in the TurboGrafx-16).<br /><br /> $0401 - Not used<br /> (Reads return $FF, writes do nothing)<br /><br /> $0402 - Color table address (LSB)<br /> $0403 - Color table address (MSB)<br /> (Both are write-only, reads return $FF)<br /><br /> These two registers form a 16-bit value, of which the lower 9 bits are<br /> used as an index into the color table for subsequent reads and writes<br /> by the data register. The remaining upper 7 bits are ignored.<br /><br /> You can update either the LSB or MSB independently and still perform<br /> color data reads and writes; the address does not have to be specified<br /> in full beforehand.<br /><br /> $0404 - Color table data (LSB)<br /> $0405 - Color table data (MSB)<br /><br /> These two registers form a 16-bit value, of which the lower 9 bits<br /> contain color data:<br /><br />    MSB          LSB<br />    -------GGGRRRBBB<br /><br />    G = Green component<br />    R = Red component<br />    B = Blue component<br /><br /> Reading $0404 returns the lower byte of the color data.  Reading $0405<br /> returns the upper byte with bits 7-1 set to '1'. When the upper byte is<br /> read, the color table address is advanced by one and will wrap when the<br /> address is at $01FF.<br /><br /> Writing to $0404 sends a byte of data to the LSB of the current entry in<br /> the color table. Writing to $0405 sends a byte of data to the MSB of the<br /> current entry in the color table, and in addition, the address is advanced<br /> by one and will wrap when the address is at $01FF.<br /><br /> Writing to $0405 multiple times will only update the MSB of each color<br /> table entry, the LSB will remain undisturbed. You can also freely change<br /> either half of the address (through $0402/$0403) between writes to the<br /> color table data registers.<br /><br /> $0406 - Not used <br /> (Reads return $FF, writes do nothing)<br /><br /> $0407 - Not used<br /> (Reads return $FF, writes do nothing)<br /><br /> Palette flicker<br /><br /> The VCE color table can only be accessed by either the CPU or the VCE at<br /> any given time, with CPU accesses taking priority. When the CPU reads<br /> or writes VCE addresses $0404 or $0405 during the active display period,<br /> the current pixel being displayed can't look it's color up through the<br /> color table as the CPU is currently using the table itself.<br /><br /> Unlike other video hardware (e.g. Sega systems) where the pixel's color<br /> will be replaced by the data read or written by the CPU, the VCE will<br /> show the same color for the last pixel it displayed. While this still<br /> causes distortion of the graphics, it is mostly masked when the current<br /> image being displayed is a horizontal strip of the same color.<br /><br /> Note that this also occurs at the edges of the display, when the monitor<br /> scans the border (overscan) area to the left and right of the active<br /> display, reading or writing the color table will cause the right border<br /> color to overlap into the active display, and likewise the active display<br /> color can overlap into the left border.<br /><br /> One game that allows you to see this effect is Coryoon, it fades the display<br /> in and out without waiting for the vertical blank period. You can easily<br /> see on the screen where a read or write has occured as the single pixels<br /> are stretched out into short horizontal lines due to the VCE displaying<br /> the same pixel color while the CPU is busy accessing the color table.<br /><br /> ----------------------------------------------------------------------------<br /> 7.) Display details<br /> ----------------------------------------------------------------------------<br /><br /> All aspects of the display are controlled by the VDC (which has several<br /> registers that define where graphics are shown within the display), and<br /> the VCE (which generates a dot clock, in turn defining the number of pixels<br /> displayable). I will start with discussing the vertical control fields<br /> in VDC registers $0C, $0D, and $0E.<br /><br /> The TurboGrafx-16 generates a NTSC display that is composed of 60 frames<br /> shown per second, with each frame divided into 263 scanlines. These<br /> scanlines are grouped as follows:<br /><br />  14 lines for the top blanking area (shown as light black).<br /> 242 lines for the active display area (graphics and/or overscan color).<br />   4 lines for the bottom blanking area (shown as light black).<br />   3 lines for the sync area (shown as pure black).<br /><br /> This layout is fixed, and cannot be changed by the vertical control<br /> registers. They only define where the graphics data is displayed within<br /> a single frame. If the active display area is positioned in a way that it<br /> occupies the lines that are used for blanking or sync, those lines will<br /> not be shown. The start of a frame is the first line after the vertical<br /> retrace period, which is not necessarily the first line you can see on a<br /> monitor.<br /><br /> For the sake of discussion, assume the VDC has a two counters that are<br /> reset at the start of a frame and incremented on each scanline. One is<br /> used to track the position within each frame, and the VDC checks this<br /> counter when generating the active display, top and bottom blanking areas,<br /> and sync area. I'll call this the frame counter. The other counter is used<br /> for tracking the graphics area within a frame, and can be reset multiple<br /> times. I'll call this the display counter.<br /><br /> The display counter is compared to an offset made by the sum of VDS and<br /> VSW. When they match, graphics data are displayed, or else the overscan<br /> color is shown. Because there are 14 lines at the beginning of a frame<br /> which make up the top border, the offset created by VDS and VSW must be<br /> at least 14 lines. In addition, most monitors cut off the edges of the<br /> display, so the offset may need to be larger.<br /><br /> For example, the standard 256x224 resolution used by most games has<br /> VDS=$17 and VSW=$02, giving an offset of 25 lines. This clears the top<br /> blanking area and gives 11 lines of overscan color before the 224 lines of<br /> graphics data are shown.<br /><br /> After the display counter matches the offset created with VDS and VSW,<br /> graphics are displayed until the counter now matches the previous offset<br /> plus VDW. At this point, graphics are turned off and the overscan color is<br /> shown for the remainder of the 242 lines that make up the active display<br /> area. If VDW and/or the VSW+VDS offset are large enough that the graphics<br /> are shown past line 242, then no overscan color is displayed and these<br /> graphics are hidden by the bottom border and sync areas.<br /><br /> Assuming this isn't the case, and there are some lines left in the remainder<br /> of the active display area (out of the available 242), the VDC will show<br /> 3 blanked lines filled with the overscan color. It will continue to do<br /> this for as many lines as are specified in the VCR register.<br /><br /> After this point, the display counter resets. It will begin to show the<br /> overscan and active display area again, following the same rules as above<br /> except for everything is positioned relative to the last line of the frame<br /> as specified by VDS+VSW+VDS+VCR+3.<br /><br /> VCR is normally used to prevent this situation, it can be set to the number<br /> of lines remaining in the frame and thereby prevent the active display area<br /> from being displayed twice.<br /><br /> Now for an example:<br /><br /> VDW = $07F, VCR = $00, VDS = $0E, VSW = $00<br /><br /> This positions the active display area at line 14 onwards, clearing the<br /> top blanking area. The height of the active display area is 128 lines.<br /> VCR is not used.<br /><br /> The display will show 14 black lines, 128 lines from the active display<br /> area, and then 3 lines of overscan color. Now the display counter resets,<br /> so 14 lines of the overscan color are displayed, followed by 97 lines<br /> of the active display area. The frame counter has reached the bottom of<br /> the frame, so you see 4 lines of the bottom border and finally 3 lines<br /> of the sync area, for a total of 263 lines.<br /><br /> Now for the horizontal aspects of the display:<br /><br /> The number of characters per scanline is determined by the dot clock used,<br /> and the horizontal parameters define what characters show graphics data and<br /> which ones show the overscan color. You can't divide the dot clock further<br /> by adjusting the horizontal parameters; for example, the 5 MHz dot clock<br /> will always show roughly 342 dots per line, so a small resolution like 128<br /> characters would have a large border on the left and right sides. Some of<br /> these dots are off-screen, since they are used for the horizontal blanking,<br /> retrace, and color burst areas.<br /><br /> VDC registers $0A and $0B can be modified at any time. Registers $0C, $0D,<br /> and $0E can only be modified outside of the active display period. So it's<br /> possible to change the horizontal resolution to any width at any line.<br />  <br /> ----------------------------------------------------------------------------<br /> 9.) Display parameter settings<br /> ----------------------------------------------------------------------------<br /><br /> These settings were created using the Display Editor program, and are<br /> included as a reference for emulator authors to see the largest possible<br /> displays, as well as developers to use in their programs.<br /><br /> Key to following settings:<br /><br /> Overscan - Part of the display may be off-screen on some monitors.<br /> Max      - This is the largest viewable area possible. (I used a video<br />            capture card to get around the limitations of a regular monitor)<br /> CLK      - Bits 1-0 of VCE register $0400<br /><br /> Horizontal settings:<br /><br /> Width  HDS HSW HDE HDW CLK<br /> 240    03  02  04  1D  00 <br /> 256    02  02  04  1F  00 (overscan)<br /> 288    00  02  04  23  00 (overscan, max)<br /> 320    05  02  04  27  01<br /> 336    04  02  04  29  01 (overscan)<br /> 376    02  02  04  2E  01 (overscan, max)<br /> 480    0C  02  04  3C  02<br /> 512    0B  02  04  3F  02 (overscan)<br /> 536    07  02  04  46  02 (overscan, max)<br /><br /> Vertical settings:<br /><br /> Height VDS VSW VDW VDW VCR<br /> 192    25  02  00  BF  0C<br /> 224    17  02  00  DF  0C<br /> 240    0F  02  00  EF  0C (overscan, max)<br /><br /> ----------------------------------------------------------------------------<br /> 10.) Programmable Sound Generator<br /> ----------------------------------------------------------------------------<br /> <br /> - The PSG channel frequency is 12 bits, $001 is the highest frequency,<br />   $FFF is the next to lowest frequency, and $000 is the lowest frequency.<br /><br /> - When writing waveform data to a channel, the index is reset when the DDA<br />   bit goes from one to zero, regardless of the other bits in $0804.<br /><br /> - Data can only be written to the waveform buffer when the channel enable<br />   and DDA bits are reset. Otherwise, the data written is ignored and the<br />   current index into the waveform is not changed.<br /> <br /></div><br />PS: i deleted the CDROM part bacause the post was too long .</div>

					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=6952"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row2">

			<td align="center" valign="middle">
				<a name="p187529"></a>
				<b class="postauthor">ccovell</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187529">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187529#p187529"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Jan 23, 2017 7:18 am&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Sun Mar 19, 2006 9:44 pm<br /><b>Posts:</b> 957<br /><b>Location:</b> Japan
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody">Charles Macdonald's doc(s) (above) are definitely the most detailed.<br /><br />I don't know if you'd find them useful, byuu, but my demos/programs can test a few things on the PCE hardware: <!-- m --><a class="postlink" href="http://www.chrismcovell.com/creations.html">http://www.chrismcovell.com/creations.html</a><!-- m --><br /><br />No CPU tests, sorry.</div>

					
						<div class="postbody"><br />_________________<br /><!-- m --><a class="postlink" href="http://www.chrismcovell.com">http://www.chrismcovell.com</a><!-- m --></div>
					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=355"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row1">

			<td align="center" valign="middle">
				<a name="p187536"></a>
				<b class="postauthor">tomaitheous</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187536">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187536#p187536"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Jan 23, 2017 10:27 am&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Thu Aug 28, 2008 1:17 am<br /><b>Posts:</b> 591
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody"><div class="quotetitle">byuu wrote:</div><div class="quotecontent">&gt; It's a matter of perspective. The raising edge of the hsync is arguably the beginning of the next line, in which the VDC generates the interrupt (if line match).<br /><br />After talking with Ryphecha about it, she advised that the interrupt actually triggers near the very end of the previous scanline you asked for. Which would indeed be the Hblank area, and give games times to do things to affect the line they were targeting.<br /></div><br /><br /> I did tests with Ryphecha, Exophase, and Charles over the years, as well as on my own. I've lost my notes over the years, so things from memory tend to be iffy (except the things/regs I consistently use). I do know that VDC will trigger an interrupt when forced to HDS. I believe there's a delay from the pixel bus to video out on the VCE side (8 pixels or more.. I don't remember). And I <em>know</em> there's a delay on the VDC side (at least 8 pixels). So if you're using composite output as a timing marker to something else, say for measuring when h-int is asserted by the VDC, it's going to be off. If the VDC did assert h-int before HSW (on the previous) line, and I do know that BYR is read during HDS, then it might be possible to test for this *if* the interrupt is generated from the transition of HDW-&gt;HDE. But I really don't think that's the case. If anything, it's HDE-&gt;HSW or HSW-&gt;HDS (both this case scenarios kinda fit the case for when VCE asserts hsync to VDC outside the HSW window). Because neither of those last two scenarios would give issues with games, while the first case potentially could.<br /><br /> I discovered this delay because I found out how to use VDC regs #3 and #4 (marked as reserved). They seem to be some internal test state regs. To access them, you have to set bits in the VRAM <em>READ</em> address reg. I forget which bits correlates to which functions (it's been too long). Reading or writing to reserved regs enables and disables. And earlier internal documentation actually gives them names, but the official doc just says they're reserved. I don't remember their names.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">&gt; Which VDC reg? <br /><br />BYR. And I just found there's a THIRD level of latching to it. The cached BYR value is latched at the start of the scanline. Without that, you'll get momentary flicker when games write the register mid-scanline. Which they do a lot because there's only one background and no windows.</div><br /><br /> That's what I mentioned; every VDC register is buffered. <em>Only</em> VWR/VRR have a latch mechanism though. The other regs can be written for the LSB or MSB singularly (for fast sine wave effects, I only change the LSB of BXR. And fast RCR updates to the LSB only). All regs, from what I remember testing, are updated on the next scan line (or at the start of the scanline when exiting HSW), except the ones defining the size of the vertical window. So that means scroll regs (BXR, BYR), color bits, horizontal window settings, etc -&gt; update on a scanline basis and regs like VPR, VDW, VCR update on vblank (start of new display). <br /><br /> I don't think it has any correlation to a single BG layer and absence of windows. That makes no sense. It's a buffered system specifically to avoid race conditions (i.e. the NES or gameboy BY reg) for mid screen changes.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">&gt; I have no idea how accurate you plan to go with this, but the VDC processes BG and sprite line setup at different 8pixel dot clock segments during hblank.<br /><br />I am limited by the available information. And the available information is unbelievably awful and outdated from 2007 and earlier =(<br /><br />But I want to be as accurate as possible. I just emulated the display start, display length regs. But not yet the display end, sync width regs. Nor the &quot;fun&quot; that happens with out of bounds values (you can apparently make the VDC start drawing the NEXT scanline on the current scanline if your values are too aggressive.)</div><br /><br /> Chris Covell's screen resolution rom is a good starting point. <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Even with just that, I'm still having troubles. HDS (horizontal display start) seems to act differently depending on the $0400.d0-d1 clock frequency setting (5mhz, 7mhz, 10mhz). Unless I manually fudge the start offset by another ~24 clock cycles for 7mhz mode only, the status bar in Order of the Griffon isn't centered.<br /></div><br /><br /> Might have something to do with how HSW works? HSW (it's defined in HSR reg) is nothing more than wait loop window. You define it  in lengths of 8 VDC pixel units, but when the VCE asserts Hsync, it immediately transitions to HDS. I.e. It ill never be the full length of the wait loop period unless the VDC times out (no external hsync), then it transitions to HDS as well. <br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">There's no documentation anywhere on this.</div><br /><!-- m --><a class="postlink" href="http://www.pcedev.net/docs/huc62_manuals.zip">http://www.pcedev.net/docs/huc62_manuals.zip</a><!-- m --><br />It's not much, but at least it provides definitions of regs (for clarity in discussion).</div>

					
						<div class="postbody"><br />_________________<br />__________________________<br /><!-- m --><a class="postlink" href="http://pcedev.wordpress.com">http://pcedev.wordpress.com</a><!-- m --></div>
					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=3645"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row2">

			<td align="center" valign="middle">
				<a name="p187556"></a>
				<b class="postauthor">ccovell</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187556">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187556#p187556"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Jan 23, 2017 5:44 pm&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Sun Mar 19, 2006 9:44 pm<br /><b>Posts:</b> 957<br /><b>Location:</b> Japan
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody"><div class="quotetitle">byuu wrote:</div><div class="quotecontent">HDS (horizontal display start) seems to act differently depending on the $0400.d0-d1 clock frequency setting (5mhz, 7mhz, 10mhz). Unless I manually fudge the start offset by another ~24 clock cycles for 7mhz mode only, the status bar in Order of the Griffon isn't centered.</div><br />I don't know what it does at a low level, but yes, the start of the active screen (BG, Sprites) cannot be aligned exactly between the 3 resolutions.  They are always off by a few &quot;millimetres&quot;.  <br /><br />What most games set their screen to in 256-pixel mode (5mhz) is offset from the NES as well.  (Lots of variations... may be a good thing from the PCE coder's perspective. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /> )</div>

					
						<div class="postbody"><br />_________________<br /><!-- m --><a class="postlink" href="http://www.chrismcovell.com">http://www.chrismcovell.com</a><!-- m --></div>
					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=355"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row1">

			<td align="center" valign="middle">
				<a name="p187644"></a>
				<b class="postauthor">byuu</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187644">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187644#p187644"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Tue Jan 24, 2017 11:00 am&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Mon Mar 27, 2006 5:23 pm<br /><b>Posts:</b> 1364
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody">&gt; Chris Covell's screen resolution rom is a good starting point.<br /><br />Yes, that was very helpful! Thanks for those, Chris!<br /><br />The problem is that I don't have a real PC Engine to run it on and see how the screen actually reacts to changing various values. Especially going way out of bounds.<br /><br />I recently emulated the SuperGrafx (mostly), and as such the VCE's role kind of crystallized a bit for me. So now I'm splitting the VDC and VCE functionality, where the VDC has no idea about the actual CRT beam cannon, but instead just runs on &quot;start of frame/scanline&quot; signals from the VCE to it, off the clock rate set by the VCE. It does nothing but set a 9-bit data bus that the VCE (or VPC) uses.<br /><br />It ... mostly works. Some nasty regressions, some nasty inconsistent pixel widths, but ... progress.<br /><br />&gt; Lots of variations... may be a good thing from the PCE coder's perspective.<br /><br />I definitely noticed that effect ... doing things properly and showing the full horizontal resolution always produces nasty background color borders (like a lot of blue area in Neutopia, see below.)<br /><br /><img src="http://i.imgur.com/uhlzR7G.png" alt="Image" /></div>

					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=375"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row2">

			<td align="center" valign="middle">
				<a name="p187673"></a>
				<b class="postauthor">ccovell</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187673">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187673#p187673"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Tue Jan 24, 2017 5:12 pm&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Sun Mar 19, 2006 9:44 pm<br /><b>Posts:</b> 957<br /><b>Location:</b> Japan
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody">This is normal behaviour.  Here's a pic of Neutopia on my monitor (run through an XRGB-2)  You can see the coloured borders (which really come from Sprite colour 0, but are set to be the same as BG colour 0) on either side.  My old Panasonic TV even showed the full 242 lines (blue at the bottom too) which my XRGB cuts off.<br /><br />By the way, feel free to post a new thread (rather than in the Z80 one...).  The <a href="http://www.pcenginefx.com/forums/index.php" class="postlink">PCEngineFX forums</a> have lots of technical discussion like this, but they're not searchable (through Google, etc.) so NESDev's not a bad place to have more PCE dev discussion.</div>

					
						<br clear="all" /><br />

						<table class="tablebg" width="100%" cellspacing="1">
						<tr>
							<td class="row3"><b class="genmed">Attachments: </b></td>
						</tr>
						
							<tr>
								<td class="row2">
			<span class="gensmall"><b>File comment:</b> 256x242 screen on CRT</span><br />
		
			<a href="./download/file.php?id=7758&amp;mode=view"><img src="./download/file.php?id=7758&amp;t=1" alt="IMG_6696.jpg" /></a><br />
			<span class="gensmall">IMG_6696.jpg [ 153.86 KiB | Viewed 1305 times ]</span>
		

		<br />
	</td>
							</tr>
						
							<tr>
								<td class="row1">
			<span class="gensmall"><b>File comment:</b> Neutopia on CRT</span><br />
		
			<a href="./download/file.php?id=7757&amp;mode=view"><img src="./download/file.php?id=7757&amp;t=1" alt="IMG_6694.jpg" /></a><br />
			<span class="gensmall">IMG_6694.jpg [ 137.42 KiB | Viewed 1305 times ]</span>
		

		<br />
	</td>
							</tr>
						
						</table>
					
						<div class="postbody"><br />_________________<br /><!-- m --><a class="postlink" href="http://www.chrismcovell.com">http://www.chrismcovell.com</a><!-- m --></div>
					

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row2">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=355"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table class="tablebg" width="100%" cellspacing="1">
	<tr class="row1">

			<td align="center" valign="middle">
				<a name="p187710"></a>
				<b class="postauthor">byuu</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0">
				<tr>
				
					<td class="gensmall" width="100%"><div style="float: left;">&nbsp;<b>Post subject:</b> <a href="#p187710">Re: Z80 T-cycle timing: what the hell damn guy?</a></div><div style="float: right;"><a href="./viewtopic.php?p=187710#p187710"><img src="./styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Tue Jan 24, 2017 10:40 pm&nbsp;</div></td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150">
			
				<tr>
					<td><img src="./styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr>
			
				</table>

				<span class="postdetails">
					<br /><b>Joined:</b> Mon Mar 27, 2006 5:23 pm<br /><b>Posts:</b> 1364
				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5">
				<tr>
					<td>
					

						<div class="postbody">&gt; Here's a pic of Neutopia on my monitor (run through an XRGB-2) You can see the coloured borders (which really come from Sprite colour 0, but are set to be the same as BG colour 0) on either side.<br /><br />Oooh, very nice, thank you!<br /><br />I think it'd help a whole lot if my video were centered at least. But I have to figure out HDS' offsets in all three modes before I can even hope to achieve that.<br /><br />&gt; The PCEngineFX forums have lots of technical discussion like this<br /><br />Yuck, can't even view it without registering. Who <em>does</em> that??<br /><br />(::cough:: me for a few weeks last month ::cough::)</div>

					<br clear="all" /><br />

						<table width="100%" cellspacing="0">
						<tr valign="middle">
							<td class="gensmall" align="right">
							
							</td>
						</tr>
						</table>
					</td>
				</tr>
				</table>
			</td>
		</tr>

		<tr class="row1">

			<td class="profile"><strong><a href="#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;">&nbsp;<a href="./memberlist.php?mode=viewprofile&amp;u=375"><img src="./styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a> &nbsp;</div> <div class="gensmall" style="float: right;">&nbsp;</div></td>
	
		</tr>

	<tr>
		<td class="spacer" colspan="2" height="1"><img src="images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr>
	</table>

	<table width="100%" cellspacing="1" class="tablebg">
	<tr align="center">
		<td class="cat"><form name="viewtopic" method="post" action="./viewtopic.php?f=23&amp;t=14994&amp;start=30"><span class="gensmall">Display posts from previous:</span> <select name="st" id="st"><option value="0" selected="selected">All posts</option><option value="1">1 day</option><option value="7">7 days</option><option value="14">2 weeks</option><option value="30">1 month</option><option value="90">3 months</option><option value="180">6 months</option><option value="365">1 year</option></select>&nbsp;<span class="gensmall">Sort by</span> <select name="sk" id="sk"><option value="a">Author</option><option value="t" selected="selected">Post time</option><option value="s">Subject</option></select> <select name="sd" id="sd"><option value="a" selected="selected">Ascending</option><option value="d">Descending</option></select>&nbsp;<input class="btnlite" type="submit" value="Go" name="sort" /></form></td>
	</tr>
	</table>
	

	<table width="100%" cellspacing="1">
	<tr>
		<td align="left" valign="middle" nowrap="nowrap">
		<a href="./posting.php?mode=post&amp;f=23"><img src="./styles/subsilver2/imageset/en/button_topic_new.gif" alt="Post new topic" title="Post new topic" /></a>&nbsp;<a href="./posting.php?mode=reply&amp;f=23&amp;t=14994"><img src="./styles/subsilver2/imageset/en/button_topic_reply.gif" alt="Reply to topic" title="Reply to topic" /></a>
		</td>
		
			<td class="nav" valign="middle" nowrap="nowrap">&nbsp;Page <strong>3</strong> of <strong>3</strong><br /></td>
			<td class="gensmall" nowrap="nowrap">&nbsp;[ 37 posts ]&nbsp;</td>
			<td class="gensmall" width="100%" align="right" nowrap="nowrap"><b><a href="#" onclick="jumpto(); return false;" title="Click to jump to pageâ€¦">Go to page</a> <a href="./viewtopic.php?f=23&amp;t=14994&amp;start=15">Previous</a>&nbsp;&nbsp;<a href="./viewtopic.php?f=23&amp;t=14994">1</a><span class="page-sep">, </span><a href="./viewtopic.php?f=23&amp;t=14994&amp;start=15">2</a><span class="page-sep">, </span><strong>3</strong></b></td>
		
	</tr>
	</table>

</div>

<div id="pagefooter"></div>

<br clear="all" />
<table class="tablebg" width="100%" cellspacing="1" cellpadding="0" style="margin-top: 5px;">
	<tr>
		<td class="row1">
			<p class="breadcrumbs"><a href="./index.php">Board index</a> &#187; <a href="./viewforum.php?f=25">Other</a> &#187; <a href="./viewforum.php?f=23">Other Retro Dev</a></p>
			<p class="datetime">All times are UTC - 7 hours </p>
		</td>
	</tr>
	</table>
	<br clear="all" />

	<table class="tablebg" width="100%" cellspacing="1">
	<tr>
		<td class="cat"><h4>Who is online</h4></td>
	</tr>
	<tr>
		<td class="row1"><p class="gensmall">Users browsing this forum: <a href="./memberlist.php?mode=viewprofile&amp;u=9317">Apache Thunder</a> and 2 guests</p></td>
	</tr>
	</table>


<br clear="all" />

<table width="100%" cellspacing="1">
<tr>
	<td width="40%" valign="top" nowrap="nowrap" align="left"></td>
	<td align="right" valign="top" nowrap="nowrap"><span class="gensmall">You <strong>cannot</strong> post new topics in this forum<br />You <strong>cannot</strong> reply to topics in this forum<br />You <strong>cannot</strong> edit your posts in this forum<br />You <strong>cannot</strong> delete your posts in this forum<br />You <strong>cannot</strong> post attachments in this forum<br /></span></td>
</tr>
</table>

<br clear="all" />

<table width="100%" cellspacing="0">
<tr>
	<td><form method="get" name="search" action="./search.php"><span class="gensmall">Search for:</span> <input class="post" type="text" name="keywords" size="20" /> <input class="btnlite" type="submit" value="Go" /><input type="hidden" name="t" value="14994" />
<input type="hidden" name="sf" value="msgonly" />
</form></td>
	<td align="right">
	<form method="post" name="jumpbox" action="./viewforum.php" onsubmit="if(document.jumpbox.f.value == -1){return false;}">

	<table cellspacing="0" cellpadding="0" border="0">
	<tr>
		<td nowrap="nowrap"><span class="gensmall">Jump to:</span>&nbsp;<select name="f" onchange="if(this.options[this.selectedIndex].value != -1){ document.forms['jumpbox'].submit() }">

		
			<option value="-1">Select a forum</option>
		<option value="-1">------------------</option>
			<option value="24">NES / Famicom</option>
		
			<option value="2">&nbsp; &nbsp;NESdev</option>
		
			<option value="3">&nbsp; &nbsp;NESemdev</option>
		
			<option value="21">&nbsp; &nbsp;NES Graphics</option>
		
			<option value="6">&nbsp; &nbsp;NES Music</option>
		
			<option value="22">&nbsp; &nbsp;Homebrew Projects</option>
		
			<option value="34">&nbsp; &nbsp;&nbsp; &nbsp;2018 NESdev Competition</option>
		
			<option value="33">&nbsp; &nbsp;&nbsp; &nbsp;2017 NESdev Competition</option>
		
			<option value="32">&nbsp; &nbsp;&nbsp; &nbsp;2016 NESdev Competition</option>
		
			<option value="31">&nbsp; &nbsp;&nbsp; &nbsp;2014 NESdev Competition</option>
		
			<option value="30">&nbsp; &nbsp;&nbsp; &nbsp;2011 NESdev Competition</option>
		
			<option value="10">&nbsp; &nbsp;Newbie Help Center</option>
		
			<option value="9">&nbsp; &nbsp;NES Hardware and Flash Equipment</option>
		
			<option value="28">&nbsp; &nbsp;&nbsp; &nbsp;Reproduction</option>
		
			<option value="19">&nbsp; &nbsp;NESdev International</option>
		
			<option value="11">&nbsp; &nbsp;&nbsp; &nbsp;FCdev</option>
		
			<option value="18">&nbsp; &nbsp;&nbsp; &nbsp;NESdev China</option>
		
			<option value="27">&nbsp; &nbsp;&nbsp; &nbsp;NESdev Middle East</option>
		
			<option value="25">Other</option>
		
			<option value="5">&nbsp; &nbsp;General Stuff</option>
		
			<option value="4">&nbsp; &nbsp;Membler Industries</option>
		
			<option value="23" selected="selected">&nbsp; &nbsp;Other Retro Dev</option>
		
			<option value="12">&nbsp; &nbsp;&nbsp; &nbsp;SNESdev</option>
		
			<option value="20">&nbsp; &nbsp;&nbsp; &nbsp;GBDev</option>
		
			<option value="15">&nbsp; &nbsp;Test Forum</option>
		
			<option value="26">Site Issues</option>
		
			<option value="13">&nbsp; &nbsp;phpBB Issues</option>
		
			<option value="14">&nbsp; &nbsp;Web Issues</option>
		
			<option value="16">&nbsp; &nbsp;nesdevWiki</option>
		

		</select>&nbsp;<input class="btnlite" type="submit" value="Go" /></td>
	</tr>
	</table>

	</form>
</td>
</tr>
</table>


</div>


<div id="wrapfooter">
	
	<span class="copyright">Powered by <a href="http://www.phpbb.com/">phpBB</a>&reg; Forum Software &copy; phpBB Group
	</span>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61452025-2', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>