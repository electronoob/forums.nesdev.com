<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Hex to Decimal suggestion</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Hex to Decimal suggestion</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=10&amp;t=1222">http://forums.nesdev.com/viewtopic.php?f=10&amp;t=1222</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>6</strong> of <strong>7</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Tue Sep 12, 2006 7:34 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I'll probably attempt to implement yxa_to_5_digits on up to yxa_to_8_digits. The main problem is that these exceed the 6502's registers, so will require lots of swapping with memory. The comparisons will also be more involved with three bytes. It'd be nice to have a whole family of routines through 24 bits.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tokumaru</b> [ Tue Sep 12, 2006 8:35 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Yeah, and I liked your idea of entry points, where you can use the same routine for a range of different precisions as needed. And a big routine could always be cut down depending on how large your numbers are.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Tue Sep 12, 2006 11:36 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Extending to 24-bit input and 8 decimal digits out didn't turn out as bad as I thought. Here are the new routines I added and their timings (and the previous routines, for completeness):
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">yxa_to_8_digits: Best: 186, Average: 344, Worst: 475<br />yxa_to_7_digits: Best: 170, Average: 322, Worst: 440<br />yxa_to_6_digits: Best: 139, Average: 254, Worst: 348<br />yxa_to_5_digits: Best: 104, Average: 179, Worst: 236<br />&nbsp;xa_to_5_digits: Best:&nbsp; 99, Average: 170, Worst: 231<br />&nbsp;xa_to_4_digits: Best:&nbsp; 79, Average: 128, Worst: 173<br />&nbsp;xa_to_3_digits: Best:&nbsp; 54, Average:&nbsp; 75, Worst:&nbsp; 94<br />&nbsp; a_to_3_digits: Best:&nbsp; 43, Average:&nbsp; 52, Worst:&nbsp; 60<br />&nbsp; a_to_2_digits: Best:&nbsp; 28, Average:&nbsp; 34, Worst:&nbsp; 40</div>
<br />Support for 6 or more digits is in yxa_to_decimal.asm, and the original source has been modified as well:
<br /><a href="http://www.io.com/~greens/temp/xa_to_decimal.asm" class="postlink">xa_to_decimal.asm</a>
<br /><a href="http://www.io.com/~greens/temp/yxa_to_decimal.asm" class="postlink">yxa_to_decimal.asm</a>
<br />Unfortunately the test program had to become more extensive in order to try every possible 24-bit input value. I ended up adding my NES CPU emulator and having it run the routine for every value. This allowed the test program to conveniently generate the timing information automatically. For the 8 digit output, it took 2.5 minutes for the program to run, which translates to about 53 minutes of emulated NES time! (average of 344 clocks * $FFFFFF / 1789773 = 3224 seconds)
<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I liked your idea of entry points, where you can use the same routine for a range of different precisions as needed. And a big routine could always be cut down depending on how large your numbers are.</div>
<br />Yeah, the multiple entry points was a lucky side-effect of the algorithm. As you say, any of the upper digit code can be removed if you don't need it in a particular program.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Quietust</b> [ Wed Sep 13, 2006 7:23 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I liked the method you used, but didn't like the high code size (613 bytes) and the forcing of using all of the available registers to hold the values (which can get messy and confusing at times), so I threw together a looped routine that worked on the same principle but took up less space. Code size came up at 280 bytes, and while it is significantly slower than your version, it's still way faster than the one I posted earlier. It currently doesn't support multiple entry points for variable output digits, but that's easy enough to add by just replacing the initial LDY in each routine with a different value corresponding to the proper offsets in the data tables.
<br />
<br />This one assembles with CA65:
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">.define&nbsp; &nbsp;HEX_BYTE2&#40;val&#41; .LOBYTE&#40;.HIWORD&#40;val&#41;&#41;<br />.define&nbsp; &nbsp;HEX_BYTE1&#40;val&#41; .HIBYTE&#40;.LOWORD&#40;val&#41;&#41;<br />.define&nbsp; &nbsp;HEX_BYTE0&#40;val&#41; .LOBYTE&#40;.LOWORD&#40;val&#41;&#41;<br /><br />hex2bcd_output:&nbsp; &nbsp;.res 8<br />hex2bcd_input:&nbsp; &nbsp;.res 3<br /><br />.proc&nbsp; &nbsp;hex2bcd_init<br />&nbsp; &nbsp;LDY #7<br />:&nbsp; &nbsp;STA hex2bcd_output,Y<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL :-&nbsp; &nbsp;<br />&nbsp; &nbsp;RTS<br />.endproc<br /><br />.proc&nbsp; &nbsp;hex2bcd_24bit<br />&nbsp; &nbsp;LDY #0<br />loop:&nbsp; &nbsp;LDA hex2bcd_otable,Y<br />&nbsp; &nbsp;BMI done<br />&nbsp; &nbsp;TAX<br />&nbsp; &nbsp;SEC<br />&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC hex2bcd_b0table,Y<br />&nbsp; &nbsp;PHA<br />&nbsp; &nbsp;LDA hex2bcd_input+1<br />&nbsp; &nbsp;SBC hex2bcd_b1table,Y<br />&nbsp; &nbsp;PHA<br />&nbsp; &nbsp;LDA hex2bcd_input+2<br />&nbsp; &nbsp;SBC hex2bcd_b2table,Y<br />&nbsp; &nbsp;BCS okay<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;BCC end<br />okay:&nbsp; &nbsp;STA hex2bcd_input+2<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;STA hex2bcd_input+1<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;STA hex2bcd_input+0<br /><br />&nbsp; &nbsp;LDA hex2bcd_output,X<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_vtable,Y<br />&nbsp; &nbsp;STA hex2bcd_output,X<br />end:&nbsp; &nbsp;INY<br />&nbsp; &nbsp;BNE loop<br /><br />done:&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_output+7<br />&nbsp; &nbsp;STA hex2bcd_output+7<br />&nbsp; &nbsp;RTS<br />.endproc<br /><br />.proc&nbsp; &nbsp;hex2bcd_16bit<br />&nbsp; &nbsp;LDY #9<br />loop:&nbsp; &nbsp;LDA hex2bcd_otable,Y<br />&nbsp; &nbsp;BMI done<br />&nbsp; &nbsp;TAX<br />&nbsp; &nbsp;SEC<br />&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC hex2bcd_b0table,Y<br />&nbsp; &nbsp;PHA<br />&nbsp; &nbsp;LDA hex2bcd_input+1<br />&nbsp; &nbsp;SBC hex2bcd_b1table,Y<br />&nbsp; &nbsp;BCS okay<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;BCC end<br />okay:&nbsp; &nbsp;STA hex2bcd_input+1<br />&nbsp; &nbsp;PLA<br />&nbsp; &nbsp;STA hex2bcd_input+0<br /><br />&nbsp; &nbsp;LDA hex2bcd_output,X<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_vtable,Y<br />&nbsp; &nbsp;STA hex2bcd_output,X<br />end:&nbsp; &nbsp;INY<br />&nbsp; &nbsp;BNE loop<br /><br />done:&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_output+7<br />&nbsp; &nbsp;STA hex2bcd_output+7<br />&nbsp; &nbsp;RTS<br />.endproc<br /><br />.proc&nbsp; &nbsp;hex2bcd_8bit<br />&nbsp; &nbsp;LDY #19<br />loop:&nbsp; &nbsp;LDA hex2bcd_otable,Y<br />&nbsp; &nbsp;BMI done<br />&nbsp; &nbsp;TAX<br />&nbsp; &nbsp;SEC<br />&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC hex2bcd_b0table,Y<br />&nbsp; &nbsp;BCC end<br />okay:&nbsp; &nbsp;STA hex2bcd_input+0<br /><br />&nbsp; &nbsp;LDA hex2bcd_output,X<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_vtable,Y<br />&nbsp; &nbsp;STA hex2bcd_output,X<br />end:&nbsp; &nbsp;INY<br />&nbsp; &nbsp;BNE loop<br /><br />done:&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;ADC hex2bcd_output+7<br />&nbsp; &nbsp;STA hex2bcd_output+7<br />&nbsp; &nbsp;RTS<br />.endproc<br /><br />hex2bcd_b2table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE2&#40;10000000&#41;<br />.byte HEX_BYTE2&#40; 6000000&#41;,HEX_BYTE2&#40; 3000000&#41;,HEX_BYTE2&#40; 2000000&#41;,HEX_BYTE2&#40; 1000000&#41;<br />.byte HEX_BYTE2&#40;&nbsp; 600000&#41;,HEX_BYTE2&#40;&nbsp; 300000&#41;,HEX_BYTE2&#40;&nbsp; 200000&#41;,HEX_BYTE2&#40;&nbsp; 100000&#41;<br />.byte HEX_BYTE2&#40;&nbsp; &nbsp;60000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp;30000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp;20000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp;10000&#41;<br />.byte HEX_BYTE2&#40;&nbsp; &nbsp; 6000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; 3000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; 2000&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; 1000&#41;<br />.byte HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp;600&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp;300&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp;200&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp;100&#41;<br />.byte HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp; 60&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp; 30&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp; 20&#41;,HEX_BYTE2&#40;&nbsp; &nbsp; &nbsp; 10&#41;<br /><br />hex2bcd_b1table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE1&#40;10000000&#41;<br />.byte HEX_BYTE1&#40; 6000000&#41;,HEX_BYTE1&#40; 3000000&#41;,HEX_BYTE1&#40; 2000000&#41;,HEX_BYTE1&#40; 1000000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; 600000&#41;,HEX_BYTE1&#40;&nbsp; 300000&#41;,HEX_BYTE1&#40;&nbsp; 200000&#41;,HEX_BYTE1&#40;&nbsp; 100000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp;60000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;30000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;20000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;10000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp; 6000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 3000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 2000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 1000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;600&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;300&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;200&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;100&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp; 60&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp; 30&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp; 20&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp; 10&#41;<br /><br />hex2bcd_b0table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE0&#40;10000000&#41;<br />.byte HEX_BYTE0&#40; 6000000&#41;,HEX_BYTE0&#40; 3000000&#41;,HEX_BYTE0&#40; 2000000&#41;,HEX_BYTE0&#40; 1000000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; 600000&#41;,HEX_BYTE0&#40;&nbsp; 300000&#41;,HEX_BYTE0&#40;&nbsp; 200000&#41;,HEX_BYTE0&#40;&nbsp; 100000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp;60000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;30000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;20000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;10000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp; 6000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 3000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 2000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 1000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;600&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;300&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;200&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;100&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp; 60&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp; 30&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp; 20&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp; 10&#41;<br /><br />hex2bcd_otable:<br />&nbsp; &nbsp;.byte 0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,$FF<br />hex2bcd_vtable:<br />&nbsp; &nbsp;.byte 1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1,6,3,2,1<br /></div>
<br />
<br />How hard do you think it would be to update your test program to test and profile these functions? When I timed the 24-bit version I got around 1500 cycles for a 5-digit number, but then I noticed that b2table was crossing a page boundary.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Bregalad</b> [ Wed Sep 13, 2006 8:35 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Oh, I did follow nothing ! Are you guys still doing the method who substract constant numbers and compares them in order to find the main digit (unsure I understand this perfectly).
<br />Using A, X and Y register as the input number isn't optimal in my opinion.
<br />The best way is to have only a pointer in z-page that points where the actual binary number in memory to be converted is, and to call the routine to a different label in function of the number of digit you want.
<br />Just compare the two folowing piece of code :
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda #&lt;Number<br />sta PointerL<br />lda #&gt;Number<br />sta PointerH<br />jsr ConvertBinNmr<br /></div><br />or<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">lda Number+2<br />tay<br />lda Number+1<br />tax<br />lda Number<br />jsr ConvertBinNmr</div>
<br />Well, both aren't so much different, but I just found the first one look more professional. Total subjective behaviour, though.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Memblers</b> [ Wed Sep 13, 2006 9:04 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent">Well, both aren't so much different, but I just found the first one look more professional. Total subjective behaviour, though.</div>
<br />
<br />I'd say it's a good opportunity for writing a macro for calling the routine, you can have it look as professional as you want while still being the fastest and smallest method (and only take up one line of source, which is great if you do it a lot, less chance for typos also).
<br />
<br />Why does your 2nd example do LDA number+2 / TAY btw?  Just do LDY number+2.  <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" />
<br />
<br />Nice work everyone, and thanks.  Maybe some day I'll have a program now that displays actual decimal numbers from hex (I can think of plenty of uses, XMODEM transfer status for one).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Wed Sep 13, 2006 12:47 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Quietust's table-based version passed the exhaustive test. I then optimized it to run about twice as fast and fit in one 256-byte page. Here is the original source and three progressively optimized versions, with comments at the top about all the changes:
<br />
<br /><a href="http://www.io.com/~greens/temp/hex2bcd_opt.zip" class="postlink">hex2bcd_opt.zip</a>
<br />
<br />This code could also have multiple entry points added for the desired number of output digits. Maybe I'll do that tomorrow.
<br />
<br /><strong>UPDATE</strong> ... or today.
<br />
<br />I think I've pretty much beat this to death here. I added entry points for arbitrary numbers of digits, and an intermediate optimized version with just the 24-bit code, if size is your biggest concern (it comes in at 192 bytes). The other fast code from yesterday is also included.
<br />
<br /><a href="http://www.io.com/~greens/temp/to_decimal_asm.zip" class="postlink">to_decimal_asm.zip</a>
<br />
<br />Summary so far:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">xa_to_decimal.asm:<br />yxa_to_8_digits: Best: 186, Average: 344, Worst: 475<br />yxa_to_7_digits: Best: 170, Average: 322, Worst: 440<br />yxa_to_6_digits: Best: 139, Average: 254, Worst: 348<br />yxa_to_5_digits: Best: 104, Average: 179, Worst: 236<br />&nbsp;xa_to_5_digits: Best:&nbsp; 99, Average: 170, Worst: 231<br />&nbsp;xa_to_4_digits: Best:&nbsp; 79, Average: 128, Worst: 173<br />&nbsp;xa_to_3_digits: Best:&nbsp; 54, Average:&nbsp; 75, Worst:&nbsp; 94<br />&nbsp; a_to_3_digits: Best:&nbsp; 43, Average:&nbsp; 52, Worst:&nbsp; 60<br />&nbsp; a_to_2_digits: Best:&nbsp; 28, Average:&nbsp; 34, Worst:&nbsp; 40<br />610 bytes &#40;279 if you leave out 6-8 digit support&#41;<br /><br />hex2bcd.asm<br />hex2bcd_24bit_8dig Best: 600, Average: 815, Worst: 940<br />hex2bcd_24bit_7dig Best: 572, Average: 777, Worst: 877<br />hex2bcd_24bit_6dig Best: 452, Average: 608, Worst: 687<br />hex2bcd_24bit_5dig Best: 332, Average: 439, Worst: 497<br />hex2bcd_16bit_5dig Best: 288, Average: 383, Worst: 441<br />hex2bcd_16bit_4dig Best: 222, Average: 289, Worst: 329<br />hex2bcd_16bit_3dig Best: 130, Average: 165, Worst: 191<br />&nbsp;hex2bcd_8bit_3dig Best:&nbsp; 55, Average:&nbsp; 67, Worst:&nbsp; 78<br />&nbsp;hex2bcd_8bit_2dig Best:&nbsp; 48, Average:&nbsp; 55, Worst:&nbsp; 60 <br />277 bytes<br /><br />hex2bcd_small.asm<br />hex2bcd_24bit_8dig: Best: 768, Average: 1073, Worst: 1226<br />hex2bcd_24bit_7dig: Best: 741, Average: 1036, Worst: 1164<br />hex2bcd_24bit_6dig: Best: 621, Average:&nbsp; 867, Worst:&nbsp; 974<br />hex2bcd_24bit_5dig: Best: 501, Average:&nbsp; 698, Worst:&nbsp; 784<br />hex2bcd_16bit_5dig: Best: 471, Average:&nbsp; 661, Worst:&nbsp; 754<br />hex2bcd_16bit_4dig: Best: 381, Average:&nbsp; 529, Worst:&nbsp; 594<br />hex2bcd_16bit_3dig: Best: 261, Average:&nbsp; 360, Worst:&nbsp; 404<br />&nbsp;hex2bcd_8bit_3dig: Best: 201, Average:&nbsp; 270, Worst:&nbsp; 309<br />&nbsp;hex2bcd_8bit_2dig: Best: 141, Average:&nbsp; 191, Worst:&nbsp; 214<br />192 bytes</div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>mozz</b> [ Sat Sep 16, 2006 10:50 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />See?  Get a few smart people interested in solving a problem, and look what happens!
<br />
<br />Blargg and Quietust, thank you for following through on this.  Now everybody who actually writes their own NES games can benefit.  This is exactly what I hoped would happen.
<br />
<br />Edit:  @Bregalad and Celius:  the algorithm I proposed works on a similar idea to <a href="http://en.wikipedia.org/wiki/Binary_search" class="postlink">binary search (see wikipedia article)</a>.
<br />For each digit, it essentially does a binary search for the value of the digit.  With 10 possible values for the digit, you need to do at most ceil(log2(10)) == 4 tests to figure out which one it is.
<br />
<br />One subtle part is this:  Once you know what the value of the digit is, you have to subtract that number from N anyways so that you can get on with figuring out the next digit.  So rather than handle the "high" case and the "low" case differently for each comparison, I keep things simple by just subtracting as I go!  That effectively makes both cases the same.
<br />
<br />So if you have 4 digits worth of number to figure out, and you start out comparing the number to 6000, then either it's less than 6000 and we do nothing (the low case), or its &gt;= 6000 (the high case) in which case we subtract that 6000 right away and add 6 to temporary where we store the value of the digit we will output.  Because of the subtraction, the remaining part of the number is now less than 4000, whether we subtracted 6000 from it or not, which makes it simple to do the next step (comparing it to 3000).
<br />
<br />The other subtle part, which Disch elaborated on earlier, is how I chose the 4 points to compare the digit to such that at most two of the comparisons will succeed.  3 comparisons is unfortunately not enough in some cases (that could only distinguish 2^3 == 8 different values).  If we had 16 possible digits to look for, we would need the four points to be 8,4,2,1 but since we only have 10 possible digits that the result might be, 6,3,2,1 are slightly faster when the digit happens to be a 7 (because 6+1 = 7, where the other case is 4+2+1 = 7)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sat Sep 16, 2006 1:10 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">mozz wrote:</div><div class="quotecontent">the algorithm I proposed works on a similar idea to binary search (see wikipedia article). For each digit, it essentially does a binary search for the value of the digit. With 10 possible values for the digit, you need to do at most ceil(log2(10)) == 4 tests to figure out which one it is.</div><br /><br />I actually started out by trying to implement a binary search, but it was quite unwieldy.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Once you know what the value of the digit is, you have to subtract that number from N anyways so that you can get on with figuring out the next digit. So rather than handle the "high" case and the "low" case differently for each comparison, I keep things simple by just subtracting as I go! That effectively makes both cases the same.</div><br />That didn't work in your code since the subtraction of the low byte is bypassed when the high byte is greater than the comparison value. Below, when X &gt; 23, it jumps to gt60000. In your code, the SBC would only have been done in place of the CMP #112, if X = 23. Also the way I coded it, I didn't keep re-loading the lowest byte, so even if I found a way to use the SBC in place of a comparison, I'd have to undo the subtract if the number was found lower than the digit value.<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; cpx #23<br />&nbsp; &nbsp; bcc lt6000<br />&nbsp; &nbsp; bne gt6000<br />&nbsp; &nbsp; cmp #112<br />&nbsp; &nbsp; bcc lt6000<br />gt6000:<br />&nbsp; &nbsp; sbc #112<br />&nbsp; &nbsp; tay<br />&nbsp; &nbsp; txa<br />&nbsp; &nbsp; sbc #23<br />&nbsp; &nbsp; tax<br />&nbsp; &nbsp; tya</div><br />On the other hand, Quietust's hex2bcd (and my further optimizations of it) do as you describe: subtract the digit value from a temporary copy of the value, and if the result isn't negative, writes this new value back. I enjoyed the simplicity of this when working with hex2bcd.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">since we only have 10 possible digits that the result might be, 6,3,2,1 are slightly faster when the digit happens to be a 7 (because 6+1 = 7, where the other case is 4+2+1 = 7)</div>
<br />I delved deeper into this in some ways. I first noted that only 3 out of 10 digits end in a 1, therefore 70% of the time the last comparison will not match, so the code can be optimized for the loop ending with a non-match. Also, supporting multiple entry points, I used the digits 7, 4, 2, 1 for the ten thousands place (in both versions), allowing the 16-bit case to check digits 4, 2, 1, and the 24-bit case to check for digits 7, 4, 2, 1. This allowed the 24-bit code to jump to the 16-bit code after checking for 7. The 7, 4, 2, 1 set is almost as good as 6, 3, 2, 1, and doesn't ever use more than two for a given digit.
<br />
<br />The code still needs to be documented a bit better and perhaps hex2bcd have the multiple entry points moved to another file (or added as macros as I did to hex2bcd_small), since they bloat it a bit.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>mozz</b> [ Sat Sep 16, 2006 3:25 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">That didn't work in your code since the subtraction of the low byte is bypassed when the high byte is greater than the comparison value. Below, when X &gt; 23, it jumps to gt60000. In your code, the SBC would only have been done in place of the CMP #112, if X = 23.</div><br />Whoops!  That's what happens when I write code at three in the morning and never test it.<br /><br /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">I delved deeper into this in some ways. I first noted that only 3 out of 10 digits end in a 1, therefore 70% of the time the last comparison will not match, so the code can be optimized for the loop ending with a non-match. Also, supporting multiple entry points, I used the digits 7, 4, 2, 1 for the ten thousands place (in both versions), allowing the 16-bit case to check digits 4, 2, 1, and the 24-bit case to check for digits 7, 4, 2, 1. This allowed the 24-bit code to jump to the 16-bit code after checking for 7. The 7, 4, 2, 1 set is almost as good as 6, 3, 2, 1, and doesn't ever use more than two for a given digit. </div>
<br />That is very clever.  I can see how 24-bit support might be useful, e.g. for experience points in an RPG.  Having entry points for known number of digits is a great idea too.  Note that if you aren't sure how large the number is but its usually small, you could do one short-circuit test at the start of the routine (e.g. if the high byte is zero, jump over a bunch of code).

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Quietust</b> [ Sat Sep 16, 2006 7:19 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">Quietust's table-based version passed the exhaustive test. I then optimized it to run about twice as fast and fit in one 256-byte page. Here is the original source and three progressively optimized versions, with comments at the top about all the changes:<br /><br /><a href="http://www.io.com/~greens/temp/hex2bcd_opt.zip" class="postlink">hex2bcd_opt.zip</a></div>
<br />
<br />Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit? Is there something gained by not handling it straight within the 16-bit case? And why do you not do the same thing when going from 16-bit to 8-bit (you end up doing the 200 case twice)?
<br />
<br />For reference, the following code appears to work properly and is only 233 bytes long. When I ran it on the 24-bit number 0, it took only 581 cycles to complete, though I don't know if larger numbers were made slower in the process.
<br />
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">hex2bcd_output:&nbsp; &nbsp;.res 8<br />hex2bcd_input:&nbsp; &nbsp;.res 3<br /><br /><br /><br />.proc&nbsp; &nbsp;hex2bcd_init<br />&nbsp; &nbsp;LDY #7<br />:&nbsp; &nbsp;STA hex2bcd_output,Y<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL :-&nbsp; &nbsp;<br />&nbsp; &nbsp;RTS<br />.endproc<br /><br />.scope hex2bcd<br />conv_24bit:<br />&nbsp; &nbsp;LDY #9<br />&nbsp; &nbsp;CLC<br />loop1:&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC b0table+9,Y<br />&nbsp; &nbsp;LDA hex2bcd_input+1<br />&nbsp; &nbsp;SBC b1table+9,Y<br />&nbsp; &nbsp;TAX<br />&nbsp; &nbsp;LDA hex2bcd_input+2<br />&nbsp; &nbsp;SBC b2table,Y<br />&nbsp; &nbsp;BCS good1<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL loop1<br />&nbsp; &nbsp;BMI conv_16bit<br />&nbsp; &nbsp;<br />good1:&nbsp; &nbsp;STA hex2bcd_input+2<br />&nbsp; &nbsp;STX hex2bcd_input+1<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;LDX otable+9,Y<br />&nbsp; &nbsp;LDA hex2bcd_output,X<br />&nbsp; &nbsp;ADC vtable,Y<br />&nbsp; &nbsp;STA hex2bcd_output,X<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC b0table+9,Y<br />&nbsp; &nbsp;STA hex2bcd_input+0<br />&nbsp; &nbsp;CLC<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL loop1<br /><br />conv_16bit:<br />&nbsp; &nbsp;LDY #8<br />&nbsp; &nbsp;CLC<br />loop2:&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;SBC b0table,Y<br />&nbsp; &nbsp;TAX<br />&nbsp; &nbsp;LDA hex2bcd_input+1<br />&nbsp; &nbsp;SBC b1table,Y<br />&nbsp; &nbsp;BCS good2<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL loop2<br />&nbsp; &nbsp;BMI conv_8bit<br />&nbsp; &nbsp;<br />good2:&nbsp; &nbsp;STX hex2bcd_input+0<br />&nbsp; &nbsp;STA hex2bcd_input+1<br />&nbsp; &nbsp;LDX otable,Y<br />&nbsp; &nbsp;LDA hex2bcd_output,X<br />&nbsp; &nbsp;ADC vtable+3,Y<br />&nbsp; &nbsp;STA hex2bcd_output,X<br />&nbsp; &nbsp;DEY<br />&nbsp; &nbsp;BPL loop2<br /><br />conv_8bit:<br />&nbsp; &nbsp;LDA hex2bcd_input+0<br />&nbsp; &nbsp;CMP #200<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #200<br />&nbsp; &nbsp;INC hex2bcd_output+5<br />&nbsp; &nbsp;INC hex2bcd_output+5<br />:&nbsp; &nbsp;CMP #100<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #100<br />&nbsp; &nbsp;INC hex2bcd_output+5<br />:&nbsp; &nbsp;LDX #0<br />&nbsp; &nbsp;CMP #60<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #60<br />&nbsp; &nbsp;LDX #6<br />:&nbsp; &nbsp;CMP #30<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #30<br />&nbsp; &nbsp;INX<br />&nbsp; &nbsp;INX<br />&nbsp; &nbsp;INX<br />:&nbsp; &nbsp;CMP #20<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #20<br />&nbsp; &nbsp;INX<br />&nbsp; &nbsp;INX<br />:&nbsp; &nbsp;CMP #10<br />&nbsp; &nbsp;BCC :+<br />&nbsp; &nbsp;SBC #10<br />&nbsp; &nbsp;INX<br />&nbsp; &nbsp;CLC<br />:&nbsp; &nbsp;ADC hex2bcd_output+7<br />&nbsp; &nbsp;STA hex2bcd_output+7<br />&nbsp; &nbsp;TXA<br />&nbsp; &nbsp;ADC hex2bcd_output+6<br />&nbsp; &nbsp;STA hex2bcd_output+6<br />&nbsp; &nbsp;RTS<br /><br />vtable:&nbsp; &nbsp;.byte 6,0,1,2,5,0,1,2,5,0,1,3<br />otable:&nbsp; &nbsp;.byte 5,5,4,4,4,4,3,3,3,3,2,2,2,2,1,1,1,1,0<br /><br />.define&nbsp; &nbsp; HEX_BYTE2&#40;val&#41; .LOBYTE&#40;.HIWORD&#40;val&#41;&#41;<br />.define&nbsp; &nbsp; HEX_BYTE1&#40;val&#41; .HIBYTE&#40;.LOWORD&#40;val&#41;&#41;<br />.define&nbsp; &nbsp; HEX_BYTE0&#40;val&#41; &#40;.LOBYTE&#40;.LOWORD&#40;val&#41;&#41;-1&#41;<br /><br />b0table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;300&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; &nbsp;600&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp; 1000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 2000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 3000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp; 6000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; &nbsp;10000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;20000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;40000&#41;,HEX_BYTE0&#40;&nbsp; &nbsp;70000&#41;<br />.byte HEX_BYTE0&#40;&nbsp; 100000&#41;,HEX_BYTE0&#40;&nbsp; 200000&#41;,HEX_BYTE0&#40;&nbsp; 300000&#41;,HEX_BYTE0&#40;&nbsp; 600000&#41;<br />.byte HEX_BYTE0&#40; 1000000&#41;,HEX_BYTE0&#40; 2000000&#41;,HEX_BYTE0&#40; 3000000&#41;,HEX_BYTE0&#40; 6000000&#41;<br />.byte HEX_BYTE0&#40;10000000&#41;<br /><br />b1table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;300&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; &nbsp;600&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp; 1000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 2000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 3000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp; 6000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; &nbsp;10000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;20000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;40000&#41;,HEX_BYTE1&#40;&nbsp; &nbsp;70000&#41;<br />.byte HEX_BYTE1&#40;&nbsp; 100000&#41;,HEX_BYTE1&#40;&nbsp; 200000&#41;,HEX_BYTE1&#40;&nbsp; 300000&#41;,HEX_BYTE1&#40;&nbsp; 600000&#41;<br />.byte HEX_BYTE1&#40; 1000000&#41;,HEX_BYTE1&#40; 2000000&#41;,HEX_BYTE1&#40; 3000000&#41;,HEX_BYTE1&#40; 6000000&#41;<br />.byte HEX_BYTE1&#40;10000000&#41;<br /><br />b2table:<br />.byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEX_BYTE2&#40;&nbsp; &nbsp;70000&#41;<br />.byte HEX_BYTE2&#40;&nbsp; 100000&#41;,HEX_BYTE2&#40;&nbsp; 200000&#41;,HEX_BYTE2&#40;&nbsp; 300000&#41;,HEX_BYTE2&#40;&nbsp; 600000&#41;<br />.byte HEX_BYTE2&#40; 1000000&#41;,HEX_BYTE2&#40; 2000000&#41;,HEX_BYTE2&#40; 3000000&#41;,HEX_BYTE2&#40; 6000000&#41;<br />.byte HEX_BYTE2&#40;10000000&#41;<br />.endscope<br /><br />hex2bcd_24bit = hex2bcd::conv_24bit<br />hex2bcd_16bit = hex2bcd::conv_16bit<br />hex2bcd_8bit = hex2bcd::conv_8bit<br /></div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Sun Sep 17, 2006 12:14 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit?</div><br />The ten thousand values subtracted are 70000, 40000, 20000, and 10000. In the 24-bit case, once it's eliminated 70000, the number could still be 69999 ($01116F). If it jumped to the 16-bit code immediately, the still non-zero most significant byte would be ignored, making the value look like 4463. Of course I had the benefit of the validator, so I could just adjust the overlap until it worked, then figure out why. :)<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">When I ran it on the 24-bit number 0, it took only 581 cycles to complete,</div>
<br />In the most recent posted code I list the worst-case values so you can easily invoke it when testing them in a program. I tested your changes and they broke the 24-bit and 16-bit routines for the reason described above. I went ahead spent a while (ugh, 3 hours now that I check) optimizing the routine more.
<br />
<br />I was able to eliminate the entry for 200 from the table and have the 16-bit case do an optimized check for this at the end, simply seeing if the high byte is non-zero, in which case it subtracts 200 without any further checks. If the high byte is zero, then it uses the normal hex2bcd_8bit code.
<br />
<br />I found another optimizatin using the 7/4/2/1 group: if the 7 test passes, then the 4 test can be skipped. I incorporated this into the ends of the 16-bit and 24-bit match loops, having them skip the last entry if the next-to-last entry matched.
<br />
<br />I was able to reduce the vtable size further by changing the millions to the 1/2/4/7 pattern, allowing the 16-bit and 24-bit routines to use the same vtable from the beginning. I had to fix a bug in the HEXBYTE macros: rather than subtract 1 from the low byte, I needed to subtract 1 from val in all of them.
<br />
<br />I rearranged the match handlers to fall through to the loop, and for the non-match loop case to fall through to the next smaller handler (i.e. 24 falls into 16, 16 falls into 8), eliminating more branches.
<br />
<br />Finally, I added short-circuiting that immediately jumps to the 16- and 8- bit handlers once the upper bits of the value become zero. This is just two branches that can be removed if desired, as they slightly increase the worst-case performance.
<br />
<br />I removed the init routine from the source since it was cluttering it up. I also wasn't able to use the local symbol names as my ca65 gave a diagnostic (same for using :+, which sucks), and I don't feel like checking for a new version, getting it to compile, and seeing if these are fixed.
<br />
<br /><a href="http://www.io.com/~greens/temp/hex2bcd5.asm" class="postlink">hex2bcd5.asm</a>
<br />
<br />Best case is for value 0. Worst case values listed.
<br />hex2bcd_24bit Best: 106, Average: 760, Worst: 962 (n=16768641)
<br />hex2bcd_16bit Best:  77, Average: 357, Worst: 439 (n=34640)
<br />hex2bcd_8bit  Best:  55, Average:  67, Worst:  78 (n=240)
<br />252 bytes
<br />
<br />If the two lines marked "optimization only" are removed: (note improved worst-case)
<br />hex2bcd_24bit Best: 589, Average: 788, Worst: 924 (n=15964654)
<br />hex2bcd_16bit Best: 278, Average: 361, Worst: 421 (n=34640)
<br />248 bytes

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Quietust</b> [ Sun Sep 17, 2006 12:48 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">blargg wrote:</div><div class="quotecontent"><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Out of curiosity, why do you handle the 40000 case within the 24-bit code and then skip it when falling through to 16-bit?</div><br />The ten thousand values subtracted are 70000, 40000, 20000, and 10000. In the 24-bit case, once it's eliminated 70000, the number could still be 69999 ($01116F). If it jumped to the 16-bit code immediately, the still non-zero most significant byte would be ignored, making the value look like 4463. Of course I had the benefit of the validator, so I could just adjust the overlap until it worked, then figure out why. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div>
<br />
<br />Oh yeah, forgot about that. <img src="./images/smilies/icon_smile.gif" alt=":)" title="Smile" />
<br />To be fair, I never would have actually seen the 256-299 case, since my score and timer all go by multiples of 50; as for the 65536-69999 case, I just wasn't patient enough to try large enough values.
<br />Come to think of it, it would probably be worth it to just divide the score and bonus timer by 10 internally and just pad them with an extra 0.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>Disch</b> [ Fri Feb 13, 2009 4:44 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />** BUMP **
<br />
<br />Was looking for this lib, but the links are all dead.  Specifically I'm looking for the one previously at this link:
<br />
<br /><!-- m --><a class="postlink" href="it's now http://h1.ripway.com/blargg/temp/to_decimal_asm.zip">it's now http://h1.ripway.com/blargg/temp/to_decimal_asm.zip</a><!-- m -->
<br />
<br />which was the 2nd link in blargg's post here:
<br />
<br /><!-- m --><a class="postlink" href="http://nesdev.com/bbs/viewtopic.php?p=17351#17351">http://nesdev.com/bbs/viewtopi ... 7351#17351</a><!-- m -->
<br />
<br />
<br />If someone has this, could they re-link it somewhere?  Or if it exists somewhere else, could someone give a link?
<br />
<br />Thanks!

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>blargg</b> [ Fri Feb 13, 2009 6:24 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b></b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />For any old links of mine, try replacing "www.io.com/~greens" with "h1.ripway.com/blargg". So this one becomes <!-- m --><a class="postlink" href="http://h1.ripway.com/blargg/temp/to_decimal_asm.zip">http://h1.ripway.com/blargg/temp/to_decimal_asm.zip</a><!-- m -->

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>6</strong> of <strong>7</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>