<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html dir="ltr" lang="en-gb">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Language" content="en-gb">
<title>nesdev.com :: View topic - Game Boy Color BG priority bit [solved]</title>

<style type="text/css">
<!--

body {
	font-family: Verdana,serif;
	font-size: 10pt;
}

img {
	border: 0;
}

td {
	font-family: Verdana,serif;
	font-size: 10pt;
	line-height: 150%;
}

.code, .codecontent, 
.quote, .quotecontent {
	margin: 0 5px 0 5px;
	padding: 5px;
	font-size: smaller;
	border: black solid 1px;
}

.quotetitle {
	color: black;
	display : block;
	font-weight: bold;
}

.forum {
	font-family: Arial,Helvetica,sans-serif;
	font-weight: bold;
	font-size: 18pt;
}

.topic {
	font-family: Arial,Helvetica,sans-serif;
	font-size: 14pt;
	font-weight: bold;
}

.gensmall {
	font-size: 8pt;
}

hr {
	color: #888;
	height: 3px;
	border-style: solid;
}

hr.sep {
	color: #aaa;
	height: 1px;
	border-style: dashed;
}
//-->
</style>

</head>
<body>

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td colspan="2" align="center"><span class="Forum">nesdev.com</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/">http://forums.nesdev.com/</a></span></td>
</tr>
<tr>
	<td colspan="2"><br /></td>
</tr>
<tr>
	<td><span class="topic">Game Boy Color BG priority bit [solved]</span><br /><span class="gensmall"><a href="http://forums.nesdev.com/viewtopic.php?f=20&amp;t=10771">http://forums.nesdev.com/viewtopic.php?f=20&amp;t=10771</a></span></td>
	<td align="right" valign="bottom"><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
</tr>
</table>



	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Mon Dec 09, 2013 2:58 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Hitting a snag here.<br /><br />Origin::BG means a background/window pixel with the priority bit clear.<br />Origin::BGP means a background/window pixel with the priority bit set.<br /><br />If I treat priority BG pixels as always being on top:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; &nbsp; unsigned ox = sx + tx;<br />&nbsp; &nbsp; &nbsp; if(ox &lt; 160) {<br />&nbsp; &nbsp; &nbsp; &nbsp; //When LCDC.D0 (BG enable) is off, OB is always rendered above BG+Window<br />&nbsp; &nbsp; &nbsp; &nbsp; if(status.bg_enable) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.origin == Pixel::Origin::BGP) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(attr &amp; 0x80) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.origin == Pixel::Origin::BG) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.palette &gt; 0) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.origin = Pixel::Origin::OB;<br />&nbsp; &nbsp; &nbsp; }</div><br /><br />The result is the bridge overlapping on top of Shantae at the beginning of a new game, cutting off the sprite.<br /><br />If I allow palette color 0 on a BG priority pixel to be transparent and allow a sprite on top of it:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; &nbsp; unsigned ox = sx + tx;<br />&nbsp; &nbsp; &nbsp; if(ox &lt; 160) {<br />&nbsp; &nbsp; &nbsp; &nbsp; //When LCDC.D0 (BG enable) is off, OB is always rendered above BG+Window<br />&nbsp; &nbsp; &nbsp; &nbsp; if(status.bg_enable) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(attr &amp; 0x80) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.origin == Pixel::Origin::BG || pixels&#91;ox&#93;.origin == Pixel::Origin::BGP) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.palette &gt; 0) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.origin = Pixel::Origin::OB;<br />&nbsp; &nbsp; &nbsp; }</div><br /><br />Then Link is visible on his horse before the window pans onto him in Legand of Zelda - Oracle of Ages' intro.<br /><br />I can't do both, so clearly I'm not understanding something here ...<br /><br />Full CGB renderer source:<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void PPU::cgb_render() {<br />&nbsp; for(auto&amp; pixel : pixels) {<br />&nbsp; &nbsp; pixel.color = 0x7fff;<br />&nbsp; &nbsp; pixel.palette = 0;<br />&nbsp; &nbsp; pixel.origin = Pixel::Origin::None;<br />&nbsp; }<br /><br />&nbsp; if(status.display_enable) {<br />&nbsp; &nbsp; cgb_render_bg();<br />&nbsp; &nbsp; if(status.window_display_enable) cgb_render_window();<br />&nbsp; &nbsp; if(status.ob_enable) cgb_render_ob();<br />&nbsp; }<br /><br />&nbsp; uint32* output = screen + status.ly * 160;<br />&nbsp; for(unsigned n = 0; n &lt; 160; n++) output&#91;n&#93; = video.palette&#91;pixels&#91;n&#93;.color&#93;;<br />&nbsp; interface-&gt;lcdScanline();<br />}<br /><br />//Attributes:<br />//0x80: 0 = OAM priority, 1 = BG priority<br />//0x40: vertical flip<br />//0x20: horizontal flip<br />//0x08: VRAM bank#<br />//0x07: palette#<br />void PPU::cgb_read_tile(bool select, unsigned x, unsigned y, unsigned&amp; tile, unsigned&amp; attr, unsigned&amp; data) {<br />&nbsp; unsigned tmaddr = 0x1800 + (select &lt;&lt; 10);<br />&nbsp; tmaddr += (((y &gt;&gt; 3) &lt;&lt; 5) + (x &gt;&gt; 3)) &amp; 0x03ff;<br /><br />&nbsp; tile = vram&#91;0x0000 + tmaddr&#93;;<br />&nbsp; attr = vram&#91;0x2000 + tmaddr&#93;;<br /><br />&nbsp; unsigned tdaddr = attr &amp; 0x08 ? 0x2000 : 0x0000;<br />&nbsp; if(status.bg_tiledata_select == 0) {<br />&nbsp; &nbsp; tdaddr += 0x1000 + ((int8)tile &lt;&lt; 4);<br />&nbsp; } else {<br />&nbsp; &nbsp; tdaddr += 0x0000 + (tile &lt;&lt; 4);<br />&nbsp; }<br /><br />&nbsp; y &amp;= 7;<br />&nbsp; if(attr &amp; 0x40) y ^= 7;<br />&nbsp; tdaddr += y &lt;&lt; 1;<br /><br />&nbsp; data&nbsp; = vram&#91;tdaddr++&#93; &lt;&lt; 0;<br />&nbsp; data |= vram&#91;tdaddr++&#93; &lt;&lt; 8;<br />&nbsp; if(attr &amp; 0x20) data = hflip(data);<br />}<br /><br />void PPU::cgb_render_bg() {<br />&nbsp; unsigned iy = (status.ly + status.scy) &amp; 255;<br />&nbsp; unsigned ix = status.scx, tx = ix &amp; 7;<br /><br />&nbsp; unsigned tile, attr, data;<br />&nbsp; cgb_read_tile(status.bg_tilemap_select, ix, iy, tile, attr, data);<br /><br />&nbsp; for(unsigned ox = 0; ox &lt; 160; ox++) {<br />&nbsp; &nbsp; unsigned index = ((data &amp; (0x0080 &gt;&gt; tx)) ? 1 : 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ((data &amp; (0x8000 &gt;&gt; tx)) ? 2 : 0);<br />&nbsp; &nbsp; unsigned palette = ((attr &amp; 0x07) &lt;&lt; 2) + index;<br />&nbsp; &nbsp; unsigned color = 0;<br />&nbsp; &nbsp; color |= bgpd&#91;(palette &lt;&lt; 1) + 0&#93; &lt;&lt; 0;<br />&nbsp; &nbsp; color |= bgpd&#91;(palette &lt;&lt; 1) + 1&#93; &lt;&lt; 8;<br />&nbsp; &nbsp; color &amp;= 0x7fff;<br /><br />&nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; pixels&#91;ox&#93;.origin = (attr &amp; 0x80 ? Pixel::Origin::BGP : Pixel::Origin::BG);<br /><br />&nbsp; &nbsp; ix = (ix + 1) &amp; 255;<br />&nbsp; &nbsp; tx = (tx + 1) &amp; 7;<br />&nbsp; &nbsp; if(tx == 0) cgb_read_tile(status.bg_tilemap_select, ix, iy, tile, attr, data);<br />&nbsp; }<br />}<br /><br />void PPU::cgb_render_window() {<br />&nbsp; if(status.ly - status.wy &gt;= 144u) return;<br />&nbsp; if(status.wx &gt;= 167u) return;<br />&nbsp; unsigned iy = status.wyc++;<br />&nbsp; unsigned ix = (7 - status.wx) &amp; 255, tx = ix &amp; 7;<br /><br />&nbsp; unsigned tile, attr, data;<br />&nbsp; cgb_read_tile(status.window_tilemap_select, ix, iy, tile, attr, data);<br /><br />&nbsp; for(unsigned ox = 0; ox &lt; 160; ox++) {<br />&nbsp; &nbsp; unsigned index = ((data &amp; (0x0080 &gt;&gt; tx)) ? 1 : 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ((data &amp; (0x8000 &gt;&gt; tx)) ? 2 : 0);<br />&nbsp; &nbsp; unsigned palette = ((attr &amp; 0x07) &lt;&lt; 2) + index;<br />&nbsp; &nbsp; unsigned color = 0;<br />&nbsp; &nbsp; color |= bgpd&#91;(palette &lt;&lt; 1) + 0&#93; &lt;&lt; 0;<br />&nbsp; &nbsp; color |= bgpd&#91;(palette &lt;&lt; 1) + 1&#93; &lt;&lt; 8;<br />&nbsp; &nbsp; color &amp;= 0x7fff;<br /><br />&nbsp; &nbsp; if(ox - (status.wx - 7) &lt; 160u) {<br />&nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.origin = (attr &amp; 0x80 ? Pixel::Origin::BGP : Pixel::Origin::BG);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; ix = (ix + 1) &amp; 255;<br />&nbsp; &nbsp; tx = (tx + 1) &amp; 7;<br />&nbsp; &nbsp; if(tx == 0) cgb_read_tile(status.window_tilemap_select, ix, iy, tile, attr, data);<br />&nbsp; }<br />}<br /><br />//Attributes:<br />//0x80: 0 = OBJ above BG, 1 = BG above OBJ<br />//0x40: vertical flip<br />//0x20: horizontal flip<br />//0x08: VRAM bank#<br />//0x07: palette#<br />void PPU::cgb_render_ob() {<br />&nbsp; const unsigned Height = (status.ob_size == 0 ? 8 : 16);<br />&nbsp; unsigned sprite&#91;10&#93;, sprites = 0;<br /><br />&nbsp; //find first ten sprites on this scanline<br />&nbsp; for(unsigned s = 0; s &lt; 40; s++) {<br />&nbsp; &nbsp; unsigned sy = oam&#91;(s &lt;&lt; 2) + 0&#93; - 16;<br />&nbsp; &nbsp; unsigned sx = oam&#91;(s &lt;&lt; 2) + 1&#93; -&nbsp; 8;<br /><br />&nbsp; &nbsp; sy = status.ly - sy;<br />&nbsp; &nbsp; if(sy &gt;= Height) continue;<br /><br />&nbsp; &nbsp; sprite&#91;sprites++&#93; = s;<br />&nbsp; &nbsp; if(sprites == 10) break;<br />&nbsp; }<br /><br />&nbsp; //render backwards, so that first sprite has highest priority<br />&nbsp; for(signed s = sprites - 1; s &gt;= 0; s--) {<br />&nbsp; &nbsp; unsigned n = sprite&#91;s&#93; &lt;&lt; 2;<br />&nbsp; &nbsp; unsigned sy = oam&#91;n + 0&#93; - 16;<br />&nbsp; &nbsp; unsigned sx = oam&#91;n + 1&#93; -&nbsp; 8;<br />&nbsp; &nbsp; unsigned tile = oam&#91;n + 2&#93; &amp; ~status.ob_size;<br />&nbsp; &nbsp; unsigned attr = oam&#91;n + 3&#93;;<br /><br />&nbsp; &nbsp; sy = status.ly - sy;<br />&nbsp; &nbsp; if(sy &gt;= Height) continue;<br />&nbsp; &nbsp; if(attr &amp; 0x40) sy ^= (Height - 1);<br /><br />&nbsp; &nbsp; unsigned tdaddr = (attr &amp; 0x08 ? 0x2000 : 0x0000) + (tile &lt;&lt; 4) + (sy &lt;&lt; 1), data = 0;<br />&nbsp; &nbsp; data |= vram&#91;tdaddr++&#93; &lt;&lt; 0;<br />&nbsp; &nbsp; data |= vram&#91;tdaddr++&#93; &lt;&lt; 8;<br />&nbsp; &nbsp; if(attr &amp; 0x20) data = hflip(data);<br /><br />&nbsp; &nbsp; for(unsigned tx = 0; tx &lt; 8; tx++) {<br />&nbsp; &nbsp; &nbsp; unsigned index = ((data &amp; (0x0080 &gt;&gt; tx)) ? 1 : 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ((data &amp; (0x8000 &gt;&gt; tx)) ? 2 : 0);<br />&nbsp; &nbsp; &nbsp; if(index == 0) continue;<br /><br />&nbsp; &nbsp; &nbsp; unsigned palette = ((attr &amp; 0x07) &lt;&lt; 2) + index;<br />&nbsp; &nbsp; &nbsp; unsigned color = 0;<br />&nbsp; &nbsp; &nbsp; color |= obpd&#91;(palette &lt;&lt; 1) + 0&#93; &lt;&lt; 0;<br />&nbsp; &nbsp; &nbsp; color |= obpd&#91;(palette &lt;&lt; 1) + 1&#93; &lt;&lt; 8;<br />&nbsp; &nbsp; &nbsp; color &amp;= 0x7fff;<br /><br />&nbsp; &nbsp; &nbsp; unsigned ox = sx + tx;<br />&nbsp; &nbsp; &nbsp; if(ox &lt; 160) {<br />&nbsp; &nbsp; &nbsp; &nbsp; //When LCDC.D0 (BG enable) is off, OB is always rendered above BG+Window<br />&nbsp; &nbsp; &nbsp; &nbsp; if(status.bg_enable) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(attr &amp; 0x80) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.origin == Pixel::Origin::BG || pixels&#91;ox&#93;.origin == Pixel::Origin::BGP) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.palette &gt; 0) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.origin = Pixel::Origin::OB;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; }<br />}</div>

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Mon Dec 09, 2013 11:18 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><img src="http://i.imgur.com/shRft9R.png" alt="Image" /><br /><br /><img src="http://i.imgur.com/0gD7oEu.png" alt="Image" /><br /><br />The reason that the bridge post is above Shantae's sprite is the priority bit in the BG attribute map, as you can see in BGB's excellent VRAM viewer. This also makes sense graphically, since she's walking between the posts. The priority bit is set for that tile, and the LCDC.0 is set, so clearly those tiles (except for palette 0) should overlap the sprite.<br /><br />Unless you're saying that some other part of the bridge is overlapping her sprite when you change the behavior? Screenshot?<br /><br /><img src="http://i.imgur.com/gpdCEcH.png" alt="Image" /><br /><br /><img src="http://i.imgur.com/qfudOKs.png" alt="Image" /><br /><br />I don't see how this how this would create a contradiction with Zelda OoA. The maroon hills, in the BG, don't have their priority bits set, so the sprite is on top. The ground tiles, in the window, do have their priority bits set, and the ground is drawn with palettes 1 and 2, not 0, so the ground overlaps the sprite.<br /><br />And while we're talking graphics... Considering the focus on cycle accuracy in the (B)SNES part of Higan, I'm surprised you went for a line based renderer and not a pixel based one. The program running on the GB CPU can still change various registers like SCX and SCY when a line is being drawn to the screen. (I.e. during mode 3.) At least one officially released game makes heavy used of that: Prehistorik Man which is using it in its intro to draw text using palette changes, and probably in some places in the gameplay as well. Not to mention demoscene demos, which (ab)use this a lot, for example Mental Respirator and 20Y, which use this for things like wobbly image stretching and other special effects.<br /><br /><img src="http://i.imgur.com/ulIdFLF.png" alt="Image" /> <img src="http://i.imgur.com/alJWP9w.png" alt="Image" /> <img src="http://i.imgur.com/UP6Vxht.gif" alt="Image" /> <img src="http://i.imgur.com/Xi5w2Ui.png" alt="Image" /><br /><br />And another &quot;while we're at it.&quot; I had to download v093r07 since Shantae didn't work in v093 and I saw this: &quot;I'm posting a beta release of higan, in the hopes of getting some feedback on the new library system (pictured below; more info on the forums), and reports of any potential new regressions before an official release.&quot;<br /><br />Regressions? You mean apart from the new &quot;features&quot;, including not being able to import files as a command line argument (useful for dragging and dropping a ROM file over higan.exe or a shortcut to it) or the now absent ability to organize one's ROMs in folders? I do appreciate the focus on accuracy in Higan, but I think the GUI/library aspect of the program is too driven by ideology, even removing legitimate features that don't have to interfere with the purity philosophy of the library. And just to state the obvious, you know my opinion on cross-loading GB and GBC files.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Tue Dec 10, 2013 12:10 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Ok, looking at the code, I think I see what the problem is. <br />Snippet #1 doesn't check the palette of the source pixel, so BG priority pixels overlap sprite pixels unconditionally.<br />Snippet #2 requires a BG priority pixel to *both* have sprite priority and BG priority to be considered for the palette check.<br /><br />I believe the correct solution is that a pixel is considered to have priority if one of two criteria are met:<br />1) The pixel has BG priority.<br />2) The pixel has sprite priority. This also implies an origin test for BG, so OB pixels aren't incorrectly handled. <br /><br />This gives the following code:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp; &nbsp; unsigned ox = sx + tx;<br />&nbsp; &nbsp; &nbsp; if(ox &lt; 160) {<br />&nbsp; &nbsp; &nbsp; &nbsp; //When LCDC.D0 (BG enable) is off, OB is always rendered above BG+Window<br />&nbsp; &nbsp; &nbsp; &nbsp; if(status.bg_enable) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.origin == Pixel::Origin::BGP || (attr &amp; 0x80 &amp;&amp; pixels&#91;ox&#93;.origin == Pixel::Origin::BG)) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(pixels&#91;ox&#93;.palette &gt; 0) continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.color = color;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.palette = index;<br />&nbsp; &nbsp; &nbsp; &nbsp; pixels&#91;ox&#93;.origin = Pixel::Origin::OB;<br />&nbsp; &nbsp; &nbsp; }<br /></div><br />Perhaps <strong>pixels[ox].origin == Pixel::Origin::BG</strong> should be replaced with <strong>pixels[ox].origin != Pixel::Origin::OB</strong> to be more &quot;correct&quot; but assuming there are only three sources (BG, BGP and OB) the two comparisons would be logically equivalent because of the left side of the ||.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Tue Dec 10, 2013 10:58 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Exophase helped out a lot with a priority list: BG0 &lt; OBJL &lt; BGL &lt; OBJH &lt; BGH<br />I was wrongly using: BG0 &lt; OBJL &lt; BGL | BGH &lt; OBJH<br /><br />You pretty much had it right as well, thank you.<br /><br />&gt; And while we're talking graphics... Considering the focus on cycle accuracy in the (B)SNES part of Higan, I'm surprised you went for a line based renderer and not a pixel based one.<br /><br />Well, the Game Boy is the least documented system I've ever worked on, by a full order of magnitude. I was afraid to implement a dot-based renderer without knowledge of when various memory values and registers are fetched.<br /><br />But yeah, since I'm working on the PPU, I may as well do it right. We can adjust the read timings later. So okay, I rewrote both the DMG and CGB renderers to be dot-based.<br /><br /><img src="http://i.imgur.com/x0jpHTB.png" alt="Image" /><br /><br />&gt; You mean apart from the new &quot;features&quot;, including not being able to import files as a command line argument (useful for dragging and dropping a ROM file over higan.exe or a shortcut to it) or the now absent ability to organize one's ROMs in folders? ... And just to state the obvious, you know my opinion on cross-loading GB and GBC files.<br /><br />I don't mean any offense, and I greatly appreciate your help here, but I've no interest in discussing these topics any more than I already have.<br /><br />The GUI is ethos, the core is higan. If you write a GUI for higan, you can support any methodology you like. My emulation cores also eventually appear in RetroArch, OpenEmu, Mednafen, etc.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Tue Dec 10, 2013 12:38 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">The GUI is ethos, the core is higan.</div><br />Then let me get this straight with a compiler analogy:<br /><br />GUI | ethos | Code::Blocks<br />Set of cores | GCC (GNU Compiler Collection) | higan<br />Individual core | gcc (GNU C Compiler) | bsnes<br /><br />Do I have the analogous terminology right?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Tue Dec 10, 2013 3:29 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Correct.<br /><br />The main point of confusion is that the official binary release is called by the emulator name instead of the GUI name. And that's because I've had about 10 GUIs now.<br /><br />Even more fun is that I refuse to be inconsistent in my emulator naming, so my GB/C emulator is also called bgb. But it's not like anyone sees the individual emulator names anymore, it's easier to just call it all higan. I am sure beware hates me even more for that though :P

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Wed Dec 11, 2013 9:32 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">&gt; And while we're talking graphics... Considering the focus on cycle accuracy in the (B)SNES part of Higan, I'm surprised you went for a line based renderer and not a pixel based one.<br /><br />Well, the Game Boy is the least documented system I've ever worked on, by a full order of magnitude. I was afraid to implement a dot-based renderer without knowledge of when various memory values and registers are fetched.<br /><br />But yeah, since I'm working on the PPU, I may as well do it right. We can adjust the read timings later. So okay, I rewrote both the DMG and CGB renderers to be dot-based.<br /><br /><img src="http://i.imgur.com/x0jpHTB.png" alt="Image" /></div>Fair enough. I understand your fear. But I thought you would start from the bottom up, so to speak. Time allowing, I'd be willing to test stuff and help you, maybe write test ROMs if needed. I'll first direct you to a dycp test by beware:<br /><br /><!-- m --><a class="postlink" href="http://akane.bircd.org/dycptest2.gb">http://akane.bircd.org/dycptest2.gb</a><!-- m --> <br /><br /><img src="http://akane.bircd.org/dycptest2.png" alt="Image" /><br /><br />Bottom = reference. Top = drawn with dycp (palette changes.) The reference image is valid on DMG, but not GBC (off by one) I suspect that GBC takes on extra (machine) cycle to look up the RGB value for the palette or something like that. Of course, there a couple of different variables that come into play. <br /><br />And yes, so much left to document, still.<br /><br />Another thing I plan to do at some point is to make a bus capture device. I think that's a relatively long way into the future, but I think it would definitely produce useful information.<br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">&gt; You mean apart from the new &quot;features&quot;, including not being able to import files as a command line argument (useful for dragging and dropping a ROM file over higan.exe or a shortcut to it) or the now absent ability to organize one's ROMs in folders? ... And just to state the obvious, you know my opinion on cross-loading GB and GBC files.<br /><br />I don't mean any offense, and I greatly appreciate your help here, but I've no interest in discussing these topics any more than I already have.<br /><br />The GUI is ethos, the core is higan. If you write a GUI for higan, you can support any methodology you like. My emulation cores also eventually appear in RetroArch, OpenEmu, Mednafen, etc.</div>I'm sorry about this. Maybe To give you some background, I didn't bring these things up here simply to be flippant. It came out of actual frustration (though admittedly microfrustration) while investigating the problems you asked about. <br /><br />Here are the events that lead up to that paragraph: Firstly, I organize the ROMs in Higan in folders, one folder for official games, and one for test/development ROMs, which are located in the GB and GBC folders in the library. So I started by importing the Shantae ROM into v093. It didn't work, so I downloaded v093r07. At that point I moved it to the &quot;official games&quot; folder by habit. I started v093r07 and noticed that my library was empty. (Since I had placed everything in subfolders.) I assumed the library had been moved to a different location or something, so I dragged the ROM file onto the window to reimport it. Didn't work. (I didn't think of trying to drag and drop the purified version at that point.) I quit Higan and tried to drop the file on the .exe. Also didn't work. When I went to import the game from the import tab, I remember thinking that it was silly. Something that should be simple took so many extra clicks to get done.<br /><br />That friction, together with being easily irritated from sleep deprivation and the fact that you asked for feedback, made me think it was good idea to complain about it. If one of those three things hadn't been true, I probably wouldn't have mentioned it. I apologize for the rash way of delivering the message. I should have put it differently and explained why, or maybe not have mentioned it at all.<br /><br />I'll however still maintain that those two things I mentioned don't necessarily violate the ethos of Higan. Ie: <br />1) Allow you to browse subfolders. Not free file system browsing, but allowing the user to browse folders they have created inside the different platforms' directories.<br />2) Drag and drop of non-pure ROM files. If you're concerned that people will abuse this to bypass the library, make those actions import the file without auto-starting it. Or show an error message. Anything is better than silently doing nothing here, imo.<br /><br />If you still don't want to discuss it further, no reply to this is needed. I get it.<div class="quotetitle">byuu wrote:</div><div class="quotecontent">Correct.<br /><br />The main point of confusion is that the official binary release is called by the emulator name instead of the GUI name. And that's because I've had about 10 GUIs now.<br /><br />Even more fun is that I refuse to be inconsistent in my emulator naming, so my GB/C emulator is also called bgb. But it's not like anyone sees the individual emulator names anymore, it's easier to just call it all higan. I am sure beware hates me even more for that though <img src="./images/smilies/icon_razz.gif" alt=":P" title="Razz" /></div>Thanks for clarifying this. I was wondering if the bsnes name was dead now. However, didn't the GB emulator use to be called bgameboy. I might just have made that up in my head to disambiguate it from beware's emulator. But if this was the case, why did you change the name? Not that it really matters, for the aforementioned reason.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Wed Dec 11, 2013 10:14 am ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; Top = drawn with dycp (palette changes.)<br /><br />Oh, fun. I made tests like that for the SFC. A lot harder there with things like a moving DRAM refresh locking the system every scanline, variable memory timings, fast-mode accesses, and penalty cycles abound.<br /><br />But the best way I found to log this information on hardware: first write a routine that synchronizes you to the exact first cycle of a new frame when called. Then write a function that consumes exactly N cycles when called (N taken from a register parameter. Then write a loop that syncs to frame, then seeks ++N cycles, does some hardware write, then logs the results or displays them onscreen. Very easy to find exact points when various values are read and written.<br /><br />Very, very time consuming, though.<br /><br />As for your test ROM:<br /><br /><img src="http://i.imgur.com/8QFlfEw.png" alt="Image" /><br /><br />Huh, looks like I made a pretty good guess as to when to start rendering the display. Only off by one or two pixels, but the effect still works.<br /><br />&gt; I was wondering if the bsnes name was dead now. However, didn't the GB emulator use to be called bgameboy.<br /><br />Yes, but I added GBA emulation and bgameboyadvance looked ugly. Of course now you could say bnes/bsnes should be bfc/bsfc with my UI naming things by their official names. So yeah, I much prefer to just call it all higan now.<br /><br />But it's much more like Mednafen where each emulator used has its own name, than like MESS. I'd love to emulate the N64 one day and complete the not-complete-crap (eg no VB) Nintendo cartridge generation, but CPUs aren't anywhere near fast enough for how I want to do it yet.<br /><br />&gt; Time allowing, I'd be willing to test stuff and help you, maybe write test ROMs if needed.<br /><br />I would greatly appreciate that! In that case, I'll just go ahead and post my current challenge instead of making another thread.<br /><br />In Donkey Kong Land, every ~30 frames you get a flickering effect:<br /><br /><img src="http://i.imgur.com/2SBVfsv.png" alt="Image" /> <img src="http://i.imgur.com/TxcVu7f.png" alt="Image" /><br /><br />Happens in v093 official too, not an artifact of recent rendering changes.<br /><br />Seems at the very bottom, the game sets SCX=0 for the little &quot;Select Game&quot; area at the bottom, and SCX=32 for the top of the screen.<br /><br />Watching a log, it seems that sometimes the second write misses the entire frame, and hits the next frame before it happens alone, and that causes the flickering.<br /><br />Downside is that I really don't know GB-Z80 at all, so tracelogs aren't all that helpful to me yet.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">frame&nbsp; //LY=0<br />20!&nbsp; //what we read back on Y=64,X=0<br />write at 127,0=00&nbsp; //LY=127, LX=0 (bottom window area) = &lt;SCX value written&gt;<br />write at 143,160=20&nbsp; //LY=143,LX=160 (end of display for next frame window area)<br />frame<br />20!<br />write at 127,0=00<br />write at 143,160=20<br />frame<br />20!<br />write at 127,0=00<br />frame<br />0!<br />write at 143,160=20<br />frame<br />20!<br />write at 127,0=00<br />write at 143,160=20<br />frame<br />20!<br />write at 127,0=00<br />write at 143,160=20<br />frame<br />20!<br />write at 127,0=00<br />frame<br />0!<br />write at 143,160=20<br />frame<br />20!<br />write at 127,0=00<br />write at 143,160=20</div><br /><br />Ever see that before?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Wed Dec 11, 2013 12:18 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />This one of those bugs that &quot;could be anything&quot;. But I'm looking into it.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Wed Dec 11, 2013 1:32 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />I think this is it.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void CPU::mmio_write(uint16 addr, uint8 data) {<br />&nbsp; if(addr == 0xff46) {&nbsp; //DMA<br />&nbsp; &nbsp; for(unsigned n = 0x00; n &lt;= 0x9f; n++) {<br />&nbsp; &nbsp; &nbsp; bus.write(0xfe00 + n, bus.read((data &lt;&lt; 8) + n));<br />&nbsp; &nbsp; //add_clocks(4);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return;<br />&nbsp; }<br />&nbsp; ...<br />}</div><br /><br />Without the time penalty for LCD OAM transfers, the problem goes away.<br /><br />I know this technically runs in parallel while the DMG CPU only reads from HRAM.<br /><br />Just implemented the transfer in parallel as an initial test, and the problem remains fixed. But man, that's a painful operation to do. I have to hook the OAM DMA transfer test in every clock tick of the CPU, and all of my opcode read/write functions need to also test for it and reject reads outside of HRAM.<br /><br />By the way, do you know what happens if you read from 0000-ff7f or ffff during an OAM DMA transfer? Does it mirror around to HRAM, or does it return the MDR (open bus)?

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Wed Dec 11, 2013 3:01 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Ugh! Yeah, that's all wrong. That behaves as if the CPU is halted while the OAM DMA is happening. In the end, it was really just a timing error from &quot;somewhere else&quot;. Right now I have breakpoints all over the place in BGB (beware's emulator; I will personally call your emulator bgameboy in the future to disambiguate it.) in the DKL ROM to look for suspicious stuff that might break. <br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">Just implemented the transfer in parallel as an initial test, and the problem remains fixed. But man, that's a painful operation to do. I have to hook the OAM DMA transfer test in every clock tick of the CPU, and all of my opcode read/write functions need to also test for it and reject reads outside of HRAM.</div>If it's any comfort, beware has decided against emulating the OAM inaccessibility accurately because of the effort it would take/inefficiency it would create. I think he even commented that if anyone would be crazy enough to implement it accurately, it would be you. <img src="./images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /><br /><br />beware does support <em>detecting</em> illegal access during OAM DMA. The way he does this (iirc - I may be hazy on the details) is as follows:<br />If interrupts are disabled, and the OAM routine follows the standard routine verbatim (true for 99% of games, but not DKL incidentally) nothing special is done, since illegal access would be impossible anyway. Otherwise (and if the user has the &quot;break on bad OAM DMA enabled in the exceptions) a special hidden access breakpoint (existing debug infrastructure) is set for reads/writes to 0000-feff. Said breakpoint expires based on a timer.<br /><br />I once suggested a slightly clusterfuckish idea to beware, which he rejected. Have a 256 place lookup table each for reads and writes which contains a function pointer for each position. These tables handle address decoding for reads and writes respectively. The index is the high byte of the address. During OAM, replace the pointers in index 0-254 with a special handler. This would be a relatively cheap way (in terms of CPU use) to handle the issue. And you really get the rest of the address decoding &quot;for free&quot; with this method, even if it would be a rewrite. Or slightly different, let the read and write handlers be function pointers, which you replace with a filter function during OAM DMA. <br /><br />I suspect this is a method you will reject as well.<br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">By the way, do you know what happens if you read from 0000-ff7f or ffff during an OAM DMA transfer? Does it mirror around to HRAM, or does it return the MDR (open bus)?</div>Neither. All addresses in the FFxx range are still accessible. What happens outside of that differs with the Gameboy type. I haven't investigated this fully, but here's what I know from my tests:<br /><br />On DMG, if you read illegal memory, you get back the currently transferred byte. <br /><br />On GBC, things are more complicated. If you read from the same memory area as the OAM source, you get the currently transferred DMA byte, just like on DMG. (What these memory areas are, exactly, depends on the GBC's internal memory decoding and remains to be investigated, but at the very least I know that ROM and WRAM are different areas.) <br /><br />But it gets even more hairy. In some circumstances when reading from a <em>different</em> memory area than the one the transfer source is in, there are still some side effects in some cases. I've yet to figure out exactly how this happens, but it could be something like ANDing the the lower 8 address bits with the DMA counter. <br /><br />Gambatte does emulate the first aspect of the bug on GBC (getting a DMA byte when reading from the same memory area.) but not the other.<br /><br />I have not investigated whether reading during OAM DMA corrupts the transfer. I have not investigated writes at all.<br /><br />There is only one game, which is not an official Nintendo release, that relies on the inaccessibility to be implemented to at least some capacity, <a href="http://furrtek.free.fr/superconnard/" class="postlink">Super Connard</a>. If you're wondering, that translates to Super Asshole and it's only used for emulator detection to display the text &quot;fuck you, emulator.&quot; As far I know, Gambatte is the only emulator that runs this ROM uncracked. The author of the ROM does recommend you to crack the ROM as an exercise.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>tepples</b> [ Wed Dec 11, 2013 4:19 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />Or going by the 3- or 4-character codes that appear on the cartridge: bhvc/bnes, bshvc/bsns, bdmg, bvue (complete crap), bnus (PCs may never be fast enough), bcgb, bagb, bntr (PCs may never be fast enough)

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Wed Dec 11, 2013 4:21 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; I will personally call your emulator bgameboy in the future to disambiguate it.<br /><br />Sure, that's perfectly acceptable and fine. He named his emulator first. You can also just say higan if you like.<br /><br />&gt; I think he even commented that if anyone would be crazy enough to implement it accurately, it would be you.<br /><br />:D<br /><br />Thing is, I probably won't get <em>too</em> insanely precise with my non-SNES cores. I hear the DMG LCD can actually halt its own clocking in order to catch up when it gets bogged down. I'm probably just going to target as close to 100% compatibility as I can get, along with emulating anything that I reasonably can.<br /><br />(I really want to emulate GBA prefetching behavior, but there's zero documentation on it, and I don't have the ability to run my own GBA code on hardware. And ARM scares the hell out of me anyway.)<br /><br />&gt; Said breakpoint expires based on a timer.<br /><br />Clever, since he has breakpoint stuff live in the official releases anyway.<br /><br />&gt; Or slightly different, let the read and write handlers be function pointers, which you replace with a filter function during OAM DMA.<br /><br />The indirection would happen on every read/write, making it probably more demanding than a conditional check inside of them. Same goes for having a memory remapping system.<br /><br />If you really want to absolutely avoid any impact on each individual read/write, your best method would be to overwrite the actual program code. You'd have to mark that page writable (VirtualProtect / mprotect) first, and then you could copy a smaller function that only does the HRAM read on top of the original op_read() function, and restore it when finished.<br /><br />This is certainly abusing the language (you'd get the function size by subtracting the next function address from the target function address), but since bgb is Windows-only and closed-source anyway, as long as it works it doesn't really matter.<br /><br />&gt; I suspect this is a method you will reject as well.<br /><br />I do something like this in my SNES emulator, where all memory is remappable. But the GB was simple enough that I don't think I bothered with a fancy memory system.<br /><br />&gt; If you're wondering, that translates to Super Asshole and it's only used for emulator detection to display the text &quot;fuck you, emulator.&quot;<br /><br />Heh. I've certainly dealt with emulator detections on the SNES. They pretty much use the least likely behavior to ever get emulated. d4s used the 12/16-step mul/div operations that run in parallel with the CPU for Breath of Fire II. Another person whose name escapes me detected the PRNG algorithm I used to initialize WRAM on power-on (it has a unique seed each run too, so it was pretty clever. I'll put a cryptographic RNG in there eventually.)<br /><br />&gt; Or going by the 3- or 4-character codes that appear on the cartridge<br /><br />If they were consistent to all regions, I would. SNES = shvc/sns/snsp/skor/etc.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>nitro2k01</b> [ Wed Dec 11, 2013 5:22 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">&gt; Said breakpoint expires based on a timer.<br /><br />Clever, since he has breakpoint stuff live in the official releases anyway.</div>Actually, he keeps them as separate as he can. Debug mode is pretty much turned on or off by a single conditional in the main loop. As long as debug mode is turned off, which it is in normal emulation mode, this check is not done/enabled at all. The purpose of BGB's DMA OAM detection is as a development aid, and has nothing to do with the emulation.<br /><br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">&gt; Or slightly different, let the read and write handlers be function pointers, which you replace with a filter function during OAM DMA.<br /><br />The indirection would happen on every read/write, making it probably more demanding than a conditional check inside of them. Same goes for having a memory remapping system.</div>You may or may not be right about that. If the CPU is smart about things, the table/function reference will stay in L2 cache, and the penalty isn't particularly hard. <br /><br />Just to be clear about what I mean, it's something like this. Slight modification to the idea: the OAM handlers are in the same table, with an offset of 512.<br /><br />Please excuse my rustiness in C(++), in case something below is syntactically wrong.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">uint8 (*gbread&#91;512&#93;) (uint16 addr);</div><br />Table of 2*256 pointers. For example, index 0-63 would contain a (the same) reference to the handler for bank 0 reads. Entries 256-510 contain OAM handers.<br />Usage:<div class="codetitle"><b>Code:</b></div><div class="codecontent">value = (*gbread&#91;(addr&gt;&gt;8)&amp;255 + oamoffset&#93;) (addr);</div><br />Normally, oamoffset = 0 , and oamoffset = 256 during OAM. <br /><br />It might be that this is more expensive than conditionals because of the memory access, but it can't be THAT bad considering you (presumably) already have a 256 place table of function references that you access frequently (the opcode decoder.)<br /><div class="quotetitle">byuu wrote:</div><div class="quotecontent">This is certainly abusing the language (you'd get the function size by subtracting the next function address from the target function address), but since bgb is Windows-only and closed-source anyway, as long as it works it doesn't really matter.</div>Note that he rejected my suggestion, and all code he's using is still kosher. Doing something like self-modifying code would very much go against his coding ideals, as far as I know them.

		

		</td>
	</tr>
	</table>


	<hr width="85%" />

	<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
	<tr>
		<td width="10%" nowrap="nowrap">Author:&nbsp;</td>
		<td><b>byuu</b> [ Wed Dec 11, 2013 8:00 pm ]</td>
	</tr>
	<tr>
		<td width="10%" nowrap="nowrap">Post subject:&nbsp;</td>
		<td><b>Re: Game Boy Color BG priority bit [solved]</b></td>
	</tr>
	<tr>
		<td colspan="2"><hr class="sep" />&gt; The purpose of BGB's DMA OAM detection is as a development aid, and has nothing to do with the emulation.<br /><br />Then I guess I don't understand what the performance issue is. I'd rather the emulation run at 2fps if it means faithfully recreating what users will see on real hardware under a development environment. But, to each their own.<br /><br />&gt; You may or may not be right about that. If the CPU is smart about things, the table/function reference will stay in L2 cache, and the penalty isn't particularly hard.<br /><br />The same is true of branch prediction on a path that's almost always false. But yeah, in practice it's really not a huge deal, it's just never a good thing putting more code in your innermost, hottest code paths.<br /><br />&gt; value = (*gbread[(addr&gt;&gt;8)&amp;255 + oamoffset]) (addr);<br /><br />Yeah, I understand.<br /><br />If you want to be horrified: bsnes has a table of 16,777,216 8-bit values. Each value is an ID to a vector of callback functions for read and write. So a memory access is: function[table[addr]](addr);<br /><br />This allows my manifest files to map data at one-byte granularity. Which some things actually rely on.<br /><br />Of course it murders cache and all of that, but oh well.<br /><br />&gt; Doing something like self-modifying code would very much go against his coding ideals, as far as I know them.<br /><br />And mine.<br /><br />Typically one who wants speed will do whatever it takes, whereas one who wants accuracy will do whatever is necessary. So he seems to be somewhere in the middle.

		

		</td>
	</tr>
	</table>


<hr width="85%" />

<table width="85%" cellspacing="3" cellpadding="0" border="0" align="center">
<tr>
	<td><span class="gensmall">Page <strong>1</strong> of <strong>2</strong></span></td>
	<td align="right"><span class="gensmall">All times are UTC - 7 hours </span></td>
</tr>
<tr>
	<td colspan="2" align="center"><span class="gensmall">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</span></td>
</tr>
</table>

</body>
</html>