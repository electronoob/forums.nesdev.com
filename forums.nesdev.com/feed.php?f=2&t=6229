<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
<link rel="self" type="application/atom+xml" href="http://forums.nesdev.com/feed.php?f=2&amp;t=6229" />

<title>nesdev.com</title>
<subtitle>NES Development and Strangulation Records message boards</subtitle>
<link href="http://forums.nesdev.com/index.php" />
<updated>2010-03-31T05:27:35-07:00</updated>

<author><name><![CDATA[nesdev.com]]></name></author>
<id>http://forums.nesdev.com/feed.php?f=2&amp;t=6229</id>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2010-03-31T05:27:35-07:00</updated>
<published>2010-03-31T05:27:35-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59355#p59355</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59355#p59355"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59355#p59355"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />So comparing the two, I see that yes, not assuming RAM contents allows you to use more debugging techniques, like random RAM filling, or even a NES emulator with something like <a href="http://valgrind.org/info/tools.html#memcheck" class="postlink">valgrind</a>, to find reads from uninitialized RAM.<br /></div><br />Ah, I was wondering if something like this existed. Maybe this could be implemented in FCEUX for example?<br /><br /><div class="quotetitle">Bregalad wrote:</div><div class="quotecontent"><br />But it's still a waste of bytes as opposed to simply have a loop that clears $000-$7ff and that takes ~10 bytes.<br /></div><br />I know it might seem more compact to clear everything at the start, but the thing is I don't think there are many variables that are initialized only once. Most of them need to be reset at one point or another (when a new level starts, when a new song starts, etc), so why not organize your code so that these resetting codes always act as the initializers of the variables, in a way that you wouldn't need a general memory reset? Looks much more organized to me.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Wed Mar 31, 2010 5:27 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2010-03-31T00:14:32-07:00</updated>
<published>2010-03-31T00:14:32-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59352#p59352</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59352#p59352"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59352#p59352"><![CDATA[
I don't think there is anything wrong or bad initializing the whole parts of memory. If you weren't doing it you would probably need to have a part of code that do something like this :<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"> lda #$00<br /> sta variable1<br /> sta blahblah<br /> sta blabhblahbalh<br /> .....<br /> ;one tousand lines long</div><br />Ok you don't clear other variables which are cleared with appropriate routines (such as stop_music) or that simply don't need any initialization, and in all cases you have to initialise some varialbles with other values than $00.<br /><br />But it's still a waste of bytes as opposed to simply have a loop that clears $000-$7ff and that takes ~10 bytes.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Wed Mar 31, 2010 12:14 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-31T00:05:25-07:00</updated>
<published>2010-03-31T00:05:25-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59351#p59351</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59351#p59351"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59351#p59351"><![CDATA[
tokumaru, you make good points about putting random values during debugging, but once you're ready for a release, leaving memory uninitialized seems a bad idea. You have to assume you still have bugs, perhaps some of the kind that depend on uninitialized memory. By clearing in a release build, you ensure that these will at least behave consistently on every machine, rather than breaking on that one guy's NES whose RAM powers up in a significantly different state than most others.<br /><br />It is true that many modules will be reinitialized multiple times in one session, being the ones that handle a level or similar. These can't rely on RAM contents, regardless of whether you clear RAM at power/reset. So if you took a bug-free game that assumed memory was cleared with zero and converted it to not assume so (and without simply adding a memory clear at the beginning <img src="http://forums.nesdev.com/images/smilies/icon_smile.gif" alt=":)" title="Smile" /> ) I doubt you'd add many source lines, perhaps 50 at most.<br /><br />So comparing the two, I see that yes, not assuming RAM contents allows you to use more debugging techniques, like random RAM filling, or even a NES emulator with something like <a href="http://valgrind.org/info/tools.html#memcheck" class="postlink">valgrind</a>, to find reads from uninitialized RAM. On the other hand, because it forces you to initialize every variable, it introduces more opportunities to forget initialization.<br /><br />At this point I'm thinking that the type of NES program is the main determiner of which gives the most benefit. Virtually all my NES programming has been of a shell-like environment for running test programs, where there is little module reinitialization, and where conciseness is a virtue. In a game where there is little that is initialized only once, I could see random-clear during dev/zero-clear during release being a better approach.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Wed Mar 31, 2010 12:05 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2010-03-30T21:38:49-07:00</updated>
<published>2010-03-30T21:38:49-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59342#p59342</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59342#p59342"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59342#p59342"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br /><div class="quotetitle">Celius wrote:</div><div class="quotecontent">Lots of my variables are accumulative values, meaning they SHOULD start from 0 and accumulate, like the Vblank count (well, this isn't necessarily something that has to start at 0, but it is accumulative).<br /></div><br />And will they always accumulate, the whole time the program is running? Don't you ever have to clear them at a certain point to start out "fresh" (like when going from one engine to another - main game to bonus game, for example)?</div><br />Not if the definition of the variable is "number of vertical blanks since reset". There are separate timer variables for game states.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">A really good example is like the RAM for my sound engine. It contains a lot of indexes that are used to index music data, starting at 0<br /></div><br />And don't you have to this on a per-song basis?</div><br />They have to be initialized before the game starts playing a song. Otherwise, the program would start playing garbage between power-on and when the first song starts. Setting sound_effect_time_left[ch] to 0, instrument_time_left[ch] to 0, and tempo to 0 helps suppress this.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I'm not suggesting people use the random values that might be in RAM, just that they initialize each variable as needed<br /></div><br />A lot of variables are needed from frame one, especially if you have an NMI routine that does more than just inc retraces. Such variables include vram_update_ready (0 = false), is_sprite_0_used (0 = false), and is_a_song_playing (0 = false). On a machine without unlimited space for init code, it can save space and time to define 0 to mean take no action, document this definition, and then spray zeroes.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Tue Mar 30, 2010 9:38 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2010-03-30T18:42:29-07:00</updated>
<published>2010-03-30T18:42:29-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59329#p59329</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59329#p59329"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59329#p59329"><![CDATA[
<div class="quotetitle">Celius wrote:</div><div class="quotecontent"><br />Clearing RAM isn't always a bad thing. Lots of my variables are accumulative values, meaning they SHOULD start from 0 and accumulate, like the Vblank count (well, this isn't necessarily something that has to start at 0, but it is accumulative).<br /></div><br />And will they always accumulate, the whole time the program is running? Don't you ever have to clear them at a certain point to start out "fresh" (like when going from one engine to another - main game to bonus game, for example)?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />A really good example is like the RAM for my sound engine. It contains a lot of indexes that are used to index music data, starting at 0, moving higher as the music plays (also there are indexes for volume envelopes). Not only that, it contains virtual registers which need to start out as 0, because my music engine sets bits of them individually. Since all 8 bits of a virtual register aren't updated every frame, and then they're copied to the actual sound registers, I cannot start out with a "random" or unknown value in them. It has to be initialized to 0.<br /></div><br />And don't you have to this on a per-song basis? Don't you have to do some sort of cleaning up/initialization every time a new song starts? Why not use this time to properly initialize all music-related variables?<br /><br />I'm not suggesting people use the random values that might be in RAM, just that they initialize each variable as needed, as a form of guarantee that whenever the variable is used it will hold a valid value, as opposed to relying on the value it was given god knows how long ago by God knows what part of the program.<br /><br />I often keep all my variable-resetting grouped by system, so each of the sub-systems in the game is responsible by initializing all of their variables, so I don't have to worry what was in RAM before. And it's not like clearing the memory only when necessary is slow or requires much code. I rarely need to clear arrays for example, because they usually have other variables that describe them. For example, a RAM slot used for dynamic objects doesn't need to have all the bytes cleared when an object is unloaded, I just have to flag the slot as empty. The next object that occupies that slot will initialize whatever it needs to, it won't have to worry about the trash left there by the previous object.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />If your code isn't working with a bunch of garbage in RAM, you're probably not properly initializing a value, in which case you'd like to find that out and fix the problem. But clearing RAM in that case is like a safety net.<br /></div><br />My point exactly. Would you rather have this safety net cover your ass and hide a mistake you made or would you rather make the error visible so that you could fix it? I'd rather detect every error I can.<br /><br />I don't know if I mentioned this here before, but during development I include at the start of my programs the opposite of a memory clearing routine, I have a memory trashing routine. If fills RAM with numbers from my pseudo-random number generator. Whenever I find a "fishy bug" I change the seed of the PRNG to see if there is any change in the buggy behavior.  It doesn't happen very often, but I believe I found a bug or two that way. Once I consider the program finished I remove that code.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Tue Mar 30, 2010 6:42 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Celius]]></name></author>
<updated>2010-03-30T18:17:56-07:00</updated>
<published>2010-03-30T18:17:56-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59328#p59328</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59328#p59328"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59328#p59328"><![CDATA[
Clearing RAM isn't always a bad thing. Lots of my variables are accumulative values, meaning they SHOULD start from 0 and accumulate, like the Vblank count (well, this isn't necessarily something that has to start at 0, but it is accumulative). A really good example is like the RAM for my sound engine. It contains a lot of indexes that are used to index music data, starting at 0, moving higher as the music plays (also there are indexes for volume envelopes). Not only that, it contains virtual registers which need to start out as 0, because my music engine sets bits of them individually. Since all 8 bits of a virtual register aren't updated every frame, and then they're copied to the actual sound registers, I cannot start out with a "random" or unknown value in them. It has to be initialized to 0.<br /><br />There are many many variables that act like this in my code, and most of them are grouped together, so I can use a nice little loop that clears them all. Don't get me wrong, some values aren't supposed to be 0, in which case I don't necessarily need or want to clear them. But I also see Blargg's point, though it could be used as an argument against clearing RAM. If your code isn't working with a bunch of garbage in RAM, you're probably not properly initializing a value, in which case you'd like to find that out and fix the problem. But clearing RAM in that case is like a safety net. Should there be something you overlooked, you won't have something like a program crash because you know the exact values in RAM.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=138">Celius</a> — Tue Mar 30, 2010 6:17 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-30T12:50:44-07:00</updated>
<published>2010-03-30T12:50:44-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59310#p59310</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59310#p59310"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59310#p59310"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">Which is what multi-threading is.<br /></div><br />Yes, but it's such a simplified version of it that it might be confusing to bring the term up right from the start.</div><br />I wasn't saying it should be presented as such, just noting that because it IS a form of multi-threading, that such issues as atomicity and inconsistency arise, and must be dealt with.<br /><br />I was thinking some about a NES tutorial. It'd start with CPU instructions, then move to graphics. At that point, you'd be doing many that wait for NMI, move things, then repeat. You'd start out with the minimal NMI that increments a counter, and explain how that works. Later, you'd start doing too much in a frame and show how this causes glitches. That would set the stage for expanding the NMI routine to do more than increment the counter. At that point, the student wouldn't have been burdened with threading issues, and would see a clear need for something beyond the single-threaded structure. You could then move the graphic update to NMI, but have the main thread update the shared data non-atomically, so that you occasionally got a different glitch. Then you could introduce the notion of atomic updates and why they're critical. Again, the student would see the clear need for it, rather than simply being told about it but not seeing it in practice. If I ever work on some NES tutorials, my main goal will be to do as much as possible with the things taught so far. This allows the student to have fun doing things with his knowledge so far. Since I'm doing more with less, he has more of a chance of mastering those few things he knows so far, before he moves on.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The only kind of clueless newbie I envision is one whose natural learning capacities have been destroyed by compulsory "education", and who now learn by rote.<br /></div><br />And wouldn't you agree that there are a lot of those? Some people simply want results, without caring much for what's behind those results.</div><br />A person who just wants results doesn't want to learn. This type of person is never my audience. You can't write NES games via a recipe approach.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I think that newbies should be trained to pay attention to their variables, and if you spoil them by giving them zeroed out memory they will fail to assimilate how important initializing variables in assembly language is.<br /></div><br />Yes, this is a good point in favor of not clearing. This is in favor of filling with random garbage that differs each run, in fact. Similar to tepples' shuffling idea for avoiding assumptions about variables' relative addresses.<br /><br />One of the strong reasons I clear all RAM is that it greatly reduces the unknowns. If you don't, your program may run fine in all the situations you test it in, but there are nearly 2^16384 possible starting states of RAM that you haven't tested. By clearing, you greatly reduce the possible states.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Tue Mar 30, 2010 12:50 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Banshaku]]></name></author>
<updated>2010-03-29T15:59:19-07:00</updated>
<published>2010-03-29T15:59:19-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59273#p59273</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59273#p59273"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59273#p59273"><![CDATA[
@Blarg and Tokumaru<br /><br />For the "clearing memory is evil", I don't know.  I always initialize my variables so this pre-initialization doesn't seems to break anything for me.  When you are in a early stage with a few variables, using a debugger and check the ram location, sometime the empty spot helps to find that you put N value a the wrong place because of the 00 values everywhere. It it was not initialized, sometime I would have never found those bugs has a beginner.<br /><br />As for the "only the counter in the NMI", I never went that way. From the beginning, I was expecting that I may have to produce a lot of data that will take time to decode so I went with flags and updating the content in NMI on demand. It felt natural to me. And one extra thing I added recently it to put the address of the NMI in RAM so I can change the address of this function "on demand" but I would not suggest that for beginner. This is just some test code and it's working fine when I need a completely different NMI function.<br /><br />edit:<br /><br />The argument about cleared memory could make it easier with a debugger is weak so I guess we should pass this one. For now, either way doesn't seems problematic. I just personally prefer to put all memory to zero out of habit.<br /><br />edit2:<br /><br />Removed comment about lj65/concentration room since the structures of files changed. Comments could have increased since the last time I saw the code and my remark could be not appropriate.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3559">Banshaku</a> — Mon Mar 29, 2010 3:59 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2010-03-29T14:15:13-07:00</updated>
<published>2010-03-29T14:15:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59259#p59259</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59259#p59259"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59259#p59259"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />Which is what multi-threading is.<br /></div><br />Yes, but it's such a simplified version of it that it might be confusing to bring the term up right from the start. IMO there should be more like a note at the end of the page explaining the technique that says "this is a simple form of multi-threading, if you want to know more, go to wikipedia".<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Flawed, bad, same thing. It's only flawed if it doesn't meet the requirements.<br /></div><br />The fact that I consider it flawed is probably just a consequence of me designing the kinds of game I like to design.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The only kind of clueless newbie I envision is one whose natural learning capacities have been destroyed by compulsory "education", and who now learn by rote.<br /></div><br />And wouldn't you agree that there are a lot of those? Some people simply want results, without caring much for what's behind those results.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Even deep understanding of LDA immediate is notable in my book.<br /></div><br />I agree.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I think tepples' approach is better than yours IN THE CONTEXT of people learning NES programming, up to the part where they do status bars, interrupts, etc. That's a lot of ground between.<br /></div><br />You are probably right, I shouldn't worry about this. When programmers get good enough to the point of adding those features they should be able to understand WHY a certain method would fail when it finally does.<br /><br />I seem to remember we've had newbies here before asking for the recipe of a status bar though. But they probably wouldn't have any problems with lag frames anytime soon.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />In your case, the bug would be easy to find: start the first level, let the player run through it, then start it again. If it behaves differently the second time, you forgot to initialize something.<br /></div><br />Yes, it's still debugable, but I feel like it encourages poor variable management. I think that newbies should be trained to pay attention to their variables, and if you spoil them by giving them zeroed out memory they will fail to assimilate how important initializing variables in assembly language is. IMO, that's even a poor simulation of what some high level languages do, because they also clear local variables, and in NES code I have never seen anyone bothering about clearing the variables used by each subroutine.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />A time when there are no more working NES units? *shudder*<br /></div><br />Really scary. Fortunately there are people working hard to clone it, let's just hope they succeed! =)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Mon Mar 29, 2010 2:15 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[blargg]]></name></author>
<updated>2010-03-29T13:34:13-07:00</updated>
<published>2010-03-29T13:34:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59253#p59253</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59253#p59253"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59253#p59253"><![CDATA[
<div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br /><div class="quotetitle">blargg wrote:</div><div class="quotecontent">Maybe I didn't read your objection carefully. I thought you were suggesting an NMI handler that did more than increment a counter, as something to teach a new programmer before the model tepples described.<br /></div> <a href="http://nesdev.com/bbs/viewtopic.php?p=59122#59122" class="postlink">This</a> was my original suggestion. I don't think it's too overwhelming.</div> Agreed. Your example also shows the simplicity very well.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />IMO what goes on in the NMI is hardly multi-threading [...] They must understand that the main program WILL be interrupted at certain points in time and they must write a separate piece of code to handle that situation.<br /></div> Which is what multi-threading is. Any shared data structures must be updated atomically. Basically you must use <a href="http://en.wikipedia.org/wiki/Non-blocking_synchronization" class="postlink">lock-free techniques</a>.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I did object to the dissemination of a piece of code that I considered flawed<br /></div> Flawed, bad, same thing. It's only flawed if it doesn't meet the requirements. If the game were doing a status bar or whatever, or did VRAM updates and could fall to 30 FPS sometimes, then I agree it would be a flawed approach since it would glitch. If it won't glitch, AND it reduces complexity, I call that success, not flawed.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Some of them [NES newbies] come from other systems or languages, and have enough knowledge to experiment with the "difficult" stuff, so I think that information should be offered somewhere.<br /></div> Absolutely. I at least have a vision of NES tutorial materials covering the spectrum. BTW, you referred to "clueless newbie". The only kind of clueless newbie I envision is one whose natural learning capacities have been destroyed by compulsory "education", and who now learn by rote. I always try to counter this by encouraging involvement and experimentation, so that deep understanding can be achieved. Even deep understanding of LDA immediate is notable in my book.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I DID say tepples' was bad because of it's limitations, but I DIDN'T say the other method was the best, I just mentioned it didn't have the same shortcomings.<br /></div> Everything has shortcomings, and those are liabilities in some contexts. In others, they are not a problem. If these shortcomings are due to benefits the approach also has, then it will be superior in some contexts. If you have a way that is just as good or better than tepples' in all aspects, THEN I won't object to you offering it as all-around better.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Since there seems to be some kind of consensus that tepples' way to handle VBlanks is the easiest one for newbies, I'll just have to shut up on this one, even though I don't agree with it. But I'm sure there will eventually be people asking "why is my status bar jumping", if these newbies persist enough to make a scrolling game.<br /></div> I'm all for discussion of the good and bad aspects of an approach, especially in a particular context, and comparisons to other approaches. But I'm against "this is bad, get rid of it" kinds of "discussion".<br /><br />Your main argument for "your" approach seems to be that it will handle more advanced game designs better. But why not argue for an even more complex one, since it can handle even more than yours? I think tepples' approach is better than yours IN THE CONTEXT of people learning NES programming, up to the part where they do status bars, interrupts, etc. That's a lot of ground between.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Another thing I happen to not agree with is clearing the whole memory to 0. Say, if a person forgets to initialize a variable before starting a level, but everything works fine because the variable was cleared at the beginning of the program. Now, when the second level starts and the variable is no longer 0, something goes wrong. Wouldn't you say this bug would be harder to catch, since the first level worked fine but the second one didn't?<br /></div> Again, I'd love to have a discussion of the relative merits of each approach, without one side believing that his approach is better and that he simply needs to make the other believe the same. Even though I prefer clearing, I am open to discussion of both. Ideally, we'd explore the issue from a fresh perspective and consider all the approaches, even beyond clearing or not clearing. In your case, the bug would be easy to find: start the first level, let the player run through it, then start it again. If it behaves differently the second time, you forgot to initialize something.<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />[...] I don't think I'll even abandon NESDEV, even when I'm 80 years old or so. I just hope that by then someone will have successfully made an accurate NES clone, otherwise we'll probably have to rely solely on emulators... =)<br /></div> That's a scary thought... I wish you hadn't mentioned that. A time when there are no more working NES units? *shudder*<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=17">blargg</a> — Mon Mar 29, 2010 1:34 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Ian A]]></name></author>
<updated>2010-03-29T06:24:10-07:00</updated>
<published>2010-03-29T06:24:10-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59229#p59229</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59229#p59229"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59229#p59229"><![CDATA[
One of the reasons why I check the forum frequently is to get different views on how to do things.  Sometimes someone explains something in a way that is easier for me to understand, though not necessarily for everyone else to understand.<br /><br />That being said, I'm interested to hear more about this memory clearing routine.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=4250">Ian A</a> — Mon Mar 29, 2010 6:24 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tepples]]></name></author>
<updated>2010-03-29T04:03:22-07:00</updated>
<published>2010-03-29T04:03:22-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59225#p59225</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59225#p59225"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59225#p59225"><![CDATA[
<div class="quotetitle">Banshaku wrote:</div><div class="quotecontent"><br />but let face it: even thought we know more than the people back in the days, how many projects near what we could call a real game "went out of door"?<br /></div><br />They got paid to develop for NES. Most of us don't, apart from Sivak.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />A few people simply decided on what pieces of code are newbie friendly (including the evil memory clearing routine I seriously disagree with)<br /></div><br />What exactly do you mean by this? If you mean the loop that clears $0200-$07FF to zero, then remember that ca65 was originally designed for use with cc65. The C language <em>requires</em> uninitialized static-allocated variables to start at 0 (for ints) or NULL (for pointers) by the first line of main(). <br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />And when I voice my own opinions of how I think is the best way to do things, bringing up the flaws in other methods, like in this thread, I get yelled at like I'm doing something wrong.<br /></div><br />Perhaps they just disagree that there is one best way. I just shied away from trying to explain a separate thread because preemptive multitasking operating systems don't have a concept of uninterruptible threads. On NES, if thread N interrupts M, every change that N makes appear atomic to M. But on PC, threads M and N can interrupt each other, and newbie attempts at threading lead to race conditions on one hand and deadlocks on the other. But once I realized when your method is useful and how the locking is easier than on a preemptive multitasking system, I put it on the wiki right away.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />but could you write a side-scrolling engine that has a status bar at the top that never flickers or shakes during lag frames without making use of the NMI thread?<br /></div><br />You can't write a side-scroller that never flickers unless you never have more than four things in play at one time. More than four, and at least the sprites will flicker once they are horizontally aligned due to the PPU's 25% overdraw limit.<br /><br /><div class="quotetitle">tokumaru wrote:</div><div class="quotecontent"><br />But I'm sure there will eventually be people asking "why is my status bar jumping", if these newbies persist enough to make a scrolling game.<br /></div><br />Most of them don't even know how to make a scrolling field longer than 512 pixels because they've never cared to watch a program update the nametable "at the seam". But I guess this discussion did have a positive result: an answer to the question has been added to the wiki.<br /><br />-- Why is my status bar jumping?<br />-- You could have lag frames, and your program isn't seeing the NMI or sprite zero hit during those frames.<br />-- How do I fix it?<br />-- Optimize your code to make lag frames happen less often. Or do your VRAM updates in the <a href="http://wiki.nesdev.com/w/index.php/NMI_thread" class="postlink">NMI thread</a>. Or both.<br /><br /><div class="quotetitle">Orsi wrote:</div><div class="quotecontent"><br />there are absolutely no actual 'games' with decent, readable source code available to read. Everything is either a demo or too complicated to read.<br /></div><br />Read through <a href="http://lj65.org/" class="postlink">LJ65</a> and <a href="http://www.pineight.com/croom/" class="postlink">Concentration Room</a> and let me know about anything you don't understand so I can add better comments.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=9">tepples</a> — Mon Mar 29, 2010 4:03 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bregalad]]></name></author>
<updated>2010-03-29T02:09:26-07:00</updated>
<published>2010-03-29T02:09:26-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59224#p59224</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59224#p59224"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59224#p59224"><![CDATA[
Well it gets firey here...<br />I just think there is not an option better than the other. The wiki might just mention the existance of 3 ways you do it :<br />- Everything in main<br />- Everything in NMI<br />- Separate thread<br /><br />And not make any advertisement for one over another, but objectively states the inconvenient of each ones. Anyone, newbie or experienced, should be able to choose the one he likes best.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=38">Bregalad</a> — Mon Mar 29, 2010 2:09 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[tokumaru]]></name></author>
<updated>2010-03-28T23:46:13-07:00</updated>
<published>2010-03-28T23:46:13-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59222#p59222</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59222#p59222"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59222#p59222"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />Maybe I didn't read your objection carefully. I thought you were suggesting an NMI handler that did more than increment a counter, as something to teach a new programmer before the model tepples described.<br /></div><br /><a href="http://nesdev.com/bbs/viewtopic.php?p=59122#59122" class="postlink">This</a> was my original suggestion. I don't think it's too overwhelming. I think it's only more complex than tepples' solution because there is a special check for incomplete frames, but the remaining elements are basically the same. Also the VRAM updates are inside the NMI routine. Since the OP wasn't a clueless newbie I figured it would would be OK to offer him that solution.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />Multi-threaded programming is a subject even experienced programmers regularly screw up, and spend hours or days tracking down bugs in. It's true that an NMI routine is simpler in that the NMI "thread" can't be interrupted by the main thread, but it's still tricky when there are shared data structures you can't atomically update.<br /></div><br />IMO what goes on in the NMI is hardly multi-threading, because in fact we don't expect the two threads to run concurrently at all, we just take advantage of the fact that they do in case calculations took too long.<br /><br />I think all that a person has to understand in order to not be confused by this is the concept of interrupts. They must understand that the main program WILL be interrupted at certain points in time and they must write a separate piece of code to handle that situation.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />How would I fail? If it weren't possible, I wouldn't try to. What I meant was that I wouldn't start out with multiple threads (main thread + NMI interrupt routine) unless it offered benefits worth its cost.<br /></div><br />You probably wouldn't fail if it was a card game, but could you write a side-scrolling engine that has a status bar at the top that never flickers or shakes during lag frames without making use of the NMI thread? I don't think there's a way. Unless you use IRQs, but the concept of an IRQ thread is basically the same of an NMI thread so there would be no point in that.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I'm arguing that every manner of writing a NES program is proper in some context, and that tepples' suggestion to have an NMI routine that does nothing more than increment a counter is valid for a good number of NES programs and games.<br /></div><br />I guess it is. Maybe I just can't stop thinking about its drawbacks because of the kind of game I'm used to design, so to me it seemed wrong to suggest something that might (I know it's a big "might") cause problems in the future while another valid suggestion was already given and apparently understood by the OP. But I realize that for most people tepples' approach "just works".<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The kind of thinking that limits me is that of "method X is the one to use in all cases, method Y should never be considered". Again, I may be reading your wrong, in which case I apologize.<br /></div><br />I did object to the dissemination of a piece of code that I considered flawed, but I didn't say my way was THE way. I surely consider it better than the other one, but not the absolute best one.<br /><br />Sometimes it seems that the beginners don't have a choice, since it's the simplest things that are always offered to them. But not all beginners are absolute programming newbies... Some of them come from other systems or languages, and have enough knowledge to experiment with the "difficult" stuff, so I think that information should be offered somewhere. I found it good that tepples decided to make a page about NMI threads.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />The problem I had was that it seemed you were arguing for ONE TRUE APPROACH, that tepples' method was bad because it couldn't handle every possible game.<br /></div><br />I DID say tepples' was bad because of it's limitations, but I DIDN'T say the other method was the best, I just mentioned it didn't have the same shortcomings. Since there seems to be some kind of consensus that tepples' way to handle VBlanks is the easiest one for newbies, I'll just have to shut up on this one, even though I don't agree with it. But I'm sure there will eventually be people asking "why is my status bar jumping", if these newbies persist enough to make a scrolling game.<br /><br />Another thing I happen to not agree with is clearing the whole memory to 0. Say, if a person forgets to initialize a variable before starting a level, but everything works fine because the variable was cleared at the beginning of the program. Now, when the second level starts and the variable is no longer 0, something goes wrong. Wouldn't you say this bug would be harder to catch, since the first level worked fine but the second one didn't? Personally I'd rather not clear the memory and use soft resets to verify if my programs work the same every time or if I forgot to initialize something.<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"><br />I worry that once I am ready to focus on Nesdev, everyone will have left for other systems. <img src="http://forums.nesdev.com/images/smilies/icon_sad.gif" alt=":(" title="Sad" /><br /></div><br />Some people (myself included) have been around for too long to just leave now, so I wouldn't worry about that. I don't think I'll even abandon NESDEV, even when I'm 80 years old or so. I just hope that by then someone will have successfully made an accurate NES clone, otherwise we'll probably have to rely solely on emulators... =)<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=95">tokumaru</a> — Sun Mar 28, 2010 11:46 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Banshaku]]></name></author>
<updated>2010-03-28T23:07:28-07:00</updated>
<published>2010-03-28T23:07:28-07:00</published>
<id>http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59221#p59221</id>
<link href="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59221#p59221"/>
<title type="html"><![CDATA[How to wait for vblank]]></title>

<content type="html" xml:base="http://forums.nesdev.com/viewtopic.php?t=6229&amp;p=59221#p59221"><![CDATA[
<div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />But hell, I stopped visiting here for many months last year because it was too overwhelming for me, and I see it still is. I couldn't find the energy to work on the Wiki, and I'm sorry about that.<br /></div><br /><br />Don't worry about the wiki, there was no obligation and sometime there is things in life that have more priority. Contribute once you feel up to it, that's all.  You were gone for a while so I was starting to supect you could have been hit by a truck or something. Good thing it's not the case <img src="http://forums.nesdev.com/images/smilies/icon_razz.gif" alt=":P" title="Razz" /><br /><br /><div class="quotetitle">blargg wrote:</div><div class="quotecontent"><br />So I have little ground to stand on. I've got projects I need to complete, that aren't NES-related, and I should focus on those. I worry that once I am ready to focus on Nesdev, everyone will have left for other systems. <img src="http://forums.nesdev.com/images/smilies/icon_sad.gif" alt=":(" title="Sad" /><br /></div><br /><br /><strong>&lt;TryingToBeFunny&gt;</strong>As long as the "geezers" on nesdev like me, Tepples, Tokumaru, Bregalad, Memblers, Dwedit, Zeppers, Celius etc contribute, nesdev will live on!! <strong>&lt;/TryingToBeFunny&gt;</strong> ... Or something like that <img src="http://forums.nesdev.com/images/smilies/icon_wink.gif" alt=";)" title="Wink" />  It's not ready to go away yet by all means.<p>Statistics: Posted by <a href="http://forums.nesdev.com/memberlist.php?mode=viewprofile&amp;u=3559">Banshaku</a> — Sun Mar 28, 2010 11:07 pm</p><hr />
]]></content>
</entry>
</feed>